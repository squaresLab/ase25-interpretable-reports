
    
    --- original_falcon180b-5886.c 
    +++ fixed_falcon180b-5886.c 
    @@ -11,6 +11,7 @@
    #include <pthread.h>
    
    #define MAX_CLIENTS 50
    +#define MAX_THREADS 50
    #define PORT 8080
    #define BUFFER_SIZE 1024
    
    @@ -19,12 +20,17 @@
    int num_clients = 0;
    pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;
    
    +int client_threads[MAX_THREADS];
    +
    void *handle_client(void *arg) {
        int client_socket = *(int *) arg;
        char buffer[BUFFER_SIZE];
    
        while (1) {
            memset(buffer, 0, BUFFER_SIZE);
    +       int bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0); // To handle buffer overflow 
    +
    +       if (bytes_received <= 0) {
    +           buffer[BUFFER_SIZE - 1] = '\0'; // Null-terminate buffer
                printf("Client %d disconnected\n", client_socket);
    -           close(client_socket);
                pthread_mutex_lock(&clients_mutex);
                for (int i = 0; i < num_clients; i++) {
                    if (clients[i] == client_socket) {
                        clients[i] = -1;
                        break;
                    }
                }
                pthread_mutex_unlock(&clients_mutex);
                close(client_socket);
                return NULL;
            }
    
            printf("Client %d sent: %s\n", client_socket, buffer);
    
            pthread_mutex_lock(&clients_mutex);
            for (int i = 0; i < num_clients; i++) {
                if (clients[i] != client_socket && clients[i] > 0) {
                    send(clients[i], buffer, strlen(buffer), 0);
                }
            }
            pthread_mutex_unlock(&clients_mutex);
        }
    }
    
    +void cleanup_threads() {
    +    for (int i = 0; i < MAX_THREADS; i++) {
    +        if (client_threads[i] != 0) {
    +            pthread_cancel(client_threads[i]);
    +        }
    +    }
    +}
    +
    void broadcast(int sender_socket, char *message) {
        pthread_mutex_lock(&clients_mutex);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i] > 0 && clients[i]!= sender_socket) {
                send(clients[i], message, strlen(message), 0);
            }
        }
        pthread_mutex_unlock(&clients_mutex);
    }
    
    int main() {
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    
        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(PORT);
        server_addr.sin_addr.s_addr = INADDR_ANY;
    
        bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
        listen(server_socket, 3);
    
        printf("Chat server started on port %d\n", PORT);
    
        while (1) {
            int client_socket = accept(server_socket, NULL, NULL);
    
            pthread_mutex_lock(&clients_mutex);
            if (num_clients >= MAX_CLIENTS) {
                send(client_socket, "Server is full\n", 16, 0);
                close(client_socket);
                pthread_mutex_unlock(&clients_mutex);
                continue;
            }
            clients[num_clients] = client_socket;
    +       client_threads[num_clients] = pthread_self(); // Store thread ID
            num_clients++;
            pthread_mutex_unlock(&clients_mutex);
    
            pthread_t thread_id;
    +       pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    
    +   cleanup_threads();
    +   close(server_socket);
        return 0;
    }
    
    