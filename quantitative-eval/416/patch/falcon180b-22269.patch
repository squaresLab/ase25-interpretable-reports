 

--- falcon180b-22269.c
+++ falcon180b-22269.c
@@ -23,13 +23,15 @@
 
 void *handle_client(void *client_socket) {
     int client_socket_copy = *((int *) client_socket);
+    free(client_socket); // Free the dynamically allocated memory
 
     char buffer[1024];
     while (1) {
         memset(buffer, 0, sizeof(buffer));
         int bytes_received = recv(client_socket_copy, buffer, sizeof(buffer), 0);
         if (bytes_received <= 0) {
             break;
         }
+        buffer[sizeof(buffer)-1] = '\0'; // Ensure NULL termination
         printf("Client %d sent: %s", client_socket_copy, buffer);
         send(client_socket_copy, buffer, strlen(buffer), 0);
     }
@@ -37,9 +39,12 @@
 
     close(client_socket_copy);
     return NULL;
 }
 
 int main() {
-    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
+    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
+    if (server_socket == -1) {
+        perror("Socket creation failed");
+        exit(EXIT_FAILURE);
+    }
     struct sockaddr_in server_addr;
     memset(&server_addr, 0, sizeof(server_addr));
     server_addr.sin_family = AF_INET;
@@ -54,6 +59,7 @@
         int client_socket = accept(server_socket, NULL, NULL);
         if (client_socket == -1) {
             printf("Error accepting connection\n");
             continue;
         }
+        
         if (num_clients >= MAX_CLIENTS) {
             printf("Maximum number of clients reached\n");
             close(client_socket);
@@ -62,6 +68,10 @@
         }
 
         clients[num_clients] = client_socket;
         num_clients++;
 
         pthread_t thread_id;
-        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
+        int *client_sock_ptr = malloc(sizeof(int));
+        if (client_sock_ptr == NULL) {
+            perror("Failed to allocate memory");
+            close(client_socket);
+            continue;
+        }
+        *client_sock_ptr = client_socket;
+        pthread_create(&thread_id, NULL, handle_client, (void *) client_sock_ptr);
     }

     return 0;
 }

