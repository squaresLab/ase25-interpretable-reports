
vuln-fix: Concurrent Modification of Shared Resource (CWE-366) in falcon180b-71724 (severity: Medium)
what: The code has a vulnerability related to concurrent modification of the `num_clients` variable without proper synchronization. This shared resource is modified in the `handle_client` function and in the main loop when new clients connect.
where: The modification of `num_clients` variable occurs at the following locations:
- Line 29: `num_clients--;`
- Line 15: `int num_clients = 0;`
- Line 71: `num_clients++;`
why: If the weakness is not resolved, it could lead to undefined behavior, potential crashes, or inconsistent data states due to race conditions. For example, the `num_clients` variable could be corrupted if multiple threads increment or decrement it simultaneously without synchronization.
how: An attacker could potentially exploit this vulnerability by creating multiple client connections quickly. This would increase the chances of causing race conditions and possibly crash the server or corrupt its state.
code-sources: The entry point for user input is the client socket which is used to receive data from connected clients. Specifically:
- Line 23: `recv(client_socket, buffer, BUFFER_SIZE, 0);`
code-sinks: User input is used and acknowledged at:
- Line 31: `send(client_socket, buffer, strlen(buffer), 0);`
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define TRUE 1
#define FALSE 0
#define NUM_THREADS 5

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

sem_t mutex;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
+        sem_wait(&mutex);
        if (num_clients == 0) {
+            sem_post(&mutex);
            break;
        }

        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf("Client disconnected\n");
            close(client_socket);
            num_clients--;
+            sem_post(&mutex);
            pthread_exit(NULL);
        }

        printf("Received message from client: %s\n", buffer);
        send(client_socket, buffer, strlen(buffer), 0);
+        sem_post(&mutex);
    }
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;

    sem_init(&mutex, 0, 1);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf("Server is listening on port 8080\n");

    while (1) {
        int client_socket;
        socklen_t client_len;

        client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &client_len);

+        sem_wait(&mutex);
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf("Server is full\n");
+            sem_post(&mutex);
        } else {
+            client_sockets[num_clients] = client_socket;
            num_clients++;

            printf("New client connected\n");

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_sockets[num_clients - 1]);
+            sem_post(&mutex);
        }
    }

    return 0;
}
```
explanation-suggested-fix: The suggested fix ensures that all modifications to the `num_clients` variable are performed within the critical section guarded by the mutex. This prevents race conditions by ensuring only one thread can increment or decrement `num_clients` at a time. Additionally, changes are made to ensure that critical sections are not prematurely exited without signalling the mutex.
method: UNKNOWN
