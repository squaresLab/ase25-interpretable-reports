
vuln-fix: CWE-830: Inclusion of Functionality from Untrusted Control Sphere in falcon180b-59779 (severity: Medium)
what: The code passes the address of a variable to `pthread_create`, leading to a race condition where multiple threads could overwrite each other's `col` value due to the use of the same memory address.
where: The vulnerability is located in the `pthread_create` function call in the `main` function, specifically in the block:
```c
for (i = 0; i < num_threads; i++) {
    int row = start_row + i * (end_row - start_row) / num_threads;
    int col = start_col + i * (end_col - start_col) / num_threads;
    pthread_create(&threads[i], NULL, runner, (void *)&col);
}
```
why: If this weakness is not resolved, threads may incorrectly share the same `col` value, causing inconsistent updates to the `grid`. This can lead to undefined behavior and potentially critical errors in the programâ€™s execution.
how: An attacker could exploit this vulnerability by triggering conditions under which multiple threads execute concurrently, leading to a race condition where each thread might attempt to access and modify shared data unpredictably.
code-sources: The variable `col` in the `main` function before being passed to `pthread_create`.
code-sinks: The `runner` function which uses `col` to index `grid`.
suggested-fix: 
```c
diff --git a/falcon180b-59779 b/falcon180b-59779
index e69de29..b3359a1 100644
--- a/falcon180b-59779
+++ b/falcon180b-59779
@@ -31,7 +31,12 @@ int main() {
 
     pthread_t threads[num_threads];
 
-    for (i = 0; i < num_threads; i++) {
+    int *cols = malloc(sizeof(int) * num_threads);
+    if (cols == NULL) {
+        perror("malloc failed");
+        exit(EXIT_FAILURE);
+    }
+    for (i = 0; i < num_threads; i++) {
         int row = start_row + i * (end_row - start_row) / num_threads;
-        int col = start_col + i * (end_col - start_col) / num_threads;
-        pthread_create(&threads[i], NULL, runner, (void *)&col);
+        cols[i] = start_col + i * (end_col - start_col) / num_threads;
+        pthread_create(&threads[i], NULL, runner, (void *)&cols[i]);
     }
 
@@ -39,6 +44,7 @@ int main() {
     for (i = 0; i < num_threads; i++) {
         pthread_join(threads[i], NULL);
     }
+    free(cols);
 
     return 0;
 }
```
explanation-suggested-fix: The suggested fix allocates memory for an array of column indices (`cols`), ensuring each thread gets a unique pointer to its column index. This prevents multiple threads from sharing the same memory address for `col`, thus avoiding the race condition.
method: UNKNOWN
