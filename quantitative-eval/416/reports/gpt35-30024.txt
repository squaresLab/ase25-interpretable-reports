 
vuln-fix: Unbounded Write (CWE-120, CWE-787, CWE-805) in gpt35-30024 (severity: High)
what: The code contains multiple instances where user input is copied into fixed-size buffers without proper bounds checking, which can lead to buffer overflow vulnerabilities.
where: The vulnerabilities are found in gpt35-30024 at lines 96, 98, and 103.
why: If not resolved, these vulnerabilities could allow an attacker to perform arbitrary code execution or cause the application to crash.
how: An attacker could exploit this vulnerability by providing an input longer than the allocated buffer size, leading to a buffer overflow. This can result in overwriting adjacent memory, which might execute malicious code or cause the application to crash.
code-sources: 
1. Line 96: User input for "name"
2. Line 98: User input for "email_address"
3. Line 103: User input for "email_address" (to delete an email)
code-sinks: 
1. Line 96: The `scanf` function can write input beyond the `name` buffer's capacity.
2. Line 98: The `scanf` function can write input beyond the `email_address` buffer's capacity.
3. Line 103: The `scanf` function can write input beyond the `email_address` buffer's capacity.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to store email addresses
typedef struct email {
    char name[50];
    char email_address[100];
    struct email *next;
} email_t;

// Function to add a new email to the mailing list
void add_email(email_t **mailing_list, char *name, char *email_address) {
    // Allocate memory for new email
    email_t *new_email = (email_t *)malloc(sizeof(email_t));
    if (new_email == NULL) {
        printf("Error: Could not allocate memory for new email.\n");
        return;
    }
    // Copy data into new email
    strncpy(new_email->name, name, sizeof(new_email->name) - 1);
    strncpy(new_email->email_address, email_address, sizeof(new_email->email_address) - 1);
    // Ensure null termination
    new_email->name[sizeof(new_email->name) - 1] = '\0';
    new_email->email_address[sizeof(new_email->email_address) - 1] = '\0';
    // Set next as NULL for now
    new_email->next = NULL;
    // If mailing list is empty, set new email as first element
    if (*mailing_list == NULL) {
        *mailing_list = new_email;
    }
    // Otherwise, find last element and set its next as new email
    else {
        email_t *current = *mailing_list;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_email;
    }
    printf("Email address added to mailing list.\n");
}

// Function to delete an email from the mailing list
void delete_email(email_t **mailing_list, char *email_address) {
    // If mailing list is empty, do nothing
    if (*mailing_list == NULL) {
        printf("Mailing list is empty.\n");
        return;
    }
    // If first email matches, delete it
    if (strcmp((*mailing_list)->email_address, email_address) == 0) {
        email_t *temp = *mailing_list;
        *mailing_list = (*mailing_list)->next;
        free(temp);
        printf("%s has been removed from the mailing list.\n", email_address);
        return;
    }
    // Otherwise, find the email and delete it
    email_t *current = *mailing_list;
    email_t *previous = NULL;
    while (current != NULL && strcmp(current->email_address, email_address) != 0) {
        previous = current;
        current = current->next;
    }
    if (current == NULL) {
        printf("%s was not found in the mailing list.\n", email_address);
        return;
    }
    previous->next = current->next;
    free(current);
    printf("%s has been removed from the mailing list.\n", email_address);
}

// Function to display all emails in the mailing list
void display_emails(email_t *mailing_list) {
    // If mailing list is empty, do nothing
    if (mailing_list == NULL) {
        printf("Mailing list is empty.\n");
        return;
    }
    printf("Mailing list:\n");
    while (mailing_list != NULL) {
        printf("%s <%s>\n", mailing_list->name, mailing_list->email_address);
        mailing_list = mailing_list->next;
    }
}

int main() {
    email_t *mailing_list = NULL;
    int choice;
    while (1) {
        printf("\nMenu:\n1. Add email address\n2. Delete email address\n3. Display all emails\n4. Exit\nEnter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
        case 1:
            printf("Enter name: ");
            char name[50], email_address[100];
            scanf("%49s", name);
            printf("Enter email address: ");
            scanf("%99s", email_address);
            add_email(&mailing_list, name, email_address);
            break;
        case 2:
            printf("Enter email address to delete: ");
            scanf("%99s", email_address);
            delete_email(&mailing_list, email_address);
            break;
        case 3:
            display_emails(mailing_list);
            break;
        case 4:
            printf("Exiting.\n");
            exit(0);
        default:
            printf("Invalid choice.\n");
        }
    }
    return 0;
}
```
explanation-suggested-fix: The suggested code diff replaces `strcpy` with `strncpy` to prevent buffer overflow, ensuring that the specified maximum number of characters is copied, minus one for the null terminator. Additionally, `scanf` is replaced with length-limited format specifiers (`%49s` and `%99s`) to ensure user input does not exceed the buffer capacity.
method: CODEQL
