
vuln-fix: CWE-362: Race Condition in falcon180b-36121 (severity: Medium)
what: The vulnerability is a race condition due to the improper handling of the global variable `g_num_clients` in a multithreaded context.
where: The race condition occurs in `falcon180b-36121`, specifically within the `handle_client` and `accept_connections` functions.
why: One possible consequence of not resolving this weakness is that concurrent access to `g_num_clients` could lead to unpredictable behavior, including crashes, data corruption, or bypassing security controls, which may allow more than the maximum number of clients to be connected and served erroneously.
how: An attacker could exploit this vulnerability by rapidly connecting and disconnecting clients, causing race conditions that lead to the improper handling of the global state, including surpassing the maximum number of allowed clients or causing the server to crash.
code-sources: The entry point for user input is the `recv` function call within `handle_client`.
code-sinks: Actions performed using user input include the `printf` statement within the `handle_client` function.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_client_socks[MAX_CLIENTS];
int g_num_clients = 0;
pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER; // Add mutex for synchronization

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf("Client %d sent: %s\n", client_sock, buffer);
    }

    close(client_sock);

    pthread_mutex_lock(&client_mutex); // Lock the mutex before modifying shared data
    for (int i = 0; i < g_num_clients; i++) {
        if (g_client_socks[i] == client_sock) {
            g_client_socks[i] = -1;
            break;
        }
    }
    g_num_clients--;
    pthread_mutex_unlock(&client_mutex); // Unlock the mutex after modifying shared data

    pthread_exit(NULL);
}

void accept_connections() {
    struct sockaddr_in server_addr, client_addr;
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_sock, 10);

    while (1) {
        memset(&client_addr, 0, sizeof(client_addr));
        socklen_t client_size = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &client_size);

        pthread_mutex_lock(&client_mutex); // Lock the mutex before accessing shared data
        if (g_num_clients >= MAX_CLIENTS) {
            pthread_mutex_unlock(&client_mutex); // Unlock the mutex if server is full
            send(client_sock, "Server is full.\r\n", 16, 0);
            close(client_sock);
            continue;
        }

        g_client_socks[g_num_clients] = client_sock;
        g_num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
        pthread_mutex_unlock(&client_mutex); // Unlock the mutex after modifying shared data
    }

    close(server_sock);
}

int main() {
    accept_connections();

    return 0;
}
```
explanation-suggested-fix: This code diff introduces a mutex to synchronize access to the shared global variable `g_num_clients` and `g_client_socks` array. By locking the mutex before modifying these shared resources and unlocking it afterward, this change prevents data races and ensures the consistent state of global variables, adhering to the rules of multithreaded programming.
method: UNKNOWN
