
vuln-fix: Race Condition (CWE-362) in falcon180b-66819 (severity: High)
what: The code has a race condition vulnerability due to the shared variable `num_clients` being accessed and modified by multiple threads without proper synchronization.
where: Main race condition issue is found in the `handle_client` function, specifically in how `num_clients` and `client_sockets[num_clients]` are being accessed and modified.
why: If not resolved, this weakness could allow an attacker to cause undefined behavior, potentially crashing the server or leading to unexpected results due to concurrent access and modification of shared variables.
how: An attacker could exploit this vulnerability by establishing multiple connections concurrently, causing race conditions when the server updates `num_clients` and `client_sockets`, which can lead to corrupted state or crashes.
code-sources: The `recv` function in `handle_client` is where data from a client enters the application.
code-sinks: The `client_sockets[num_clients] = 0;`, `num_clients--;`, and the related access and modification operations in `handle_client`.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <sys/time.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t clients_mutex;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);

            pthread_mutex_lock(&clients_mutex);
            for (int i = 0; i < MAX_CLIENTS; i++) {
                if (client_sockets[i] == client_socket) {
                    client_sockets[i] = 0;
                    num_clients--;
                    break;
                }
            }
            pthread_mutex_unlock(&clients_mutex);
            break;
        }

        printf("Client %d sent: %s\n", client_socket, buffer);
    }

    return NULL;
}

int main() {
    pthread_mutex_init(&clients_mutex, NULL);

    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf("Error creating socket\n");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf("Error binding socket\n");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf("Error listening on socket\n");
        return 1;
    }

    printf("Server started on port %d\n", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);

        if (client_socket == -1) {
            printf("Error accepting connection\n");
            continue;
        }

        printf("Client connected: %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        pthread_mutex_lock(&clients_mutex);
        if (num_clients < MAX_CLIENTS) {
            for (int i = 0; i < MAX_CLIENTS; i++) {
                if (client_sockets[i] == 0) {
                    client_sockets[i] = client_socket;
                    num_clients++;
                    break;
                }
            }
        } else {
            printf("Maximum clients reached. Connection refused.\n");
            close(client_socket);
        }

        pthread_mutex_unlock(&clients_mutex);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    pthread_mutex_destroy(&clients_mutex);
    return 0;
}
```
explanation-suggested-fix: The suggested fix introduces a mutex, `clients_mutex`, to synchronize access to `num_clients` and `client_sockets` in the `handle_client` function and in the section of `main` where new clients are accepted. Locking and unlocking the mutex ensures that only one thread can modify these variables at a time, preventing race conditions and ensuring consistency and thread safety.
method: UNKNOWN
