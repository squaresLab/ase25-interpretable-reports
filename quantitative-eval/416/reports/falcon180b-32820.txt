
vuln-fix: CWE-362: Race Condition in falcon180b-32820 (severity: High)
what: The vulnerability is a race condition caused by improper handling of the `client_socket` variable. The main thread passes the address of `client_socket` to `pthread_create`, which starts a thread executing `handle_client`. Before `handle_client` can dereference the pointer, the value of `client_socket` may change due to the main thread accepting another client.
where: The vulnerability is located in falcon180b-32820 at the line `pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);`.
why: If this weakness is not resolved, it can lead to one thread closing or reading from the wrong client socket, causing data corruption, denial of service, or improper handling of client requests.
how: An attacker could exploit this vulnerability by connecting multiple clients rapidly. By creating a situation where the `client_socket` changes before a thread dereferences it, the attacker can cause the server to mishandle client connections.
code-sources: Entry point for user input is the `recv` function in `handle_client`, receiving data from the connected client sockets.
code-sinks: Output using `printf` in the `while` loop inside `handle_client`, which logs the client data.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

typedef struct {
    int client_socket;
} thread_data_t;

void *handle_client(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    int client_socket = data->client_socket;
    char buffer[BUFFER_SIZE];
    free(data);

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf("Client %d sent: %s\n", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf("Server is listening on port 8080\n");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf("Maximum number of clients reached\n");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        thread_data_t *data = (thread_data_t *)malloc(sizeof(thread_data_t));
        data->client_socket = client_socket;
        pthread_create(&thread_id, NULL, handle_client, (void *)data);
    }

    return 0;
}
```
explanation-suggested-fix: The suggested fix involves creating a struct to encapsulate the client socket and passing this struct to the thread function. This way, even if the value of `client_socket` changes in the main thread, each thread will have its own copy.
method: UNKNOWN
