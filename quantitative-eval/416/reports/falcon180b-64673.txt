
    vuln-fix: CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') in falcon180b-64673 (severity: High)
    what: The vulnerability is a race condition due to shared resource access without proper synchronization.
    where: The vulnerable code occurs when multiple threads access and modify `thread_data_t data` in `create_thread()` without proper synchronization. Specifically, there is a potential race condition between thread creation and setting their unique names.
    why: One possible consequence of not resolving this weakness is that it could lead to unpredictable behavior, including crashes or incorrect thread names being assigned, potentially causing further logic errors in the system.
    how: An attacker could exploit this vulnerability by creating multiple threads in rapid succession, causing the `thread_data_t` structure to be overwritten unpredictably, potentially leading to denial of service or erratic application behavior.
    code-sources: The main function, specifically where `create_thread` is called with user input `names[i]` and `(void *)i`.
    code-sinks: The actions performed by the application using the user input include creating threads and setting their unique names.
    suggested-fix: 
    ```diff
    --- original_falcon180b-64673.c
    +++ fixed_falcon180b-64673.c
    @@ -13,11 +13,15 @@
     int create_thread(pthread_t *thread, const char *name,
                       void *(*func)(void *), void *arg) {
         int ret;
    -    thread_data_t data;
    +    thread_data_t *data;
    +    
    +    data = malloc(sizeof(thread_data_t));
    +    if (data == NULL) {
    +        fprintf(stderr, "Error: unable to allocate memory for thread_data_t\n");
    +        return -1;
    +    }

    -    data.id = *thread;
    -    data.func = func;
    -    data.arg = arg;
    +    data->id = *thread;
    +    data->func = func;
    +    data->arg = arg;

         ret = pthread_create(thread, NULL, thread_func, data);
         if (ret!= 0) {
             fprintf(stderr, "Error: unable to create thread, %s\n", strerror(ret));
    @@ -26,6 +30,7 @@
             return ret;
         }

    -    ret = pthread_setname_np(*thread, name);
    +    ret = pthread_setname_np(*thread, name);
         if (ret!= 0) {
            fprintf(stderr, "Error: unable to set thread name, %s\n", strerror(ret));
    +        free(data);
            return ret;
         }
    
         return 0;
     }
    ```

    explanation-suggested-fix: The suggested code changes resolve the vulnerability by allocating memory for `thread_data_t` on the heap, ensuring each thread has its own independent data structure. This removes the shared state and prevents the race condition.
    method: UNKNOWN
