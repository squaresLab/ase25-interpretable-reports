
    vuln-fix: Global Variable Access Synchronization Issue (CWE-362: Race Condition) in gpt35-3871.c at lines 14-19, 25-31, 37-39, and 100-116 (severity: High)
    what: The code contains multiple global variables (`elevator_positions`, `elevator_directions`, `elevator_doors_open`, and `floor_buttons_pressed`) that are accessed and modified by multiple threads without any form of synchronization, such as mutexes, to prevent concurrent access. This leads to a potential race condition.
    where: Vulnerability is located in the following lines of file gpt35-3871.c:
      - Lines accessing and modifying `elevator_positions`, `elevator_directions`, `elevator_doors_open`, and `floor_buttons_pressed` inside `elevator_thread_function`: lines 14-19, 25-31, and 37-39
      - Lines accessing and modifying `floor_buttons_pressed` inside `main` function: lines 100-116
    why: If race conditions occur, it can lead to undefined behavior which may cause the program to malfunction, potentially leading to security vulnerabilities such as incorrect elevator movements, doors opening at wrong times, or crashing the application.
    how: An attacker might exploit the race condition to manipulate the state of the elevator system in a harmful way, such as causing elevators to go to the wrong floors or stopping mid-operation, which can lead to dangerous situations in real-world elevator systems.
    code-sources: The user input is taken from the `scanf` function at line 107 in the `main` function.
    code-sinks: The user input influences the global state directly by modifying the `floor_buttons_pressed` array at line 115 in the `main` function and is used within the `elevator_thread_function` to simulate elevator movements.
    suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

#define FLOORS 10
#define ELEVATORS 3

int elevator_positions[ELEVATORS] = { 0 };
bool elevator_directions[ELEVATORS] = { true }; //true for up, false for down
bool elevator_doors_open[ELEVATORS] = { false };

int floor_buttons_pressed[FLOORS] = { 0 };

// Add mutex for synchronizing elevator state access
pthread_mutex_t elevator_mutex = PTHREAD_MUTEX_INITIALIZER;

void* elevator_thread_function(void* args)
{
    int elevator_num = *(int*) args; //Extracting the elevator number from the void pointer argument
    while (true) //Elevator's continuous loop
    {
        // Lock mutex before accessing shared variables
        pthread_mutex_lock(&elevator_mutex);

        //Check if the elevator is moving or if its doors are open
        if (!elevator_doors_open[elevator_num])
        {
            //Check if any floor buttons have been pressed in the direction the elevator is moving
            bool pressed_button = false;
            for (int floor = 0; floor < FLOORS; floor++)
            {
                //Check if the button has been pressed and the elevator is going in the right direction
                if (floor_buttons_pressed[floor] > 0 && ((elevator_directions[elevator_num] && floor > elevator_positions[elevator_num])
                     || (!elevator_directions[elevator_num] && floor < elevator_positions[elevator_num])))
                {
                    pressed_button = true;
                    break;
                }
            }
            //If there are no pressed buttons in the elevator's direction, switch directions
            if (!pressed_button)
            {
                elevator_directions[elevator_num] = !elevator_directions[elevator_num];
            }
            //Move the elevator in the proper direction
            if (elevator_directions[elevator_num])
            {
                elevator_positions[elevator_num]++;
            }
            else
            {
                elevator_positions[elevator_num]--;
            }
            //Check if the elevator has arrived at a floor and needs to stop
            bool stop = false;
            for (int floor = 0; floor < FLOORS; floor++)
            {
                if (elevator_positions[elevator_num] == floor && floor_buttons_pressed[floor] > 0)
                {
                    stop = true;
                    break;
                }
            }
            if (stop)
            {
                elevator_doors_open[elevator_num] = true;
                printf("Elevator %d has arrived at floor %d.\n", elevator_num, elevator_positions[elevator_num]);
                sleep(2); //Open the doors for 2 seconds
                elevator_doors_open[elevator_num] = false;
                //Remove the button press for this floor
                floor_buttons_pressed[elevator_positions[elevator_num]] = 0;
            }
        }

        // Unlock mutex after done accessing shared variables
        pthread_mutex_unlock(&elevator_mutex);

        //Sleep the thread for 100 milliseconds (simulate moving between floors)
        usleep(100000);
    }
}

int main()
{
    pthread_t elevator_threads[ELEVATORS];
    int elevator_numbers[ELEVATORS] = { 0, 1, 2 };
    //Create the elevator threads
    for (int i = 0; i < ELEVATORS; i++)
    {
        if (pthread_create(&elevator_threads[i], NULL, elevator_thread_function, (void*) &elevator_numbers[i]))
        {
            printf("Error: Cannot create elevator thread %d.\n", i);
            exit(1);
        }
    }

    while (true) //Simulation loop for user pressing floor buttons
    {
        //Prompt for user input
        printf("Enter floor number (0 to exit): ");
        int floor;
        scanf("%d", &floor);
        if (floor < 0 || floor >= FLOORS) //Invalid floor number
        {
            printf("Invalid floor number.\n");
        }
        else if (floor == 0) //Exit simulation
        {
            break;
        }
        else //Valid floor number, add it to the queue
        {
            pthread_mutex_lock(&elevator_mutex);  // Lock mutex before modifying shared variable
            int min_queue_len = abs(elevator_positions[0] - floor); //Calculate the minimum queue length for the first elevator
            int min_queue_elevator = 0; //This will store the index of the elevator with the shortest queue
            for (int i = 1; i < ELEVATORS; i++)
            {
                int queue_len = abs(elevator_positions[i] - floor); //Calculate the queue length for this elevator
                if (queue_len < min_queue_len)
                {
                    min_queue_len = queue_len;
                    min_queue_elevator = i;
                }
            }
            floor_buttons_pressed[floor]++; //Add the button press to the queue
            pthread_mutex_unlock(&elevator_mutex); // Unlock mutex after copying shared variable
            printf("Button for floor %d pressed.\n", floor);
        }
    }

    for (int j = 0; j < ELEVATORS; j++) // Join threads before exiting
    {
        pthread_join(elevator_threads[j], NULL);
    }

    pthread_mutex_destroy(&elevator_mutex);  // Destroy mutex object after usage
    return 0;
}
```
explanation-suggested-fix: The suggested code diff uses a mutex (`pthread_mutex_t`) to synchronize access to global variables that are shared among multiple threads. The mutex is locked before any thread accesses or modifies these shared variables and is unlocked after the access or modification is complete. This ensures that only one thread can access the shared variables at a time, thereby preventing race conditions.
    method: UNKNOWN
