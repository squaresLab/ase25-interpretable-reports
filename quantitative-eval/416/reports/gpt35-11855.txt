    
vuln-fix: CWE-362: Race Condition in gpt35-11855 at lines 48-55 (severity: High)
what: The code contains a race condition due to improper handling of shared resources across multiple threads.
where: Lines 48-55 in gpt35-11855.c
why: Unresolved, this race condition can lead to inconsistent program state, crashes, security breaches, and unpredictable behavior.
how: An attacker could exploit this vulnerability by causing multiple threads to access and modify shared resources concurrently, leading to data corruption or unexpected behavior.
code-sources: User inputs received via the `read` function from the socket in the `connection_handler` function.
code-sinks: The user inputs are used directly in the `write` function without proper synchronization.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

void *connection_handler(void *);
pthread_mutex_t lock;

int main(int argc, char **argv) {

  int server_fd, new_socket, c;
  struct sockaddr_in server, client;

  // Initialize mutex lock
  if (pthread_mutex_init(&lock, NULL) != 0) {
    perror("Mutex Init Failed");
    exit(EXIT_FAILURE);
  }

  // Create socket
  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
  }

  // Assign IP, PORT
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = htons(PORT);

  // Bind the socket with the server address
  if (bind(server_fd, (struct sockaddr *)&server, sizeof(server)) < 0) {
    perror("Bind Failed");
    exit(EXIT_FAILURE);
  }

  // Listen for incoming connections
  if (listen(server_fd, 3) < 0) {
    perror("Listen Failed");
    exit(EXIT_FAILURE);
  }

  printf("Server listening on port %d\n", PORT);

  c = sizeof(struct sockaddr_in);
  while ((new_socket = accept(server_fd, (struct sockaddr *)&client, (socklen_t *)&c))) {
    printf("Connection accepted from %s:%d\n", inet_ntoa(client.sin_addr), ntohs(client.sin_port));

    pthread_t thread_id;
    if (pthread_create(&thread_id, NULL, connection_handler, (void *)&new_socket) < 0) {
      perror("Thread Creation Failed");
      return 1;
    }
  }

  if (new_socket < 0) {
    perror("Accept Failed");
    exit(EXIT_FAILURE);
  }

  // Destroy mutex lock
  pthread_mutex_destroy(&lock);
  
  close(server_fd);
  return 0;
}

void *connection_handler(void *socket_ptr) {
  int socket = *(int *)socket_ptr;
  char buffer[1024];
  int msg_len;

  // Send welcome message to connected client
  char *welcome_msg = "Welcome to the chat server! Type 'exit' to disconnect.";
  write(socket, welcome_msg, strlen(welcome_msg));

  while ((msg_len = read(socket, buffer, 1024)) > 0) {
    buffer[msg_len - 1] = '\0';   // Remove '\n' at the end of the message
    if (strcmp(buffer, "exit") == 0)
      break;   // Disconnect client if 'exit' is typed

    // Lock mutex before broadcasting
    pthread_mutex_lock(&lock);

    // Broadcast message to all connected clients
    printf("[%d] %s\n", socket, buffer);
    for (int i = 4; i < 1024; i++) {
      if (i == socket)
        continue;
      if (write(i, buffer, strlen(buffer)) < 0) {
        perror("Write Failed");
        break;
      }
    }

    // Unlock mutex after broadcasting
    pthread_mutex_unlock(&lock);
  }

  // Disconnect client
  printf("Connection closed from %d\n", socket);
  close(socket);
  return NULL;
}
```
explanation-suggested-fix: The suggested fix introduces a mutex (`pthread_mutex_t lock`) to synchronize access to shared resources. The `pthread_mutex_lock` and `pthread_mutex_unlock` functions ensure that only one thread can broadcast the message at any given time, thereby resolving the race condition.
method: UNKNOWN
