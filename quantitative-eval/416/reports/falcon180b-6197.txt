
    vuln-fix: Buffer Overflow (CWE-120, CWE-787, CWE-805) in falcon180b-6197 (severity: High)
    what: Multiple buffer overflow vulnerabilities exist due to unbounded writing operations within the phone book application.
    where: Lines 15, 17, 68, and 73 in falcon180b-6197.
    why: Buffer overflow can lead to unexpected behavior, crashes, and security vulnerabilities. Attackers could exploit these weaknesses to execute arbitrary code.
    how: An attacker could input data larger than the allocated buffer (in this case, the `name` array of size 50 and the `phone` array of size 15) which would lead to buffer overflow, possibly overwriting critical memory areas.
    code-sources: 
        - Line 15: `scanf("%s", phonebook[size].name);`
        - Line 17: `scanf("%s", phonebook[size].phone);`
        - Line 68: `scanf("%s", name);`
        - Line 73: `scanf("%s", name);`
    code-sinks: Usage of `scanf` without limiting the input size can cause overflow in lines where the respective buffers are used.
    suggested-fix: 
        ```diff
        diff --git a/falcon180b-6197 b/falcon180b-6197
        index e69de29..b00fd53 100644
        --- a/falcon180b-6197
        +++ b/falcon180b-6197
        @@ -15,7 +15,7 @@ void add_entry(struct entry *phonebook, int size) {
            printf("Enter name: ");
        -   scanf("%s", phonebook[size].name);
        +   scanf("%49s", phonebook[size].name);
            printf("Enter phone number: ");
        -   scanf("%s", phonebook[size].phone);
        +   scanf("%14s", phonebook[size].phone);
         }
         
         void search_entry(struct entry *phonebook, int size, char *name) {
        @@ -65,10 +65,10 @@ void delete_entry(struct entry *phonebook, int *size, char *name) {
                     strcpy(phonebook[j+1].phone, phonebook[*size].phone);
                 }
                 (*size)--;
        @@ -68,7 +68,7 @@ void delete_entry(struct entry *phonebook, int *size, char *name) {
         while (1) {
             printf("1. Add entry\n2. Search entry\n3. Delete entry\n4. Exit\n");
             int choice;
        -    scanf("%d", &choice);
        +    if (scanf("%d", &choice) != 1) {
        +        printf("Invalid input.\n");
        +        while (getchar() != '\n'); // clear input buffer
        +        continue;
        +    }
         
             switch (choice) {
                 case 1:
                     if (size >= MAX_ENTRIES) {
                         printf("Phone book is full.\n");
                     } else {
        -                add_entry(phonebook, size);
        +                add_entry(phonebook, size);
                         size++;
                     }
                     break;
                 case 2:
                     printf("Enter name to search: ");
        -            char name[50];
        -            scanf("%s", name);
        +            char name[50];
        +            scanf("%49s", name);
                     search_entry(phonebook, size, name);
                     break;
                 case 3:
                     printf("Enter name to delete: ");
        -            scanf("%s", name);
        +            scanf("%49s", name);
                     delete_entry(phonebook, &size, name);
                     break;
                 case 4:
                     printf("Exiting...\n");
                     exit(0);
                 default:
                     printf("Invalid choice.\n");
         return 0;
         }
        ```
    explanation-suggested-fix: The fix involves using field width specifiers in `scanf` to limit the number of characters read, thus preventing writing beyond the allocated buffer size. This prevents buffer overflow by ensuring that inputs fit within the bounds of allocated arrays.
    method: CODEQL
