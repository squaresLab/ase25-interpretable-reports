
    vuln-fix: CWE-362: Race Condition in falcon180b-71855 (severity: High)
    what: The vulnerability is a race condition in the `handle_client` function where the `client_socket` variable is being shared across threads without proper synchronization. This can lead to undefined behavior including crashes and data corruption.
    where: Lines involving threading and socket communications, particularly:
    ```c
    clients[num_clients][0] = client_socket;
    clients[num_clients][1] = client_socket;
    num_clients++;
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    ```
    why: If not resolved, this weakness can allow attackers to exploit the race condition, potentially causing the server to crash, perform incorrect actions, or corrupt transmitted data, making the system unreliable and unsafe.
    how: An attacker could exploit this by quickly opening and closing connections to the server, potentially creating a situation where multiple threads access and modify the `client_socket` and `num_clients` variable simultaneously, leading to inconsistent states.
    code-sources: Entry point is the network socket connection accepted in main loop:
    ```c
    int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
    ```
    code-sinks: The vulnerable actions are in the `handle_client` function, such as `recv`, `send`, and handling the `client_socket`.
    suggested-fix: 
    ```diff
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <pthread.h>
    #include <errno.h>
    #include <unistd.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <netdb.h>

    #define MAX_CLIENTS 10
    #define BUFFER_SIZE 1024

    int clients[MAX_CLIENTS][2];
    int num_clients = 0;
    pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER;

    void *handle_client(void *arg) {
        int client_socket = *(int *)arg;
        free(arg);
        char buffer[BUFFER_SIZE];
        while(1) {
            memset(buffer, 0, BUFFER_SIZE);
            int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
            if(bytes_received <= 0) {
                break;
            }
            printf("Client %d says: %s\n", client_socket, buffer);
            send(client_socket, buffer, strlen(buffer), 0);
        }
        close(client_socket);
        return NULL;
    }

    int main() {
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);
        if(server_socket == -1) {
            printf("Error creating socket\n");
            exit(1);
        }

        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(8080);
        server_addr.sin_addr.s_addr = INADDR_ANY;

        if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
            printf("Error binding socket\n");
            exit(1);
        }

        if(listen(server_socket, 10) == -1) {
            printf("Error listening on socket\n");
            exit(1);
        }

        printf("Server started on port 8080\n");

        while(1) {
            struct sockaddr_in client_addr;
            socklen_t client_size = sizeof(client_addr);
            int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
            if(client_socket == -1) {
                printf("Error accepting connection\n");
                continue;
            }

            pthread_mutex_lock(&client_mutex);
            if(num_clients >= MAX_CLIENTS) {
                printf("Maximum number of clients reached\n");
                close(client_socket);
                pthread_mutex_unlock(&client_mutex);
                continue;
            }

            int *client_socket_ptr = malloc(sizeof(int));
            *client_socket_ptr = client_socket;

            clients[num_clients][0] = client_socket;
            clients[num_clients][1] = client_socket;
            num_clients++;
            pthread_mutex_unlock(&client_mutex);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)client_socket_ptr);
            pthread_detach(thread_id);
        }

        return 0;
    }
    ```
    explanation-suggested-fix: The suggested code diff introduces a mutex, `client_mutex`, to synchronize access to shared data like `num_clients` and the `clients` array. This prevents race conditions by ensuring that only one thread can modify these shared resources at a time. Additionally, each `pthread_create` now invokes `handle_client` with a dynamically allocated copy of `client_socket` to avoid passing a potentially shared memory address.
    method: UNKNOWN
