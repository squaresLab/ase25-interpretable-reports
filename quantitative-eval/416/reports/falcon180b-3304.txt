
vuln-fix: CWE-362: Race Condition in falcon180b-3304 (severity: high)
what: The vulnerability stems from a race condition due to shared access to the `clients` array and `num_clients` variable without proper synchronization.
where: Lines related to modifying the `clients` array and `num_clients` variable within the main function and `handle_client` function.
why: If this weakness is not resolved, multiple threads can simultaneously modify these shared resources, leading to inconsistent or corrupt state, possibly causing crashes or unexpected behavior. This could also give rise to potential exploitation where an attacker could cause denial of service or manipulate client socket assignments.
how: An attacker can create multiple connections to the server rapidly, aiming to exploit the unsynchronized access to the `clients` array and `num_clients` variable. By doing so, they could cause the server to crash or behave unpredictably.
code-sources: The client connections accepted by the `accept` function call.
code-sinks: The `handle_client` function where `clients` array and `num_clients` are accessed and modified.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            close(client_socket);
            pthread_mutex_lock(&clients_mutex);
            for(int i = 0; i < MAX_CLIENTS; i++) {
                if(clients[i] == client_socket) {
                    clients[i] = 0;
                    num_clients--;
                    break;
                }
            }
            pthread_mutex_unlock(&clients_mutex);
            pthread_exit(0);
        }
        printf("Client %d sent: %s\n", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        printf("Error creating socket\n");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf("Error binding socket\n");
        return 1;
    }

    if(listen(server_socket, MAX_CLIENTS) == -1) {
        printf("Error listening on socket\n");
        return 1;
    }

    printf("Server started on port 12345\n");

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
        if(client_socket == -1) {
            printf("Error accepting client\n");
            continue;
        }

        pthread_mutex_lock(&clients_mutex);
        for(int i = 0; i < MAX_CLIENTS; i++) {
            if(clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }
        pthread_mutex_unlock(&clients_mutex);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}
```
explanation-suggested-fix: The suggested code diff resolves the vulnerability by introducing a mutex (`clients_mutex`) to synchronize access to the shared `clients` array and `num_clients` variable. Whenever these shared resources are accessed or modified, the mutex is locked to ensure that only one thread can perform operations on them at a time. This prevents race conditions and ensures the consistency and integrity of the shared state.
method: UNKNOWN
