
vuln-fix: Return of stack-allocated memory (CWE-825) in falcon180b-3601:25,44 and Unbounded write (CWE-120, CWE-787, CWE-805) in falcon180b-3601:61,63,69,71 (severity: High)
what: 
1. The functions `encrypt` (line 25) and `decrypt` (line 44) return pointers to stack-allocated memory. 
2. In `main` function, the buffer write operations in lines 61, 63, 69, and 71 do not control the length of data written, which may result in a buffer overflow.

where: 
1. `encrypt` function:  falcon180b-3601, line 25
2. `decrypt` function:  falcon180b-3601, line 44
3. `main` function:  falcon180b-3601, lines 61, 63, 69, 71

why: 
Failing to fix these vulnerabilities can lead to undefined behavior in the application, including crashes or security breaches. 

how: 
1. For returning stack-allocated memory, an attacker could exploit use-after-free vulnerabilities leading to execution of arbitrary code.
2. For unbounded write vulnerabilities, an attacker could manipulate the inputs to cause buffer overflows, potentially leading to execution of arbitrary code or crashing the application.

code-sources: 
- `scanf("%s", message);` in `main`: falcon180b-3601, line 61 
- `scanf("%s", key);` in `main`: falcon180b-3601, line 63 
- `scanf("%s", encrypted);` in `main`: falcon180b-3601, line 69 
- `scanf("%s", key);` in `main`: falcon180b-3601, line 71

code-sinks: 
- `encrypt(message, key)` call in `main`: falcon180b-3601, line 65 
- `decrypt(encrypted, key)` call in `main`: falcon180b-3601, line 73

suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define SIZE 100

char *encrypt(char *message, char *key) {
-    char result[SIZE];
+    char *result = (char *)malloc(SIZE * sizeof(char));
    int i, j, k;
    for (i = 0, j = 0; message[i]!= '\0'; i++) {
        result[i] = message[i] + key[j];
        if (result[i] > 'z') {
            result[i] -= 26;
        } else if (result[i] < 'a') {
            result[i] += 26;
        }
        j++;
        if (j == strlen(key)) {
            j = 0;
        }
    }
    result[i] = '\0';
    return result;
}

char *decrypt(char *message, char *key) {
-    char result[SIZE];
+    char *result = (char *)malloc(SIZE * sizeof(char));
    int i, j, k;
    for (i = 0, j = 0; message[i]!= '\0'; i++) {
        result[i] = message[i] - key[j];
        if (result[i] > 'z') {
            result[i] -= 26;
        } else if (result[i] < 'a') {
            result[i] += 26;
        }
        j++;
        if (j == strlen(key)) {
            j = 0;
        }
    }
    result[i] = '\0';
    return result;
}

int main() {
    char message[SIZE];
    char key[SIZE];
    char *encrypted;
    char *decrypted;
    int choice;
    do {
        printf("\nWelcome to the Future Cryptography System!\n");
        printf("1. Encrypt Message\n2. Decrypt Message\n3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch (choice) {
            case 1:
                printf("Enter your message: ");
-                scanf("%s", message);
+                scanf("%99s", message);
                printf("Enter your key: ");
-                scanf("%s", key);
+                scanf("%99s", key);
                encrypted = encrypt(message, key);
                printf("\nEncrypted Message: %s\n", encrypted);
+                free(encrypted);
                break;
            case 2:
                printf("Enter your encrypted message: ");
-                scanf("%s", encrypted);
+                encrypted = (char*)malloc(SIZE * sizeof(char));
+                scanf("%99s", encrypted);
                printf("Enter your key: ");
-                scanf("%s", key);
+                scanf("%99s", key);
                decrypted = decrypt(encrypted, key);
                printf("\nDecrypted Message: %s\n", decrypted);
+                free(decrypted);
+                free(encrypted);
                break;
            case 3:
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    } while (1);
    return 0;
}
```
explanation-suggested-fix: 
1. The return of stack-allocated memory is fixed by allocating memory on the heap using `malloc` in the `encrypt` and `decrypt` functions.
2. Buffer overflow vulnerabilities are fixed by limiting the `scanf` input to `99` characters to ensure that there is no buffer overflow.
3. The `free` calls are added to release the dynamically allocated memory, preventing memory leaks.

method: CODEQL
