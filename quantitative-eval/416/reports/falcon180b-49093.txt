
vuln-fix: CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') in falcon180b-49093 (severity: High)
what: The code involves multiple threads accessing shared resources (i.e., `clients` array and `num_clients` variable) without proper synchronization. This can lead to race conditions where the shared resources can be in an inconsistent state when multiple clients connect or disconnect simultaneously.
where: The vulnerability is present in the following lines and file:
- falcon180b-49093, line 8: `int clients[MAX_CLIENTS];`
- falcon180b-49093, line 9: `int num_clients = 0;`
- falcon180b-49093, line 58: `clients[num_clients++] = client_socket;`
why: If this weakness is not resolved, it can lead to unpredictable behavior, crashes, or security vulnerabilities due to improper handling of shared data across concurrent threads. This can cause the server to malfunction, resulting in denial of service or data corruption.
how: An attacker could exploit this vulnerability by connecting and disconnecting multiple clients rapidly, causing the server to improperly update the `clients` array and `num_clients` variable, potentially leading to service disruption or data corruption.
code-sources: The entry point for user input is the clientâ€™s connection made through the `accept` system call:
- falcon180b-49093, line 53: `int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);`
code-sinks: Actions performed using user input:
- falcon180b-49093, line 29: `int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);`
- falcon180b-49093, lines 31, 33: Printing and broadcasting received message: `printf("Client %d sent: %s\n", client_socket, buffer);`, `send(clients[i], buffer, strlen(buffer), 0);`
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS]; // array to store client sockets
int num_clients = 0; // number of clients connected
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf("Client %d sent: %s\n", client_socket, buffer);
        pthread_mutex_lock(&clients_mutex);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
        pthread_mutex_unlock(&clients_mutex);
    }
    close(client_socket);
    pthread_exit(0);
}

void broadcast(int sender_socket, char *message) {
    pthread_mutex_lock(&clients_mutex);
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
    pthread_mutex_unlock(&clients_mutex);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf("Error creating socket\n");
        exit(1);
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf("Error binding socket\n");
        exit(1);
    }
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf("Error listening on socket\n");
        exit(1);
    }
    printf("Server started on port 8080\n");
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
        if (client_socket == -1) {
            printf("Error accepting connection\n");
            exit(1);
        }
        printf("Client connected: %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        pthread_mutex_lock(&clients_mutex);
        clients[num_clients++] = client_socket;
        pthread_mutex_unlock(&clients_mutex);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
    return 0;
}
```
explanation-suggested-fix: The suggested code diff introduces a mutex `clients_mutex` to synchronize access to the shared `clients` array and `num_clients` variable. By locking the mutex before modifying or iterating over these shared resources and unlocking it afterward, we can ensure that only one thread can access these resources at a time, thereby preventing race conditions.
method: UNKNOWN
