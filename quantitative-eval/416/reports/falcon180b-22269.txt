
vuln-fix: CWE-787: Out-of-bounds Write in falcon180b-22269 (severity: High)
what: An out-of-bounds write vulnerability occurs when the code writes data past the end of a buffer or object, which can overwrite adjacent memory locations and cause crashes or even arbitrary code execution.
where: The vulnerability is located in the `handle_client` function, specifically in the lines where `pthread_create` passes `client_socket` by reference and in the `while` loop handling client messages.
why: Failure to resolve this vulnerability could allow an attacker to overwrite memory regions, causing the program to crash or potentially execute arbitrary code.
how: An attacker can send data to the server to exploit this vulnerability, causing the application's memory to be corrupted. By passing certain crafted inputs, an attacker could manipulate the memory layout and possibly execute arbitrary code.
code-sources: User input enters through the `recv` function in the `handle_client` function.
code-sinks: The `send` function in the `handle_client` function uses the buffer that contains the data retrieved from the `recv` function.
suggested-fix: 
```diff
--- falcon180b-22269.c
+++ falcon180b-22269.c
@@ -23,13 +23,15 @@
 
 void *handle_client(void *client_socket) {
     int client_socket_copy = *((int *) client_socket);
+    free(client_socket); // Free the dynamically allocated memory
 
     char buffer[1024];
     while (1) {
         memset(buffer, 0, sizeof(buffer));
         int bytes_received = recv(client_socket_copy, buffer, sizeof(buffer), 0);
         if (bytes_received <= 0) {
             break;
         }
+        buffer[sizeof(buffer)-1] = '\0'; // Ensure NULL termination
         printf("Client %d sent: %s", client_socket_copy, buffer);
         send(client_socket_copy, buffer, strlen(buffer), 0);
     }
@@ -37,9 +39,12 @@
 
     close(client_socket_copy);
     return NULL;
 }
 
 int main() {
-    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
+    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
+    if (server_socket == -1) {
+        perror("Socket creation failed");
+        exit(EXIT_FAILURE);
+    }
     struct sockaddr_in server_addr;
     memset(&server_addr, 0, sizeof(server_addr));
     server_addr.sin_family = AF_INET;
@@ -54,6 +59,7 @@
         int client_socket = accept(server_socket, NULL, NULL);
         if (client_socket == -1) {
             printf("Error accepting connection\n");
             continue;
         }
+        
         if (num_clients >= MAX_CLIENTS) {
             printf("Maximum number of clients reached\n");
             close(client_socket);
@@ -62,6 +68,10 @@
         }
 
         clients[num_clients] = client_socket;
         num_clients++;
 
         pthread_t thread_id;
-        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
+        int *client_sock_ptr = malloc(sizeof(int));
+        if (client_sock_ptr == NULL) {
+            perror("Failed to allocate memory");
+            close(client_socket);
+            continue;
+        }
+        *client_sock_ptr = client_socket;
+        pthread_create(&thread_id, NULL, handle_client, (void *) client_sock_ptr);
     }

     return 0;
 }
```
explanation-suggested-fix: The suggested code diff resolves the vulnerability by ensuring that `client_socket` is passed by value to the `pthread_create` function, using dynamically allocated memory and freeing it inside the `handle_client` function. Additionally, we guarantee that the buffer is null-terminated before using it in `printf` and `send`, which mitigates potential buffer overflow and memory corruption issues.
method: UNKNOWN
