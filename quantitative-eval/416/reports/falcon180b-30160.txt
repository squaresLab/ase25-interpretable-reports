
vuln-fix: Race Condition (CWE-362) in falcon180b-30160.c:25-52 (severity: high)
what: A race condition exists due to the shared `client_socket` variable in the `handle_client` function. Multiple threads may access this variable, resulting in undefined behavior and potential crashes.
where: The race condition is found within the `handle_client` function defined on lines 25-52 in falcon180b-30160.c.
why: If left unresolved, this race condition could allow an attacker to cause the server to crash or behave unpredictably, leading to potential denial of service (DoS) or exploitation of other weaknesses.
how: An attacker could exploit this vulnerability by rapidly connecting and disconnecting from the server, possibly causing the mishandling of the socket descriptor which may lead to unpredictable behavior or crashes.
code-sources: Entry points for user input include the socket connections established in the `main` function.
code-sinks: Usage of data from user input occurs at various points such as the `recv` function in the `handle_client` function.
suggested-fix: 
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;
pthread_mutex_t client_lock;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            pthread_mutex_lock(&client_lock);
            for (int i = 0; i < num_clients; i++) {
                if (clients[i][0] == client_socket) {
                    clients[i][0] = 0;
                    break;
                }
            }
            pthread_mutex_unlock(&client_lock);
            close(client_socket);
            pthread_exit(NULL);
        }

        printf("Client %d sent message: %s\n", client_socket, buffer);

        pthread_mutex_lock(&client_lock);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i][0] != client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
        pthread_mutex_unlock(&client_lock);
    }
}

int main() {
    pthread_mutex_init(&client_lock, NULL);

    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf("Server started on port 8080\n");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        pthread_mutex_lock(&client_lock);
        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = pthread_create(&clients[num_clients][2], NULL, handle_client, (void *)&client_socket);

        if (clients[num_clients][1] != 0) {
            close(client_socket);
            clients[num_clients][0] = 0;
        } else {
            num_clients++;
        }
        pthread_mutex_unlock(&client_lock);
    }

    pthread_mutex_destroy(&client_lock);
    return 0;
}
```
explanation-suggested-fix: The suggested code adds a `pthread_mutex_t` named `client_lock` to ensure that the client list accesses and updates are thread-safe. This prevents race conditions by locking the mutex before accessing or modifying the shared `clients` array in both the `handle_client` function and the main loop where new threads are created and clients are added.
method: UNKNOWN
