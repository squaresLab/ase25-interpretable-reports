
vuln-fix: **CWE-200: Information Exposure** in falcon180b-50204 (severity: Medium)
what: The vulnerability occurs because the `handle_client` function prints the contents of the message buffer directly to the console using `printf`. This can expose potentially sensitive information that was transmitted by clients to unauthorized personnel monitoring the server's console.
where: The vulnerability is specifically located in the `handle_client` function of file falcon180b-50204, lines where `printf("Client %d sent: %s\n", client_socket, buffer);` is called.
why: If this vulnerability is not resolved, sensitive data such as passwords, personal information, or other confidential information could be exposed to unauthorized users, violating privacy agreements and potentially leading to data breaches.
how: An attacker could exploit this vulnerability by simply sending sensitive information over the network connection, which then gets printed out to the server's console. The attacker or an unauthorized third party monitoring the server console could then retrieve this information.
code-sources: The entry points in the code where user input enters the application are primarily through the `recv` function in the `handle_client` function.
code-sinks: The actions performed by the application using user input from a source occur within the `printf` function call in `handle_client`.
suggested-fix:
```diff
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
pthread_t thread_ids[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

-       printf("Client %d sent: %s\n", client_socket, buffer);
+       printf("Client %d sent a message\n", client_socket);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (i != client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf("Error creating socket\n");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5000);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf("Error binding socket\n");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf("Error listening on socket\n");
        exit(1);
    }

    printf("Server started on port 5000\n");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf("Error accepting connection\n");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf("Maximum number of clients reached\n");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        pthread_create(&thread_ids[num_clients], NULL, handle_client, (void *) &client_socket);
        num_clients++;
    }

    return 0;
}
```
explanation-suggested-fix: The suggested code diff resolves the vulnerability by eliminating the direct printing of client messages to the server's console, replacing it with a generic message indicating that a client sent a message. This change maintains functionality while protecting potentially sensitive information from being exposed.
method: UNKNOWN
