
    vuln-fix: CWE-415 Double Free Vulnerability in falcon180b-66050 (severity: High)
    what: The code has a vulnerability where the same memory (represented by an open socket) can be freed multiple times. Specifically, the `client_socket` is shared between the main thread and the client handler thread, causing potential race conditions leading to double free situations.
    where: 
    - Line 15: `void *handle_client(void *socket_desc) {`
    - Line 34: `close(sock);`
    - Line 66: `pthread_create(&threads[i], NULL, handle_client, &client_socket);`
    - Line 50: `close(sock);`
    why: Unmitigated double free vulnerabilities can lead to undefined behavior, including potential program crashes or the execution of arbitrary code by an attacker.
    how: An attacker could trigger a race condition where the main thread and the `handle_client` thread both attempt to close the same socket descriptor. This can cause the program to crash or, worse, allow the attacker to execute arbitrary code.
    code-sources: The entry point is the `accept()` function on line 53, where connections from clients are accepted.
    code-sinks: Actions using user input include receiving data `recv()` and sending data `send()` in the `handle_client` function.
    suggested-fix: 
```
diff --git a/falcon180b-66050 b/falcon180b-66050
index abcdef1..1234567 100644
--- a/falcon180b-66050
+++ b/falcon180b-66050
@@ -63,13 +63,19 @@ int main() {
             if (client_sockets[i] == 0) {
                 client_sockets[i] = client_socket;
-                pthread_create(&threads[i], NULL, handle_client, &client_socket);
+                int *new_sock = malloc(sizeof(int));
+                *new_sock = client_socket;
+                pthread_create(&threads[i], NULL, handle_client, (void *)new_sock);
                 break;
             }
         }
     }
 
     return 0;
 }

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
@@ -31,6 +37,7 @@ void *handle_client(void *socket_desc) {
    }

    close(sock);
+    free(socket_desc);
    return NULL;
}
```
    explanation-suggested-fix: The suggested code fix allocates memory dynamically for each client socket pointer and then frees this memory at the end of the `handle_client` function. This ensures that each thread has a unique pointer, preventing double free scenarios.
    method: UNKNOWN
