category,file_name,verification_finished,vulnerable_line,column,function,violated_property,stack_trace,error_type,code_snippet,source_code,num_lines,cyclomatic_complexity
VULNERABLE,falcon180b-54961.c,yes,17,5,handle_client,"
  file falcon180b-54961.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 12345\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",70,4.0
VULNERABLE,falcon180b-42496.c,yes,21,5,handle_client,"
  file falcon180b-42496.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error: Failed to create socket.\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error: Failed to bind socket.\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error: Failed to listen on socket.\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket!= -1) {
            printf(""Client connected: %d\n"", client_socket);
            if (num_clients >= MAX_CLIENTS) {
                close(client_socket);
                printf(""Error: Maximum number of clients reached.\n"");
            } else {
                client_sockets[num_clients] = client_socket;
                num_clients++;
                pthread_t thread_id;
                if (pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket)!= 0) {
                    printf(""Error: Failed to create thread.\n"");
                }
            }
        }
    }

    close(server_socket);
    return 0;
}",85,6.5
VULNERABLE,gpt35-68643.c,yes,32,5,client_thread,"
  file gpt35-68643.c line 32 column 5 function client_thread
","
  c:@F@client_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"pthread_mutex_t players_mutex = PTHREAD_MUTEX_INITIALIZER;

// Define the thread function to handle a client's connection
void *client_thread(void *arg) {
    // Extract the socket from the argument
    int client_socket = *(int*)arg;

    // Receive the client's name
    char name[BUFFER_SIZE];
    read(client_socket, name, BUFFER_SIZE);
","//FormAI DATASET v1.0 Category: Socket programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>

// Define the maximum number of players
#define MAX_PLAYERS 4

// Define the size of the buffer used for sending/receiving messages
#define BUFFER_SIZE 1024

// Define the server port number
#define SERVER_PORT 12345

// Define the client structure
typedef struct {
    int socket;
    char name[BUFFER_SIZE];
} client_t;

// Define the players' list and the mutex to protect it
client_t players[MAX_PLAYERS];
pthread_mutex_t players_mutex = PTHREAD_MUTEX_INITIALIZER;

// Define the thread function to handle a client's connection
void *client_thread(void *arg) {
    // Extract the socket from the argument
    int client_socket = *(int*)arg;
    
    // Receive the client's name
    char name[BUFFER_SIZE];
    read(client_socket, name, BUFFER_SIZE);
    
    // Add the client to the players' list
    pthread_mutex_lock(&players_mutex);
    int player_index = -1;
    for (int i = 0; i < MAX_PLAYERS; i++) {
        if (players[i].socket == 0) {
            players[i].socket = client_socket;
            strncpy(players[i].name, name, BUFFER_SIZE);
            player_index = i;
            break;
        }
    }
    pthread_mutex_unlock(&players_mutex);
    
    // Check if the maximum number of players has been reached
    if (player_index == -1) {
        char message[BUFFER_SIZE];
        snprintf(message, BUFFER_SIZE, ""Sorry, the game is already full."");
        write(client_socket, message, strlen(message));
        close(client_socket);
        return NULL;
    }
    
    // Notify the client about the other players' names
    char message[BUFFER_SIZE];
    int players_count = 0;
    pthread_mutex_lock(&players_mutex);
    for (int i = 0; i < MAX_PLAYERS; i++) {
        if (players[i].socket != 0 && i != player_index) {
            snprintf(message, BUFFER_SIZE, ""Player %s has joined the game."", name);
            write(players[i].socket, message, strlen(message));
            snprintf(message, BUFFER_SIZE, ""%s"", players[i].name);
            write(client_socket, message, strlen(message));
            players_count++;
        }
    }
    pthread_mutex_unlock(&players_mutex);
    
    // Wait for the game to start
    while (players_count != MAX_PLAYERS) {
      sleep(1);
    }
    
    // Start the game
    char game_message[BUFFER_SIZE];
    snprintf(game_message, BUFFER_SIZE, ""The game has started!"");
    for (int i = 0; i < MAX_PLAYERS; i++) {
        write(players[i].socket, game_message, strlen(game_message));
    }
    
    // Receive the client's messages until the game ends
    char buffer[BUFFER_SIZE];
    while (1) {
        int bytes = read(client_socket, buffer, BUFFER_SIZE);
        if (bytes <= 0) break;
        pthread_mutex_lock(&players_mutex);
        for (int i = 0; i < MAX_PLAYERS; i++) {
            if (players[i].socket != 0 && i != player_index) {
                write(players[i].socket, buffer, bytes);
            }
        }
        pthread_mutex_unlock(&players_mutex);
    }
    
    // Remove the client from the players' list
    pthread_mutex_lock(&players_mutex);
    players[player_index].socket = 0;
    pthread_mutex_unlock(&players_mutex);
    
    // Notify the other players that the client has left
    pthread_mutex_lock(&players_mutex);
    for (int i = 0; i < MAX_PLAYERS; i++) {
        if (players[i].socket != 0 && i != player_index) {
            snprintf(message, BUFFER_SIZE, ""Player %s has left the game."", name);
            write(players[i].socket, message, strlen(message));
        }
    }
    pthread_mutex_unlock(&players_mutex);
    
    // Close the client's socket
    close(client_socket);
    
    return NULL;
}

// Define the main function
int main() {
    // Initialize the players' list
    for (int i = 0; i < MAX_PLAYERS; i++) {
        players[i].socket = 0;
        memset(players[i].name, 0, BUFFER_SIZE);
    }
    
    // Create the server socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""Failed to create server socket"");
        exit(1);
    }
    
    // Bind the server socket to the port and start listening for connections
    struct sockaddr_in server_address = {0};
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(SERVER_PORT);
    server_address.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) == -1) {
        perror(""Failed to bind server socket"");
        exit(1);
    }
    if (listen(server_socket, MAX_PLAYERS) == -1) {
        perror(""Failed to start listening for connections"");
        exit(1);
    }
    
    // Accept clients' connections in a loop
    while (1) {
        // Accept a client's connection
        struct sockaddr_in client_address = {0};
        socklen_t client_address_size = sizeof(client_address);
        int client_socket = accept(server_socket, (struct sockaddr*)&client_address, &client_address_size);
        if (client_socket == -1) {
            perror(""Failed to accept client connection"");
            exit(1);
        }
        
        // Create a thread to handle the client's connection
        pthread_t thread;
        if (pthread_create(&thread, NULL, client_thread, &client_socket) != 0) {
            perror(""Failed to create client thread"");
            exit(1);
        }
        pthread_detach(thread);
    }
    
    // Close the server socket
    close(server_socket);
    
    return 0;
}",175,12.5
VULNERABLE,falcon180b-7503.c,yes,20,5,handle_client,"
  file falcon180b-7503.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            client_sockets[client_count - 1] = -1;
            client_count--;
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    return NULL;
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket!= -1) {
            client_sockets[client_count] = client_socket;
            client_count++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",84,4.5
VULNERABLE,falcon180b-2373.c,yes,18,5,handle_client,"
  file falcon180b-2373.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char buffer[BUFFER_SIZE];
    int client_socket = *(int *) socket_desc;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char buffer[BUFFER_SIZE];
    int client_socket = *(int *) socket_desc;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main(int argc, char *argv[]) {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        printf(""Client connected. Total clients: %d\n"", num_clients);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",80,3.667
VULNERABLE,falcon180b-44796.c,yes,22,5,handle_client,"
  file falcon180b-44796.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(sock);
            pthread_exit(NULL);
        }
        printf(""Client %d sent: %s\n"", sock, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= sock) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-5931.c,yes,20,5,handle_client,"
  file falcon180b-5931.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CONNECTIONS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];
    printf(""Client %d connected\n"", client_socket);

    // Receive message from client
    memset(buffer, 0, MAX_MSG_SIZE);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CONNECTIONS 10
#define MAX_MSG_SIZE 1024

int client_sockets[MAX_CONNECTIONS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];
    printf(""Client %d connected\n"", client_socket);

    // Receive message from client
    memset(buffer, 0, MAX_MSG_SIZE);
    int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);
    if (bytes_received <= 0) {
        printf(""Client %d disconnected\n"", client_socket);
        close(client_socket);
        return NULL;
    }
    printf(""Received message from client %d: %s\n"", client_socket, buffer);

    // Send message to all clients
    for (int i = 0; i < num_clients; i++) {
        if (client_socket!= client_sockets[i]) {
            send(client_sockets[i], buffer, strlen(buffer), 0);
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CONNECTIONS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        socklen_t socklen = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &socklen);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CONNECTIONS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",89,5.5
VULNERABLE,gpt35-21987.c,yes,70,5,server_handler,"
  file gpt35-21987.c line 70 column 5 function server_handler
","
  c:@F@server_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *server_handler(void *arg)
{
    int sock = *(int *)arg;
    char buffer[1024] = {0};
    int valread;
    char *response = ""Hello from server."";
    send(sock, response, strlen(response), 0);
","//FormAI DATASET v1.0 Category: Networking ; Style: content
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

void *server_handler(void *arg);
void *client_handler(void *arg);

int main(int argc, char const *argv[])
{
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    // Forcefully attaching socket to the PORT
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
    {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Forcefully attaching socket to the PORT
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }
    if (listen(server_fd, 3) < 0)
    {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }
    printf(""Server is listening on port %d\n"", PORT);

    // handle multiple client requests
    pthread_t thread_id;
    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)))
    {
        printf(""New client connection accepted.\n"");

        if (pthread_create(&thread_id, NULL, server_handler, (void *)&new_socket) < 0)
        {
            perror(""Could not create thread.\n"");
            return -1;
        }
    }

    return 0;
}

void *server_handler(void *arg)
{
    int sock = *(int *)arg;
    char buffer[1024] = {0};
    int valread;
    char *response = ""Hello from server."";
    send(sock, response, strlen(response), 0);

    while ((valread = read(sock, buffer, 1024)) > 0)
    {
        printf(""Received Message: %s\n"", buffer);

        if (strcmp(buffer, ""exit"") == 0)
        {
            char *bye_bye = ""Goodbye! Hope to see you again."";
            send(sock, bye_bye, strlen(bye_bye), 0);
            printf(""Client has disconnected.\n"");
            close(sock);
            return NULL;
        }

        else
        {
            // Sending response to the client
            response = ""Message received. Thank you."";
            send(sock, response, strlen(response), 0);
        }
        memset(buffer, 0, sizeof(buffer));
    }
    return NULL;
}",98,5.0
VULNERABLE,gpt35-51180.c,yes,63,5,run_task,"
  file gpt35-51180.c line 63 column 5 function run_task
","
  c:@F@run_task at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `highest_priority_task'",dereference failure: accessed expired variable pointer,"    Task* current_task = (Task*)task;

    printf(""Executing task: %s\n"", current_task->task_name);
    system(current_task->task_location);

    current_task->is_running = false;

    return NULL;
}

void dispatch_tasks(int thread_pool_size) {","//FormAI DATASET v1.0 Category: Task Scheduler ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <time.h>
#include <pthread.h>

#define TASK_NAME_MAX_LENGTH 50
#define MAX_TASKS 100
#define MAX_THREAD_POOL_SIZE 10

typedef struct {
    char task_name[TASK_NAME_MAX_LENGTH];
    int priority;
    int frequency; 
    char task_location[50];
    bool is_running;
} Task;

Task task_queue[MAX_TASKS];
int task_queue_length = 0;
pthread_mutex_t task_queue_mutex;

void add_task_to_queue(Task task) {
    pthread_mutex_lock(&task_queue_mutex);

    task_queue[task_queue_length++] = task;

    pthread_mutex_unlock(&task_queue_mutex);
}

Task get_highest_priority_task() {
    pthread_mutex_lock(&task_queue_mutex);

    Task highest_priority_task = task_queue[0];
    int highest_priority_index = 0;

    for(int i=1; i<task_queue_length; i++) {
        if(task_queue[i].priority > highest_priority_task.priority) {
            highest_priority_task = task_queue[i];
            highest_priority_index = i;
        }
    }

    for(int i=highest_priority_index; i<task_queue_length-1; i++) {
        task_queue[i] = task_queue[i+1];
    }

    task_queue_length--;

    pthread_mutex_unlock(&task_queue_mutex);

    return highest_priority_task;
}

void* run_task(void* task) {
    Task* current_task = (Task*)task;

    printf(""Executing task: %s\n"", current_task->task_name);
    system(current_task->task_location);

    current_task->is_running = false;

    return NULL;
}

void dispatch_tasks(int thread_pool_size) {
    pthread_t thread_pool[MAX_THREAD_POOL_SIZE];
    int threads_in_use = 0;

    while(1) {
        if(threads_in_use == thread_pool_size || task_queue_length == 0) {
            continue;
        }

        Task highest_priority_task = get_highest_priority_task();

        pthread_create(&thread_pool[threads_in_use++], NULL, run_task, (void*)&highest_priority_task);

        while(threads_in_use != 0 && pthread_tryjoin_np(thread_pool[threads_in_use-1], NULL) == 0) {
            threads_in_use--;
        }
    }
}

int main() {
    srand(time(NULL));

    pthread_mutex_init(&task_queue_mutex, NULL);

    Task task1 = {""task1"", 2, 5, ""echo 'This is task 1'"", false};
    Task task2 = {""task2"", 3, 10, ""mkdir task2_folder"", false};
    Task task3 = {""task3"", 1, 3, ""ls"", false};
    Task task4 = {""task4"", 4, 2, ""touch task4_file"", false};

    add_task_to_queue(task1);
    add_task_to_queue(task2);
    add_task_to_queue(task3);
    add_task_to_queue(task4);

    dispatch_tasks(4);

    pthread_mutex_destroy(&task_queue_mutex);

    return 0;
}",107,2.6
VULNERABLE,falcon180b-26756.c,yes,22,5,handle_client,"
  file falcon180b-26756.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENT];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENT 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENT];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        printf(""Socket creation failed\n"");
        exit(1);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Bind failed\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Listen failed\n"");
        exit(1);
    }

    while (1) {
        int client_socket;
        socklen_t client_size;

        if ((client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &client_size)) == -1) {
            printf(""Accept failed\n"");
            exit(1);
        }

        int i;
        for (i = 0; i < MAX_CLIENT; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                client_count++;
                break;
            }
        }

        if (i == MAX_CLIENT) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",95,6.0
VULNERABLE,falcon180b-6547.c,yes,38,5,handle_client_request,"
  file falcon180b-6547.c line 38 column 5 function handle_client_request
","
  c:@F@handle_client_request at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    sem_post(&g_client_sem);
}

// Function to handle client requests
void *handle_client_request(void *socket_ptr) {
    int client_socket = *((int *)socket_ptr);

    char buffer[MAX_REQUEST_LENGTH];
    while (1) {
        memset(buffer, 0, MAX_REQUEST_LENGTH);
        int bytes_received = recv(client_socket, buffer, MAX_REQUEST_LENGTH, 0);","//Falcon-180B DATASET v1.0 Category: Appointment Scheduler ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_REQUEST_LENGTH 1024
#define SEMAPHORE_VALUE 1

int g_client_count = 0;
int g_client_sockets[MAX_CLIENTS];
sem_t g_client_sem;

// Function to initialize the semaphore
void init_semaphore() {
    sem_init(&g_client_sem, 0, SEMAPHORE_VALUE);
}

// Function to lock the semaphore
void lock_semaphore() {
    sem_wait(&g_client_sem);
}

// Function to unlock the semaphore
void unlock_semaphore() {
    sem_post(&g_client_sem);
}

// Function to handle client requests
void *handle_client_request(void *socket_ptr) {
    int client_socket = *((int *)socket_ptr);

    char buffer[MAX_REQUEST_LENGTH];
    while (1) {
        memset(buffer, 0, MAX_REQUEST_LENGTH);
        int bytes_received = recv(client_socket, buffer, MAX_REQUEST_LENGTH, 0);
        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent the following request: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

// Function to accept client connections
void accept_client_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    while (1) {
        printf(""Waiting for client connection...\n"");
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting client connection\n"");
            continue;
        }

        lock_semaphore();
        g_client_sockets[g_client_count] = client_socket;
        g_client_count++;
        unlock_semaphore();

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client_request, (void *)&client_socket);
    }
}

// Main function
int main() {
    init_semaphore();
    accept_client_connections();

    return 0;
}",103,2.167
VULNERABLE,falcon180b-628.c,yes,19,5,handle_client,"
  file falcon180b-628.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        perror(""socket"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        return 1;
    }

    if (listen(server_socket, 10) == -1) {
        perror(""listen"");
        return 1;
    }

    accept_connections(server_socket);

    return 0;
}",86,3.667
VULNERABLE,falcon180b-48091.c,yes,19,5,handle_client,"
  file falcon180b-48091.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: high level of detail
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 512

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        socklen_t client_addr_size = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *) &clients[num_clients], &client_addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        num_clients++;
        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",81,4.5
VULNERABLE,falcon180b-8171.c,yes,21,5,handle_client,"
  file falcon180b-8171.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Packet Monitoring ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(12345);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 12345\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 11, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-20132.c,yes,17,5,thread_func,"
  file falcon180b-20132.c line 17 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Global variable shared by all threads
int shared_var = 0;

// Function executed by each thread
void* thread_func(void* arg) {
    int id = *(int*) arg;

    printf(""Thread %d started\n"", id);

    // Lock the mutex before entering critical section
    pthread_mutex_lock(&lock);","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex lock for critical section
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for thread synchronization
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Global variable shared by all threads
int shared_var = 0;

// Function executed by each thread
void* thread_func(void* arg) {
    int id = *(int*) arg;

    printf(""Thread %d started\n"", id);

    // Lock the mutex before entering critical section
    pthread_mutex_lock(&lock);

    // Wait for turn using condition variable
    printf(""Thread %d waiting...\n"", id);
    pthread_cond_wait(&cond, &lock);
    printf(""Thread %d got the lock\n"", id);

    // Critical section
    shared_var++;
    printf(""Thread %d incremented shared_var to %d\n"", id, shared_var);

    // Signal next thread and unlock mutex
    pthread_cond_signal(&cond);
    pthread_mutex_unlock(&lock);

    return NULL;
}

int main() {
    int num_threads = 5;
    pthread_t threads[num_threads];

    // Create threads
    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void*) &i);
    }

    // Join threads
    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",55,2.0
VULNERABLE,falcon180b-40026.c,yes,19,5,handle_client,"
  file falcon180b-40026.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_socket = -1;
int g_clients[MAX_CLIENTS] = {0};
int g_num_clients = 0;

void *handle_client(void *param) {
    int client_socket = *(int *)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Robot movement control ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_socket = -1;
int g_clients[MAX_CLIENTS] = {0};
int g_num_clients = 0;

void *handle_client(void *param) {
    int client_socket = *(int *)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(g_socket, NULL, NULL);

        if (g_num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 15, 0);
            close(client_socket);
            continue;
        }

        g_clients[g_num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
}

int main() {
    g_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (g_socket == -1) {
        printf(""Error creating socket.\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(g_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket.\n"");
        return 1;
    }

    if (listen(g_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket.\n"");
        return 1;
    }

    printf(""Server started on port %d.\n"", PORT);
    accept_connections();

    return 0;
}",81,3.333
VULNERABLE,gemini_pro-24092.c,yes,15,5,handle_client,"
  file gemini_pro-24092.c line 15 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientfd'",dereference failure: accessed expired variable pointer,"#define PORT 8080

// Function to handle client requests
void *handle_client(void *args)
{
    int sockfd = *(int *)args;
    char buffer[1024];

    // Receive the request from the client
    int n = read(sockfd, buffer, sizeof(buffer));
    if (n < 0)","//GEMINI-pro DATASET v1.0 Category: Simple Web Server ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080

// Function to handle client requests
void *handle_client(void *args)
{
    int sockfd = *(int *)args;
    char buffer[1024];

    // Receive the request from the client
    int n = read(sockfd, buffer, sizeof(buffer));
    if (n < 0)
    {
        perror(""read"");
        close(sockfd);
        pthread_exit(NULL);
    }

    // Parse the request to get the requested URL
    char *url = strtok(buffer, "" "");
    if (!url)
    {
        perror(""strtok"");
        close(sockfd);
        pthread_exit(NULL);
    }

    // Open the requested file
    FILE *fp = fopen(url + 1, ""rb"");
    if (!fp)
    {
        perror(""fopen"");
        close(sockfd);
        pthread_exit(NULL);
    }

    // Send the file contents to the client
    int bytes_sent;
    while ((bytes_sent = fread(buffer, 1, sizeof(buffer), fp)) > 0)
    {
        if (write(sockfd, buffer, bytes_sent) < 0)
        {
            perror(""write"");
            close(sockfd);
            fclose(fp);
            pthread_exit(NULL);
        }
    }

    // Close the socket and the file
    close(sockfd);
    fclose(fp);

    pthread_exit(NULL);
}

int main()
{
    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Bind the socket to the port
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for client connections
    if (listen(sockfd, 5) < 0)
    {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    // Accept client connections and handle them in separate threads
    while (1)
    {
        int clientfd = accept(sockfd, NULL, NULL);
        if (clientfd < 0)
        {
            perror(""accept"");
            continue;
        }

        pthread_t tid;
        if (pthread_create(&tid, NULL, handle_client, &clientfd) != 0)
        {
            perror(""pthread_create"");
            close(clientfd);
            continue;
        }

        pthread_detach(tid);
    }

    // Close the listening socket
    close(sockfd);

    return 0;
}",118,6.5
VULNERABLE,falcon180b-27973.c,yes,17,5,handle_client,"
  file falcon180b-27973.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Browser Plugin ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",69,3.5
VULNERABLE,falcon180b-59240.c,yes,21,5,handle_client,"
  file falcon180b-59240.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg)
{
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1)
    {
        memset(buffer, 0, BUFFER_SIZE);","//Falcon-180B DATASET v1.0 Category: Wireless Network Scanner ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080
#define SERVER_IP ""127.0.0.1""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg)
{
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1)
    {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0)
        {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

void broadcast_message(int sender_socket, char *message)
{
    for (int i = 0; i < num_clients; i++)
    {
        if (i!= sender_socket)
        {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

int main()
{
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port %d\n"", SERVER_PORT);

    while (1)
    {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS)
        {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",83,3.0
VULNERABLE,gemini_pro-13367.c,yes,34,3,thread_function,"
  file gemini_pro-13367.c line 34 column 3 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"struct sockaddr_in servaddr;

// Define the thread function
void *thread_function(void *arg) {
  // Get the thread's ID
  int tid = *(int *)arg;

  // Create a buffer
  char buffer[BUFFER_SIZE];

  // Send a request to the server","//GEMINI-pro DATASET v1.0 Category: Internet Speed Test Application ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>

// Define the server's IP address and port
#define SERVER_IP ""192.168.1.1""
#define SERVER_PORT 80

// Define the number of threads to use
#define NUM_THREADS 4

// Define the buffer size
#define BUFFER_SIZE 1024

// Define the number of iterations
#define NUM_ITERATIONS 10

// Define the global variables
int sockfd;
struct sockaddr_in servaddr;

// Define the thread function
void *thread_function(void *arg) {
  // Get the thread's ID
  int tid = *(int *)arg;

  // Create a buffer
  char buffer[BUFFER_SIZE];

  // Send a request to the server
  sprintf(buffer, ""GET / HTTP/1.1\r\nHost: %s\r\n\r\n"", SERVER_IP);
  send(sockfd, buffer, strlen(buffer), 0);

  // Receive the response from the server
  int n;
  while ((n = recv(sockfd, buffer, BUFFER_SIZE, 0)) > 0) {
    // Do something with the data
  }

  // Close the socket
  close(sockfd);

  // Return the thread's ID
  return (void *)tid;
}

// Define the main function
int main(int argc, char **argv) {
  // Create a socket
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    perror(""socket"");
    exit(1);
  }

  // Connect to the server
  servaddr.sin_family = AF_INET;
  servaddr.sin_port = htons(SERVER_PORT);
  servaddr.sin_addr.s_addr = inet_addr(SERVER_IP);
  if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1) {
    perror(""connect"");
    exit(1);
  }

  // Create the threads
  pthread_t threads[NUM_THREADS];
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_create(&threads[i], NULL, thread_function, (void *)&i);
  }

  // Join the threads
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  // Close the socket
  close(sockfd);

  return 0;
}",89,3.5
VULNERABLE,falcon180b-36726.c,yes,19,5,handle_client,"
  file falcon180b-36726.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Color Code Converter ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (num_clients < MAX_CLIENTS) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",59,4.0
VULNERABLE,falcon180b-4529.c,yes,19,5,handle_client,"
  file falcon180b-4529.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        // Send message to all other clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    printf(""Client %d disconnected\n"", client_socket);

    pthread_exit(0);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 44, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",80,4.0
VULNERABLE,falcon180b-41358.c,yes,54,5,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-41358.c line 54 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"    strcpy(address, get_input(""""));
    printf(""Your address is: %s\n"", address);

    // Get user input for phone number
    printf(""Enter your phone number: "");
    strcpy(phone_number, get_input(""""));
    printf(""Your phone number is: %s\n"", phone_number);

    return 0;
}","//Falcon-180B DATASET v1.0 Category: User Input Sanitizer ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_INPUT_LENGTH 1000

// Function to sanitize user input
void sanitize_input(char *input) {
    int i;
    for (i = 0; i < strlen(input); i++) {
        if (!isalnum(input[i])) {
            input[i] = '\0';
        }
    }
}

// Function to validate user input
int validate_input(char *input) {
    if (strlen(input) == 0) {
        return 0;
    }
    return 1;
}

// Function to get user input
char *get_input(char *prompt) {
    char input[MAX_INPUT_LENGTH];
    printf(""%s"", prompt);
    fgets(input, MAX_INPUT_LENGTH, stdin);
    input[strcspn(input, ""\n"")] = '\0';
    sanitize_input(input);
    return input;
}

int main() {
    char name[MAX_INPUT_LENGTH];
    char address[MAX_INPUT_LENGTH];
    char phone_number[MAX_INPUT_LENGTH];

    // Get user input for name
    printf(""Enter your name: "");
    strcpy(name, get_input(""""));
    printf(""Your name is: %s\n"", name);

    // Get user input for address
    printf(""Enter your address: "");
    strcpy(address, get_input(""""));
    printf(""Your address is: %s\n"", address);

    // Get user input for phone number
    printf(""Enter your phone number: "");
    strcpy(phone_number, get_input(""""));
    printf(""Your phone number is: %s\n"", phone_number);

    return 0;
}",58,1.75
VULNERABLE,falcon180b-2435.c,yes,19,5,handle_client,"
  file falcon180b-2435.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while (1) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_DATA_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while (1) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(3000);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port 3000\n"");

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Server is full. Cannot accept more clients.\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_create(&threads[num_clients - 1], NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,codellama_13b-7434.c,yes,47,9,main,"
  file codellama_13b-7434.c line 47 column 9 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `amount'",dereference failure: accessed expired variable pointer,"        accounts[0].balance += amount;
        printf(""Your new balance is: $%.2f\n"", accounts[0].balance);
        break;
      case 3:
        printf(""Enter the amount to withdraw: "");
        scanf(""%f"", &amount);
        accounts[0].balance -= amount;
        printf(""Your new balance is: $%.2f\n"", accounts[0].balance);
        break;
      case 4:
        printf(""Thank you for using our funny banking system! 😄\n"");","//Code Llama-13B DATASET v1.0 Category: Banking Record System ; Style: funny
// A unique C Banking Record System example program in a funny style

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct account {
  char name[20];
  float balance;
};

int main() {
  struct account accounts[5] = {
    {""John"", 1000},
    {""Mary"", 2000},
    {""Bob"", 3000},
    {""Alice"", 4000},
    {""Eve"", 5000}
  };

  printf(""Welcome to our funny banking system! 😄\n"");

  int option;
  do {
    printf(""1. Check balance\n"");
    printf(""2. Deposit money\n"");
    printf(""3. Withdraw money\n"");
    printf(""4. Exit\n"");

    printf(""Enter your choice: "");
    scanf(""%d"", &option);

    switch (option) {
      case 1:
        printf(""Your current balance is: $%.2f\n"", accounts[0].balance);
        break;
      case 2:
        printf(""Enter the amount to deposit: "");
        float amount;
        scanf(""%f"", &amount);
        accounts[0].balance += amount;
        printf(""Your new balance is: $%.2f\n"", accounts[0].balance);
        break;
      case 3:
        printf(""Enter the amount to withdraw: "");
        scanf(""%f"", &amount);
        accounts[0].balance -= amount;
        printf(""Your new balance is: $%.2f\n"", accounts[0].balance);
        break;
      case 4:
        printf(""Thank you for using our funny banking system! 😄\n"");
        break;
      default:
        printf(""Invalid option. Try again!\n"");
    }
  } while (option != 4);

  return 0;
}",60,6.0
VULNERABLE,falcon180b-58623.c,yes,19,5,handle_client,"
  file falcon180b-58623.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    bzero(buffer, BUFFER_SIZE);

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080
#define SERVER_IP ""127.0.0.1""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    bzero(buffer, BUFFER_SIZE);

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more clients.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();
    return 0;
}",85,3.667
VULNERABLE,falcon180b-44235.c,yes,18,5,thread_function,"
  file falcon180b-44235.c line 18 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
#define BUFFER_SIZE 1024
#define PORT 8080

void *thread_function(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>

#define BUFFER_SIZE 1024
#define PORT 8080

void *thread_function(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_function, (void *) &client_socket);
    }

    return 0;
}",60,2.5
VULNERABLE,falcon180b-4508.c,yes,19,5,handle_client,"
  file falcon180b-4508.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 512

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            clients[num_clients] = -1;
            num_clients--;
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= -1) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(5000);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server listening on port 5000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

            printf(""Client connected, total clients: %d\n"", num_clients);
        }
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-11100.c,yes,16,5,handle_connection,"
  file falcon180b-11100.c line 16 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int connections[MAX_CONNECTIONS];
int num_connections = 0;

void* handle_connection(void* arg) {
    int client_socket = *((int*) arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CONNECTIONS 10
#define BUFFER_SIZE 1024

int connections[MAX_CONNECTIONS];
int num_connections = 0;

void* handle_connection(void* arg) {
    int client_socket = *((int*) arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char* request = strtok(buffer, "" "");
        if (request == NULL) {
            continue;
        }

        if (strcmp(request, ""GET"") == 0) {
            char* uri = strtok(NULL, "" "");
            if (uri == NULL) {
                continue;
            }

            if (strstr(uri, "".php"")!= NULL) {
                printf(""Possible intrusion detected on connection %d\n"", client_socket);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    if (bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CONNECTIONS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr*) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_connections >= MAX_CONNECTIONS) {
            close(client_socket);
            printf(""Maximum number of connections reached\n"");
            continue;
        }

        connections[num_connections] = client_socket;
        num_connections++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_connection, &client_socket);
    }
}

int main() {
    accept_connections();

    return 0;
}",102,5.0
VULNERABLE,falcon180b-59563.c,yes,19,5,handle_client,"
  file falcon180b-59563.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS], num_clients = 0;
int server_socket;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT ""8080""

int clients[MAX_CLIENTS], num_clients = 0;
int server_socket;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket_copy);
            return NULL;
        }

        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);
        send(client_socket_copy, buffer, strlen(buffer), 0);
    }
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(atoi(PORT));

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %s\n"", PORT);

    while (1) {
        socklen_t addr_size;
        struct sockaddr_in client_addr;
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket < 0) {
            perror(""accept"");
            exit(EXIT_FAILURE);
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",92,5.5
VULNERABLE,llama2-13B_3.c,yes,15,13,print_matrix,"
  file llama2-13B_3.c line 15 column 13 function print_matrix
","
  c:@F@print_matrix at file llama2-13B_3.c line 92 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `inv'",dereference failure: accessed expired variable pointer,"// Function to print the matrix
void print_matrix(int mat[M][N]) {
    int i, j;
    for (i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }
}
","//LLAMA2-13B DATASET v1.0 Category: Matrix operations ; Style: standalone
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define M 5 // size of the matrix
#define N 3 // number of elements in each row

// Function to print the matrix
void print_matrix(int mat[M][N]) {
    int i, j;
    for (i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            printf(""%d "", mat[i][j]);
        }
        printf(""\n"");
    }
}

// Function to perform matrix multiplication
int matrix_multiply(int mat1[M][N], int mat2[M][N], int mat3[M][N]) {
    int i, j, k;
    for (i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            int sum = 0;
            for (k = 0; k < N; k++) {
                sum += mat1[i][k] * mat2[k][j];
            }
            mat3[i][j] = sum;
        }
    }
    return 0;
}

// Function to perform matrix addition
int matrix_add(int mat1[M][N], int mat2[M][N], int mat3[M][N]) {
    int i, j, k;
    for (i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            int sum = 0;
            for (k = 0; k < N; k++) {
                sum += mat1[i][k] + mat2[i][k];
            }
            mat3[i][j] = sum;
        }
    }
    return 0;
}

// Function to perform matrix inversion
int matrix_invert(int mat[M][N]) {
    int i, j, k;
    int inv[M][N];
    for (i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            inv[i][j] = 0;
        }
    }
    for (i = 0; i < M; i++) {
        for (j = 0; j < N; j++) {
            for (k = 0; k < N; k++) {
                inv[i][j] += mat[i][k] * inv[k][j];
            }
        }
    }
    return inv;
}

int main() {
    int mat1[M][N] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
            mat2[M][N] = {{10, 20, 30}, {40, 50, 60}, {70, 80, 90}},
            mat3[M][N] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}},
            i, j, k;

    // Perform matrix multiplication
    matrix_multiply(mat1, mat2, mat3);

    // Print the result
    print_matrix(mat3);

    // Perform matrix addition
    matrix_add(mat1, mat2, mat3);

    // Print the result
    print_matrix(mat3);

    // Perform matrix inversion
    int inv_mat = matrix_invert(mat1);

    // Print the result
    print_matrix(inv_mat);

    return 0;
}",95,3.6
VULNERABLE,falcon180b-71515.c,yes,19,5,handle_client,"
  file falcon180b-71515.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == client_socket) {
            clients[i] = -1;
            break;
        }
    }

    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 50, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",99,7.0
VULNERABLE,falcon180b-6105.c,yes,19,5,handle_client,"
  file falcon180b-6105.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

void broadcast_message(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (i!= sender_socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 41, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        printf(""Client %d connected.\n"", client_socket);

        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",76,3.667
VULNERABLE,gemini_pro-37830.c,yes,18,5,handle_client,"
  file gemini_pro-37830.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `newsockfd'",dereference failure: accessed expired variable pointer,"// A happy greeting to send clients
const char *greeting = ""Hello, world! We're glad you're here :)\n"";

// This thread function handles communication with individual clients
void *handle_client(void *arg) {
    int sockfd = *(int *)arg;

    // Receive the client's message
    char buffer[1024];
    int n = read(sockfd, buffer, sizeof(buffer));
","//GEMINI-pro DATASET v1.0 Category: Socket programming ; Style: happy
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <pthread.h>

#define PORT 8080

// A happy greeting to send clients
const char *greeting = ""Hello, world! We're glad you're here :)\n"";

// This thread function handles communication with individual clients
void *handle_client(void *arg) {
    int sockfd = *(int *)arg;

    // Receive the client's message
    char buffer[1024];
    int n = read(sockfd, buffer, sizeof(buffer));

    // Print the client's message
    printf(""Client: %s"", buffer);

    // Send the greeting to the client
    write(sockfd, greeting, strlen(greeting));

    // Close the client socket
    close(sockfd);

    return NULL;
}

int main() {
    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Bind the socket to an address
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(PORT);
    addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for connections
    if (listen(sockfd, 5) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    // Accept connections and spawn threads to handle them
    while (1) {
        // Accept a connection
        int newsockfd = accept(sockfd, NULL, NULL);
        if (newsockfd == -1) {
            perror(""accept"");
            continue;
        }

        // Create a thread to handle the connection
        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, &newsockfd);
        pthread_detach(thread);
    }

    // Close the socket
    close(sockfd);

    return 0;
}",79,3.5
VULNERABLE,falcon180b-21851.c,yes,22,5,handle_client,"
  file falcon180b-21851.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while (1) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_DATA_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while (1) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;
    struct hostent *host;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        printf(""Error setting socket option\n"");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Error listening on socket\n"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port 8080\n"");

    while (1) {
        socklen_t addr_size;
        struct sockaddr_in client_addr;

        memset(&client_addr, 0, sizeof(client_addr));
        addr_size = sizeof(client_addr);

        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    close(server_socket);
    return 0;
}",102,6.0
VULNERABLE,falcon180b-755.c,yes,18,5,handle_client,"
  file falcon180b-755.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int main_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Medical Store Management System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int main_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void add_client(int client_socket) {
    if (num_clients >= MAX_CLIENTS) {
        printf(""Maximum number of clients reached.\n"");
        return;
    }

    clients[num_clients] = client_socket;
    num_clients++;

    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
}

int main() {
    int main_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (main_socket == -1) {
        printf(""Error creating socket.\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(main_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket.\n"");
        return 1;
    }

    if (listen(main_socket, 10) == -1) {
        printf(""Error listening on socket.\n"");
        return 1;
    }

    printf(""Server started on port 8080.\n"");

    while (1) {
        int client_socket = accept(main_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection.\n"");
            continue;
        }

        add_client(client_socket);
    }

    close(main_socket);
    return 0;
}",88,3.667
VULNERABLE,gpt35-75557.c,yes,28,5,handle_connection,"
  file gpt35-75557.c line 28 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    write(socket_fd, response, strlen(response));
    close(socket_fd);
}

void *handle_connection(void *arg) {
    int socket_fd = *((int *) arg);
    handle_request(socket_fd);
    return NULL;
}

void signal_handler() {","//FormAI DATASET v1.0 Category: Simple Web Server ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <signal.h>

#define MAX_CONNECTIONS 10
#define PORT_NUMBER 8080
#define BUFFER_SIZE 1024

int server_socket;
pthread_t threads[MAX_CONNECTIONS];

void handle_request(int socket_fd) {
    char buffer[BUFFER_SIZE];
    read(socket_fd, buffer, BUFFER_SIZE);
    printf(""Received request: %s\n"", buffer);
    char response[BUFFER_SIZE] = ""HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 12\n\nHello World!"";
    write(socket_fd, response, strlen(response));
    close(socket_fd);
}

void *handle_connection(void *arg) {
    int socket_fd = *((int *) arg);
    handle_request(socket_fd);
    return NULL;
}

void signal_handler() {
    printf(""Shutting down server...\n"");
    close(server_socket);
    exit(0);
}

int main() {
    // Ignore SIGPIPE signal to prevent crashes when writing to closed sockets
    signal(SIGPIPE, SIG_IGN);
    
    // Set up server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr = { 0 };
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT_NUMBER);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CONNECTIONS);
    
    // Set up handler for SIGINT signal to gracefully shutdown server
    signal(SIGINT, signal_handler);

    // Accept incoming connections and spawn threads to handle them
    while (1) {
        struct sockaddr_in client_addr = { 0 };
        socklen_t client_addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_len);
        pthread_t thread;
        pthread_create(&thread, NULL, handle_connection, &client_socket);
        for (int i = 0; i < MAX_CONNECTIONS; i++) {
            if (!threads[i]) {
                threads[i] = thread;
                break;
            }
            if (i == MAX_CONNECTIONS - 1) {
                printf(""Maximum number of connections reached.\n"");
                close(client_socket);
            }
        }
        pthread_detach(thread);
    }
    return 0;
}",75,2.0
VULNERABLE,gemini_pro-29412.c,yes,56,7,main,"
  file gemini_pro-29412.c line 56 column 7 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `shift'",dereference failure: accessed expired variable pointer,"      result = n << shift;
      printf(""The left shift of %u by %d is %u\n"", n, shift, result);
      break;
    case 6:
      printf(""Enter the number of bits to shift right: "");
      scanf(""%d"", &shift);
      result = n >> shift;
      printf(""The right shift of %u by %d is %u\n"", n, shift, result);
      break;
    default:
      printf(""Invalid choice, brave soul. Try again.\n"");","//GEMINI-pro DATASET v1.0 Category: Bitwise operations ; Style: medieval
#include <stdio.h>
#include <stdlib.h>

int main() {

  // Declare ye variables, brave adventurer!
  unsigned int n, m, result;
  int choice;

  // A hearty welcome to the land of bitwise operations!
  printf(""Welcome to the realm of bitwise operations, fair traveler!\n"");
  printf(""Choose thy weapon (bitwise operation):\n"");
  printf(""1. AND (&)\n"");
  printf(""2. OR (|)\n"");
  printf(""3. XOR (^)\n"");
  printf(""4. NOT (~)\n"");
  printf(""5. Left Shift (<<)\n"");
  printf(""6. Right Shift (>>)\n"");
  printf(""Enter thy choice, valiant one: "");
  scanf(""%d"", &choice);

  // Receive the numbers thou wishest to operate upon
  printf(""Enter the first number, brave soul: "");
  scanf(""%u"", &n);
  printf(""Enter the second number, valiant warrior: "");
  scanf(""%u"", &m);

  // Perform the chosen operation upon the numbers
  switch (choice) {
    case 1:
      result = n & m;
      printf(""The AND of %u and %u is %u\n"", n, m, result);
      break;
    case 2:
      result = n | m;
      printf(""The OR of %u and %u is %u\n"", n, m, result);
      break;
    case 3:
      result = n ^ m;
      printf(""The XOR of %u and %u is %u\n"", n, m, result);
      break;
    case 4:
      result = ~n;
      printf(""The NOT of %u is %u\n"", n, result);
      break;
    case 5:
      printf(""Enter the number of bits to shift left: "");
      int shift;
      scanf(""%d"", &shift);
      result = n << shift;
      printf(""The left shift of %u by %d is %u\n"", n, shift, result);
      break;
    case 6:
      printf(""Enter the number of bits to shift right: "");
      scanf(""%d"", &shift);
      result = n >> shift;
      printf(""The right shift of %u by %d is %u\n"", n, shift, result);
      break;
    default:
      printf(""Invalid choice, brave soul. Try again.\n"");
  }

  // Bid farewell to the valiant adventurer
  printf(""May thy quest for knowledge be fruitful, brave adventurer!\n"");
  return 0;
}",67,7.0
VULNERABLE,falcon180b-54342.c,yes,18,5,handle_client,"
  file falcon180b-54342.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System process viewer ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",67,4.0
VULNERABLE,falcon180b-22942.c,yes,17,5,handle_client,"
  file falcon180b-22942.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        send(client_socket, buffer, bytes_received, 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            continue;
        }

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",67,3.5
VULNERABLE,falcon180b-68716.c,yes,19,5,thread_routine,"
  file falcon180b-68716.c line 19 column 5 function thread_routine
","
  c:@F@thread_routine at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *thread_routine(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *thread_routine(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more connections.\n"");
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_routine, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections();

    return 0;
}",79,3.333
VULNERABLE,gpt35-18284.c,yes,20,5,handle_client,"
  file gpt35-18284.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;
    char buffer[BUFFER_SIZE];
    while (1) {
        int read_size = read(sock, buffer, BUFFER_SIZE);
        if (read_size < 0) {
            perror(""Error reading from client"");","//FormAI DATASET v1.0 Category: Chat server ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;
    char buffer[BUFFER_SIZE];
    while (1) {
        int read_size = read(sock, buffer, BUFFER_SIZE);
        if (read_size < 0) {
            perror(""Error reading from client"");
            break;
        }
        buffer[read_size] = '\0';
        printf(""Client %d says: %s\n"", sock, buffer);
        pthread_mutex_lock(&client_mutex);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i] != sock) {
                write(clients[i], buffer, strlen(buffer));
            }
        }
        pthread_mutex_unlock(&client_mutex);
    }
    pthread_mutex_lock(&client_mutex);
    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == sock) {
            clients[i] = clients[num_clients - 1];
            num_clients--;
        }
    }
    pthread_mutex_unlock(&client_mutex);
    printf(""Client %d disconnected\n"", sock);
    close(sock);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""Error creating socket"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""Error binding to port"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        perror(""Error listening for connections"");
        exit(EXIT_FAILURE);
    }

    printf(""Chat server started, waiting for connections on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket < 0) {
            perror(""Error accepting client connection"");
            continue;
        }
        pthread_mutex_lock(&client_mutex);
        clients[num_clients] = client_socket;
        num_clients++;
        pthread_mutex_unlock(&client_mutex);
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, &client_socket) != 0) {
            perror(""Error creating thread for client"");
            break;
        }
        pthread_detach(thread);
    }

    close(server_socket);
    return 0;
}",96,7.0
VULNERABLE,falcon180b-56872.c,yes,17,5,handle_client,"
  file falcon180b-56872.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server is waiting for clients...\n"");

    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);
        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    while (1) {
        usleep(1000);
    }

    return 0;
}",63,3.0
VULNERABLE,falcon180b-40084.c,yes,18,5,handle_client,"
  file falcon180b-40084.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_port = 8080;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", server_port);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",68,3.0
VULNERABLE,falcon180b-57234.c,yes,20,5,handle_client,"
  file falcon180b-57234.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int client_count = 0;
char buffer[BUFFER_SIZE];

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket_copy);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;
char buffer[BUFFER_SIZE];

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket_copy);
            return NULL;
        }
        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);
        for (int i = 0; i < client_count; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (client_count >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        clients[client_count] = client_socket;
        client_count++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",77,6.0
VULNERABLE,gemini_pro-37257.c,yes,47,5,thread_func,"
  file gemini_pro-37257.c line 47 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"pthread_t thread_pool[MAX_CLIENTS];

// Define the thread function
void* thread_func(void* arg) {
    // Get the client socket
    int client_sock = *(int*)arg;

    // Get the client address
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    getpeername(client_sock, (struct sockaddr*)&client_addr, &client_addr_len);","//GEMINI-pro DATASET v1.0 Category: Chat server ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <pthread.h>
#include <time.h>

// Define the maximum number of clients
#define MAX_CLIENTS 100

// Define the maximum message length
#define MAX_MSG_LEN 1024

// Define the port number
#define PORT 8080

// Define the server address
#define SERVER_ADDR ""127.0.0.1""

// Define the server socket
int server_sock;

// Define the client sockets
int client_socks[MAX_CLIENTS];

// Define the number of clients
int num_clients = 0;

// Define the mutex
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Define the condition variable
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Define the thread pool
pthread_t thread_pool[MAX_CLIENTS];

// Define the thread function
void* thread_func(void* arg) {
    // Get the client socket
    int client_sock = *(int*)arg;

    // Get the client address
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    getpeername(client_sock, (struct sockaddr*)&client_addr, &client_addr_len);

    // Print the client address
    printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

    // Loop until the client disconnects
    while (1) {
        // Receive a message from the client
        char msg[MAX_MSG_LEN];
        int msg_len = recv(client_sock, msg, MAX_MSG_LEN, 0);

        // If the client disconnected, break the loop
        if (msg_len <= 0) {
            break;
        }

        // Print the message
        printf(""Client: %s\n"", msg);

        // Send a message to the client
        char reply[MAX_MSG_LEN];
        sprintf(reply, ""Server: %s"", msg);
        send(client_sock, reply, strlen(reply), 0);
    }

    // Close the client socket
    close(client_sock);

    // Decrement the number of clients
    pthread_mutex_lock(&mutex);
    num_clients--;
    pthread_mutex_unlock(&mutex);

    // Signal the condition variable
    pthread_cond_signal(&cond);

    // Return NULL
    return NULL;
}

// Define the main function
int main() {
    // Create the server socket
    server_sock = socket(AF_INET, SOCK_STREAM, 0);

    // Set the server address
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_ADDR);

    // Bind the server socket to the server address
    bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));

    // Listen for incoming connections
    listen(server_sock, MAX_CLIENTS);

    // Loop until the server is stopped
    while (1) {
        // Accept an incoming connection
        int client_sock = accept(server_sock, (struct sockaddr*)NULL, NULL);

        // If the server is full, close the client socket
        if (num_clients >= MAX_CLIENTS) {
            close(client_sock);
            continue;
        }

        // Add the client socket to the list of client sockets
        client_socks[num_clients] = client_sock;

        // Increment the number of clients
        pthread_mutex_lock(&mutex);
        num_clients++;
        pthread_mutex_unlock(&mutex);

        // Create a thread to handle the client
        pthread_create(&thread_pool[num_clients], NULL, thread_func, &client_sock);
    }

    // Close the server socket
    close(server_sock);

    // Return 0
    return 0;
}",137,3.0
VULNERABLE,falcon180b-56391.c,yes,18,5,handle_client,"
  file falcon180b-56391.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int listening_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int listening_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(listening_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
        } else {
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            client_sockets[num_clients++] = client_socket;
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(listening_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(listening_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
        } else {
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            client_sockets[num_clients++] = client_socket;
        }
    }

    accept_connections();

    return 0;
}",64,3.0
VULNERABLE,gemini_pro-28035.c,yes,29,5,traffic_light,"
  file gemini_pro-28035.c line 29 column 5 function traffic_light
","
  c:@F@traffic_light at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Create a thread for each traffic light
pthread_t threads[NUM_LIGHTS];

// Function to simulate a traffic light
void *traffic_light(void *arg) {
    int light_num = *(int *)arg;

    while (1) {
        // Lock the mutex
        pthread_mutex_lock(&mutex);
","//GEMINI-pro DATASET v1.0 Category: Traffic Light Controller ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

// Define the traffic light states
#define RED 0
#define YELLOW 1
#define GREEN 2

// Define the number of traffic lights
#define NUM_LIGHTS 3

// Create a mutex to protect the shared data
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Create a condition variable to signal when the traffic light has changed
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Create an array to store the current state of each traffic light
int light_states[NUM_LIGHTS];

// Create a thread for each traffic light
pthread_t threads[NUM_LIGHTS];

// Function to simulate a traffic light
void *traffic_light(void *arg) {
    int light_num = *(int *)arg;

    while (1) {
        // Lock the mutex
        pthread_mutex_lock(&mutex);

        // Wait until the traffic light is green
        while (light_states[light_num] != GREEN) {
            pthread_cond_wait(&cond, &mutex);
        }

        // Unlock the mutex
        pthread_mutex_unlock(&mutex);

        // Display the green light
        printf(""Traffic light %d is green\n"", light_num);

        // Sleep for 5 seconds
        sleep(5);

        // Lock the mutex
        pthread_mutex_lock(&mutex);

        // Change the traffic light to yellow
        light_states[light_num] = YELLOW;

        // Signal that the traffic light has changed
        pthread_cond_signal(&cond);

        // Unlock the mutex
        pthread_mutex_unlock(&mutex);

        // Display the yellow light
        printf(""Traffic light %d is yellow\n"", light_num);

        // Sleep for 1 second
        sleep(1);

        // Lock the mutex
        pthread_mutex_lock(&mutex);

        // Change the traffic light to red
        light_states[light_num] = RED;

        // Signal that the traffic light has changed
        pthread_cond_signal(&cond);

        // Unlock the mutex
        pthread_mutex_unlock(&mutex);

        // Display the red light
        printf(""Traffic light %d is red\n"", light_num);

        // Sleep for 5 seconds
        sleep(5);
    }

    return NULL;
}

int main() {
    // Initialize the traffic light states
    for (int i = 0; i < NUM_LIGHTS; i++) {
        light_states[i] = RED;
    }

    // Create the traffic light threads
    for (int i = 0; i < NUM_LIGHTS; i++) {
        pthread_create(&threads[i], NULL, traffic_light, (void *)&i);
    }

    // Join the traffic light threads
    for (int i = 0; i < NUM_LIGHTS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",106,3.5
VULNERABLE,falcon180b-40415.c,yes,18,5,handle_client,"
  file falcon180b-40415.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();

    return 0;
}",88,3.667
VULNERABLE,falcon180b-54234.c,yes,24,5,thread_func,"
  file falcon180b-54234.c line 24 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;
int main_socket;
struct sockaddr_in server_addr;

void *thread_func(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define BACKLOG 5

int clients[MAX_CLIENTS];
int num_clients = 0;
int main_socket;
struct sockaddr_in server_addr;

void *thread_func(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            return NULL;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(main_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(12345);

    bind(main_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(main_socket, BACKLOG);

    int thread_id;
    pthread_t thread[MAX_CLIENTS];

    while (1) {
        socklen_t addr_size = sizeof(struct sockaddr_in);
        int client_socket = accept(main_socket, (struct sockaddr *) &server_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_create(&thread[num_clients - 1], NULL, thread_func, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-48421.c,yes,21,5,handle_client,"
  file falcon180b-48421.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *param) {
    int client_socket = *(int *)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <unistd.h>
#include <pthread.h>
#include <time.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *param) {
    int client_socket = *(int *)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;
    int addrlen = sizeof(client_addr);
    char *ip = ""127.0.0.1"";
    int port = 8080;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(ip);
    server_addr.sin_port = htons(port);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server started on IP: %s, Port: %d\n"", ip, port);

    while (1) {
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addrlen);

        if (client_socket < 0) {
            perror(""accept"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",91,5.0
VULNERABLE,falcon180b-240.c,yes,17,5,handle_client,"
  file falcon180b-240.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket_copy, buffer);
    }

    close(client_socket_copy);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",89,6.0
VULNERABLE,falcon180b-57744.c,yes,20,5,handle_client,"
  file falcon180b-57744.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;
int server_socket;
int opt = 1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;
int opt = 1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int optval = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

        clients[num_clients++] = client_socket;
    }

    return 0;
}",65,4.0
VULNERABLE,gemini_pro-6652.c,yes,16,5,handle_client,"
  file gemini_pro-6652.c line 16 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
#define MAX_CONNECTIONS 10

// Function to handle client connections
void *handle_client(void *arg) {
    int client_socket = *((int *)arg);

    // Receive data from client
    char buffer[1024];
    int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
    if (bytes_received < 0) {","//GEMINI-pro DATASET v1.0 Category: TCP/IP Programming ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CONNECTIONS 10

// Function to handle client connections
void *handle_client(void *arg) {
    int client_socket = *((int *)arg);

    // Receive data from client
    char buffer[1024];
    int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
    if (bytes_received < 0) {
        perror(""recv"");
        close(client_socket);
        return NULL;
    }

    // Process received data
    // ...

    // Send data back to client
    char *response = ""Hello from server!"";
    int bytes_sent = send(client_socket, response, strlen(response), 0);
    if (bytes_sent < 0) {
        perror(""send"");
        close(client_socket);
        return NULL;
    }

    // Close client socket
    close(client_socket);

    return NULL;
}

int main() {
    // Create a server socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        perror(""socket"");
        return EXIT_FAILURE;
    }

    // Set socket options
    int optval = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

    // Bind socket to address and port
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(5000);
    server_address.sin_addr.s_addr = INADDR_ANY;
    int bind_result = bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address));
    if (bind_result < 0) {
        perror(""bind"");
        close(server_socket);
        return EXIT_FAILURE;
    }

    // Listen for connections
    int listen_result = listen(server_socket, MAX_CONNECTIONS);
    if (listen_result < 0) {
        perror(""listen"");
        close(server_socket);
        return EXIT_FAILURE;
    }

    // Accept connections in a loop
    while (1) {
        // Create a client socket
        struct sockaddr_in client_address;
        socklen_t client_address_len = sizeof(client_address);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_len);
        if (client_socket < 0) {
            perror(""accept"");
            continue;
        }

        // Create a new thread to handle the client connection
        pthread_t client_thread;
        int create_thread_result = pthread_create(&client_thread, NULL, handle_client, (void *)&client_socket);
        if (create_thread_result != 0) {
            perror(""pthread_create"");
            close(client_socket);
            continue;
        }

        // Detach the client thread
        if (pthread_detach(client_thread) != 0) {
            perror(""pthread_detach"");
        }
    }

    // Close server socket
    close(server_socket);

    return EXIT_SUCCESS;
}",108,5.5
VULNERABLE,gemini_pro-28641.c,yes,16,5,client_thread_func,"
  file gemini_pro-28641.c line 16 column 5 function client_thread_func
","
  c:@F@client_thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `sockfd'",dereference failure: accessed expired variable pointer,"#include <signal.h>
#include <pthread.h>

// Client
void *client_thread_func(void *arg) {
    int sockfd = *((int *) arg);
    char buf[1024];
    while (1) {
        printf(""Enter message: "");
        fgets(buf, sizeof(buf), stdin);
        send(sockfd, buf, strlen(buf), 0);","//GEMINI-pro DATASET v1.0 Category: Client Server Application ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>

// Client
void *client_thread_func(void *arg) {
    int sockfd = *((int *) arg);
    char buf[1024];
    while (1) {
        printf(""Enter message: "");
        fgets(buf, sizeof(buf), stdin);
        send(sockfd, buf, strlen(buf), 0);
    }
    return NULL;
}

// Server
void handle_client(int sockfd) {
    char buf[1024];
    while (1) {
        int n = recv(sockfd, buf, sizeof(buf), 0);
        if (n == 0) {
            close(sockfd);
            return;
        } else if (n < 0) {
            if (errno == EINTR) {
                continue;
            }
            perror(""Error receiving data"");
            close(sockfd);
            return;
        }
        printf(""Received message: %s"", buf);
    }
}

int main(int argc, char **argv) {
    if (argc != 3) {
        printf(""Usage: %s <server IP address> <port>\n"", argv[0]);
        return 1;
    }
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror(""Error creating socket"");
        return 1;
    }
    struct sockaddr_in servaddr;
    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(atoi(argv[2]));
    if (inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0) {
        perror(""Error converting IP address"");
        close(sockfd);
        return 1;
    }
    if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0) {
        perror(""Error connecting to server"");
        close(sockfd);
        return 1;
    }
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, client_thread_func, &sockfd);
    if (ret != 0) {
        perror(""Error creating client thread"");
        close(sockfd);
        return 1;
    }
    handle_client(sockfd);
    close(sockfd);
    return 0;
}",80,4.333
VULNERABLE,falcon180b-35364.c,yes,17,5,handle_client,"
  file falcon180b-35364.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 3) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = 0;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);

    return 0;
}",89,5.0
VULNERABLE,falcon180b-18286.c,yes,22,5,handle_client,"
  file falcon180b-18286.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUF_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            return NULL;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    puts(""Server started on port 8080"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-18483.c,yes,21,5,handle_client,"
  file falcon180b-18483.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
pthread_t threads[MAX_CLIENTS];
int thread_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
pthread_t threads[MAX_CLIENTS];
int thread_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (thread_count >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[thread_count] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        thread_count++;
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (thread_count >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[thread_count] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        thread_count++;
    }

    return 0;
}",86,3.667
VULNERABLE,gpt35-59206.c,yes,14,3,client_handler,"
  file gpt35-59206.c line 14 column 3 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"#include <pthread.h>

#define PORT 8080

void *client_handler(void *socket_desc) {
  int sock = *(int*)socket_desc;
  char buffer[1024] = {0};

  // Receive message from client
  int valread = read(sock, buffer, 1024);
  if(valread > 0) {","//FormAI DATASET v1.0 Category: Networking ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080

void *client_handler(void *socket_desc) {
  int sock = *(int*)socket_desc;
  char buffer[1024] = {0};

  // Receive message from client
  int valread = read(sock, buffer, 1024);
  if(valread > 0) {
    printf(""Client message: %s"", buffer);
  }
  else {
    printf(""Receive failed.\n"");
  }

  // Send message to client
  char *message = ""Server received message.\n"";
  send(sock, message, strlen(message), 0);

  close(sock);
}

int main(int argc, char const *argv[]) {
  int server_fd, new_socket, opt = 1;
  struct sockaddr_in address;
  int addrlen = sizeof(address);

  // Creating socket
  server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if(server_fd == 0) {
    perror(""Failed to create socket.\n"");
    exit(EXIT_FAILURE);
  }

  // Set socket options
  if(setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
    perror(""Failed to set socket options.\n"");
    exit(EXIT_FAILURE);
  }

  // Set address information
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(PORT);

  // Bind socket to address
  if(bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
    perror(""Failed to bind socket to address.\n"");
    exit(EXIT_FAILURE);
  }

  // Listen for connections
  if(listen(server_fd, 3) < 0) {
    perror(""Failed to listen for connections.\n"");
    exit(EXIT_FAILURE);
  }

  printf(""Listening...\n"");

  // Accept connections and handle in separate threads
  while((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))) {
    pthread_t thread_id;
    if(pthread_create(&thread_id, NULL, client_handler, (void*)&new_socket) < 0) {
      perror(""Failed to create thread.\n"");
      exit(EXIT_FAILURE);
    }

    printf(""Connection of Client %s:%d accepted.\n"", inet_ntoa(address.sin_addr), ntohs(address.sin_port));
  }

  if(new_socket < 0) {
    perror(""Failed to accept connection.\n"");
    exit(EXIT_FAILURE);
  }

  return 0;
}",87,5.0
VULNERABLE,falcon180b-51.c,yes,19,5,handle_client,"
  file falcon180b-51.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    for (int i = 0; i < num_clients; i++) {
        if (client_sockets[i] == client_socket) {
            client_sockets[i] = -1;
        }
    }

    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 3);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 50, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",82,5.0
VULNERABLE,gemini_pro-19533.c,yes,29,5,cast_vote,"
  file gemini_pro-19533.c line 29 column 5 function cast_vote
","
  c:@F@cast_vote at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"pthread_mutex_t candidates_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to cast a vote for a candidate
void *cast_vote(void *arg) {
    // Get the candidate ID from the argument
    int candidate_id = *(int *)arg;

    // Lock the candidates array
    pthread_mutex_lock(&candidates_mutex);

    // Increment the vote count for the candidate","//GEMINI-pro DATASET v1.0 Category: Electronic Voting System ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_CANDIDATES 5

// Structure to represent a candidate
typedef struct {
    char *name;
    int votes;
} candidate_t;

// Array of candidates
candidate_t candidates[NUM_CANDIDATES] = {
    {""Alice"", 0},
    {""Bob"", 0},
    {""Carol"", 0},
    {""Dave"", 0},
    {""Eve"", 0}
};

// Mutex to protect the candidates array
pthread_mutex_t candidates_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to cast a vote for a candidate
void *cast_vote(void *arg) {
    // Get the candidate ID from the argument
    int candidate_id = *(int *)arg;

    // Lock the candidates array
    pthread_mutex_lock(&candidates_mutex);

    // Increment the vote count for the candidate
    candidates[candidate_id].votes++;

    // Unlock the candidates array
    pthread_mutex_unlock(&candidates_mutex);

    return NULL;
}

int main() {
    // Create an array of thread IDs
    pthread_t thread_ids[NUM_CANDIDATES];

    // Create a thread for each candidate
    for (int i = 0; i < NUM_CANDIDATES; i++) {
        pthread_create(&thread_ids[i], NULL, cast_vote, &i);
    }

    // Join all the threads
    for (int i = 0; i < NUM_CANDIDATES; i++) {
        pthread_join(thread_ids[i], NULL);
    }

    // Print the results of the election
    printf(""Election results:\n"");
    for (int i = 0; i < NUM_CANDIDATES; i++) {
        printf(""%s: %d votes\n"", candidates[i].name, candidates[i].votes);
    }

    return 0;
}",64,2.5
VULNERABLE,falcon180b-2543.c,yes,18,5,handle_client,"
  file falcon180b-2543.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        if (strncmp(buffer, ""on"", 3) == 0) {
            system(""echo 1 > /sys/class/leds/light/brightness"");
        } else if (strncmp(buffer, ""off"", 4) == 0) {
            system(""echo 0 > /sys/class/leds/light/brightness"");
        } else if (strncmp(buffer, ""dim"", 4) == 0) {
            system(""echo 50 > /sys/class/leds/light/brightness"");
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",72,4.5
VULNERABLE,falcon180b-9602.c,yes,19,5,handle_client,"
  file falcon180b-9602.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: Alan Turing
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 37, 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",61,3.0
VULNERABLE,falcon180b-30149.c,yes,18,5,handle_client,"
  file falcon180b-30149.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more clients.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,3.5
VULNERABLE,falcon180b-19843.c,yes,19,5,handle_client,"
  file falcon180b-19843.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_server_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define PORT 8080

int g_server_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        // Send message to all clients
        for (int i = 0; i < g_num_clients; i++) {
            if (g_client_sockets[i]!= client_socket) {
                send(g_client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (g_num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        g_client_sockets[g_num_clients] = client_socket;
        g_num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-24689.c,yes,17,5,handle_client,"
  file falcon180b-24689.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_COMMAND_LENGTH];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, MAX_COMMAND_LENGTH, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_COMMAND_LENGTH 100

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_COMMAND_LENGTH];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, MAX_COMMAND_LENGTH, 0);

        if (bytes_received <= 0) {
            break;
        }

        char *command = strtok(buffer, "" "");
        if (command == NULL) {
            continue;
        }

        if (strcmp(command, ""ON"") == 0) {
            system(""echo 1 > /sys/class/leds/led0/brightness"");
        } else if (strcmp(command, ""OFF"") == 0) {
            system(""echo 0 > /sys/class/leds/led0/brightness"");
        } else if (strcmp(command, ""DIM"") == 0) {
            system(""echo 50 > /sys/class/leds/led0/brightness"");
        } else if (strcmp(command, ""QUIT"") == 0) {
            close(client_socket);
            break;
        }
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Smart Home Server is Running!\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",76,5.5
VULNERABLE,falcon180b-47537.c,yes,22,5,handle_client,"
  file falcon180b-47537.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>
#include <pthread.h>

#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);

    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            break;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port %d\n"", PORT);

    accept_connections();

    return 0;
}",90,3.333
VULNERABLE,falcon180b-43039.c,yes,19,5,handle_client,"
  file falcon180b-43039.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Simple Web Server ; Style: decentralized
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    printf(""Client %d disconnected\n"", client_socket);
}

void accept_clients() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        clients[num_clients++] = client_socket;
    }
}

int main() {
    accept_clients();
    return 0;
}",63,3.0
VULNERABLE,falcon180b-37635.c,yes,24,5,thread_func,"
  file falcon180b-37635.c line 24 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"
    // Signal the main thread that a new thread has started
    pthread_cond_signal(&cond);

    // Do some work...
    int id = *((int *) arg);
    printf(""Thread %d started.\n"", id);
    sleep(1);
    printf(""Thread %d finished.\n"", id);

    // Unlock the mutex","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex for protecting shared data
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for signaling threads
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Flag for indicating whether all threads have finished
int finished = 0;

// Function called by each thread
void *thread_func(void *arg) {
    // Lock the mutex to protect shared data
    pthread_mutex_lock(&mutex);

    // Signal the main thread that a new thread has started
    pthread_cond_signal(&cond);

    // Do some work...
    int id = *((int *) arg);
    printf(""Thread %d started.\n"", id);
    sleep(1);
    printf(""Thread %d finished.\n"", id);

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    // Signal the main thread that a thread has finished
    pthread_cond_signal(&cond);

    return NULL;
}

int main() {
    // Create an array of thread IDs
    pthread_t threads[5];

    // Create 5 threads
    for (int i = 0; i < 5; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void *) &i);
    }

    // Lock the mutex to protect shared data
    pthread_mutex_lock(&mutex);

    // Wait for all threads to finish
    while (finished == 0) {
        // Signal the main thread when a thread has started
        pthread_cond_wait(&cond, &mutex);
    }

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    return 0;
}",60,2.0
VULNERABLE,gemini_pro-4506.c,yes,58,13,print_matrix,"
  file gemini_pro-4506.c line 58 column 13 function print_matrix
","
  c:@F@print_matrix at file gemini_pro-4506.c line 83 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `c'",dereference failure: accessed expired variable pointer,"
// Define the function to print the matrix
void print_matrix(int a[3][3]) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf(""%d "", a[i][j]);
        }
        printf(""\n"");
    }
}
","//GEMINI-pro DATASET v1.0 Category: Matrix operations ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>

// Define the Romeo and Juliet matrices
int romeo[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

int juliet[3][3] = {
    {10, 11, 12},
    {13, 14, 15},
    {16, 17, 18}
};

// Define the function to add the two matrices
int add_matrices(int a[3][3], int b[3][3]) {
    int c[3][3];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            c[i][j] = a[i][j] + b[i][j];
        }
    }
    return c;
}

// Define the function to subtract the two matrices
int subtract_matrices(int a[3][3], int b[3][3]) {
    int c[3][3];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            c[i][j] = a[i][j] - b[i][j];
        }
    }
    return c;
}

// Define the function to multiply the two matrices
int multiply_matrices(int a[3][3], int b[3][3]) {
    int c[3][3];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            c[i][j] = 0;
            for (int k = 0; k < 3; k++) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return c;
}

// Define the function to print the matrix
void print_matrix(int a[3][3]) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf(""%d "", a[i][j]);
        }
        printf(""\n"");
    }
}

// Main function
int main() {
    // Add the two matrices
    int sum = add_matrices(romeo, juliet);

    // Subtract the two matrices
    int difference = subtract_matrices(romeo, juliet);

    // Multiply the two matrices
    int product = multiply_matrices(romeo, juliet);

    // Print the results
    printf(""The sum of the two matrices is:\n"");
    print_matrix(sum);

    printf(""The difference of the two matrices is:\n"");
    print_matrix(difference);

    printf(""The product of the two matrices is:\n"");
    print_matrix(product);

    return 0;
}",86,2.8
VULNERABLE,gpt35-7225.c,yes,47,3,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file gpt35-7225.c line 47 column 3 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `newString'",dereference failure: accessed expired variable pointer,"  if (s[len - 1] == '\n') {
    s[len - 1] = '\0';
  }

  char newString[MAX_LEN];
  strcpy(newString, removeSpecialChar(s, len));

  if (isPalindrome(newString)) {
    printf(""%s is a palindrome\n"", s);
  } else {
    printf(""%s is not a palindrome\n"", s);","//FormAI DATASET v1.0 Category: Palindrome Checker ; Style: funny
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX_LEN 100

char removeSpecialChar(char s[], int len) {
  char newString[MAX_LEN];
  int j = 0;
  
  for (int i = 0; i < len; i++) {
    if (isalnum(s[i])) {
      newString[j] = tolower(s[i]);
      j++;
    }
  }
  
  newString[j] = '\0';
  return newString;
}

int isPalindrome(char s[]) {
  int len = strlen(s);
  
  for (int i = 0; i < len / 2; i++) {
    if (s[i] != s[len - i - 1]) {
      return 0;
    }
  }
  
  return 1;
}

int main() {
  char s[MAX_LEN];
  
  printf(""Enter a string: "");
  fgets(s, MAX_LEN, stdin);
  
  int len = strlen(s);
  if (s[len - 1] == '\n') {
    s[len - 1] = '\0';
  }
  
  char newString[MAX_LEN];
  strcpy(newString, removeSpecialChar(s, len));
  
  if (isPalindrome(newString)) {
    printf(""%s is a palindrome\n"", s);
  } else {
    printf(""%s is not a palindrome\n"", s);
  }
  
  return 0;
}",56,3.0
VULNERABLE,falcon180b-42863.c,yes,19,5,handle_client,"
  file falcon180b-42863.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",84,6.0
VULNERABLE,falcon180b-3027.c,yes,18,5,handle_client,"
  file falcon180b-3027.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(sock, buffer, bytes_received, 0);
    }

    close(sock);
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i][0]!= sender_socket) {
            send(clients[i][0], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 15, 0);
            close(client_socket);
        } else {
            clients[num_clients][0] = client_socket;
            clients[num_clients][1] = 0;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",74,3.0
VULNERABLE,falcon180b-51302.c,yes,20,5,handle_client,"
  file falcon180b-51302.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: imaginative
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);
    printf(""Server started on port 8080\n"");
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }
    close(server_socket);
    return 0;
}",56,3.0
VULNERABLE,falcon180b-57607.c,yes,18,5,handle_client,"
  file falcon180b-57607.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Building a SMTP Client ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 25
#define MAX_CLIENTS 5
#define BUFFER_SIZE 512

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections(server_socket);

    close(server_socket);
    return 0;
}",89,3.667
VULNERABLE,gpt35-76373.c,yes,18,5,clientHandler,"
  file gpt35-76373.c line 18 column 5 function clientHandler
","
  c:@F@clientHandler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientSocket'",dereference failure: accessed expired variable pointer,"int clientSockets[10];

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *clientHandler(void *arg) {
    int clientSocket = *(int *) arg;
    int bufferLength = 1024;
    char buffer[bufferLength];

    pthread_mutex_lock(&mutex);
    clientCount++;","//FormAI DATASET v1.0 Category: Networking ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

int clientCount = 0;
int clientSockets[10];

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *clientHandler(void *arg) {
    int clientSocket = *(int *) arg;
    int bufferLength = 1024;
    char buffer[bufferLength];
    
    pthread_mutex_lock(&mutex);
    clientCount++;
    pthread_mutex_unlock(&mutex);
    
    while (1) {
        bzero(buffer, bufferLength);
        int read = recv(clientSocket, buffer, bufferLength, 0);
        
        if (read == 0) {
            pthread_mutex_lock(&mutex);
            for (int i = 0; i < clientCount; i++) {
                if (clientSockets[i] == clientSocket) {
                    while (i < clientCount - 1) {
                        clientSockets[i] = clientSockets[i + 1];
                        i++;
                    }
                    break;
                }
            }
            clientCount--;
            pthread_mutex_unlock(&mutex);
            printf(""Client with socket %d disconnected\n"", clientSocket);
            break;
        }
        
        printf(""Received message from client %d: %s\n"", clientSocket, buffer);
        
        for (int i = 0; i < clientCount; i++) {
            if (clientSockets[i] != clientSocket) {
                send(clientSockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    
    close(clientSocket);
    pthread_exit(NULL);
}

int main() {
    int serverSocket;
    struct sockaddr_in serverAddress;
    pthread_t threadId;
    
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket == -1) {
        printf(""Failed to create socket\n"");
        exit(EXIT_FAILURE);
    }
    
    memset(&serverAddress, 0, sizeof(serverAddress));
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = INADDR_ANY;
    serverAddress.sin_port = htons(PORT);
    
    if (bind(serverSocket, (struct sockaddr *) &serverAddress, sizeof(serverAddress)) == -1) {
        printf(""Failed to bind socket\n"");
        exit(EXIT_FAILURE);
    }
    
    if (listen(serverSocket, 10) == -1) {
        printf(""Failed to listen on socket\n"");
        exit(EXIT_FAILURE);
    }
    
    printf(""Server listening on port %d\n"", PORT);
    
    while (1) {
        struct sockaddr_in clientAddress;
        int clientSocket, clientAddressLength = sizeof(clientAddress);
        
        clientSocket = accept(serverSocket, (struct sockaddr *) &clientAddress, (socklen_t *) &clientAddressLength);
        if (clientSocket == -1) {
            printf(""Failed to accept client connection\n"");
            continue;
        }
        
        if (clientCount == 10) {
            printf(""Max clients reached, no more connections allowed\n"");
            close(clientSocket);
            continue;
        }
        
        pthread_mutex_lock(&mutex);
        clientSockets[clientCount] = clientSocket;
        pthread_mutex_unlock(&mutex);
        
        printf(""Client with socket %d connected\n"", clientSocket);
        
        if (pthread_create(&threadId, NULL, &clientHandler, &clientSocket) != 0) {
            printf(""Failed to create client thread\n"");
            continue;
        }
    }
    
    close(serverSocket);
    pthread_exit(NULL);
}",118,8.0
VULNERABLE,gemini_pro-2424.c,yes,42,26,handle_connection,"
  file gemini_pro-2424.c line 42 column 26 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `conn'",dereference failure: accessed expired variable pointer,"    connection *conn = (connection *)arg;

    char buffer[MAX_BUFFER_SIZE];

    while (1) {
        int bytes_read = recv(conn->fd, buffer, MAX_BUFFER_SIZE, 0);

        if (bytes_read <= 0) {
            break;
        }
","//GEMINI-pro DATASET v1.0 Category: Intrusion detection system ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CONNECTIONS 100
#define MAX_BUFFER_SIZE 1024
#define MAX_RULES 100

typedef struct {
    char *pattern;
    int pattern_length;
    int threshold;
} rule;

typedef struct {
    int fd;
    struct sockaddr_in addr;
    int rule_index;
    int matches;
} connection;

rule rules[MAX_RULES];
int num_rules;
connection connections[MAX_CONNECTIONS];
int num_connections;

void *handle_connection(void *arg) {
    connection *conn = (connection *)arg;

    char buffer[MAX_BUFFER_SIZE];

    while (1) {
        int bytes_read = recv(conn->fd, buffer, MAX_BUFFER_SIZE, 0);

        if (bytes_read <= 0) {
            break;
        }

        for (int i = 0; i < num_rules; i++) {
            if (strstr(buffer, rules[i].pattern) != NULL) {
                conn->matches++;

                if (conn->matches >= rules[i].threshold) {
                    printf(""Intrusion detected from %s:%d!\n"", inet_ntoa(conn->addr.sin_addr), ntohs(conn->addr.sin_port));
                    close(conn->fd);
                    pthread_exit(NULL);
                }
            }
        }
    }

    pthread_exit(NULL);
}

int main() {
    int listenfd;
    struct sockaddr_in servaddr;

    listenfd = socket(AF_INET, SOCK_STREAM, 0);

    if (listenfd < 0) {
        perror(""socket"");
        exit(1);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(1337);

    if (bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
        perror(""bind"");
        exit(1);
    }

    if (listen(listenfd, MAX_CONNECTIONS) < 0) {
        perror(""listen"");
        exit(1);
    }

    while (1) {
        struct sockaddr_in cliaddr;
        socklen_t clilen = sizeof(cliaddr);

        int connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &clilen);

        if (connfd < 0) {
            perror(""accept"");
            continue;
        }

        if (num_connections >= MAX_CONNECTIONS) {
            printf(""Maximum number of connections reached!\n"");
            close(connfd);
            continue;
        }

        connection conn = {connfd, cliaddr, -1, 0};
        connections[num_connections++] = conn;

        pthread_t thread;
        pthread_create(&thread, NULL, handle_connection, (void *)&conn);
    }

    return 0;
}",115,6.5
VULNERABLE,falcon180b-49818.c,yes,21,5,handle_client,"
  file falcon180b-49818.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d said: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-2680.c,yes,44,5,handle_client,"
  file falcon180b-2680.c line 44 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
    return sockfd;
}

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_LINE];

    while (1) {
        memset(buffer, 0, MAX_LINE);
        int bytes_received = recv(client_socket, buffer, MAX_LINE, 0);","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>

#define MAX_LINE 4096
#define PORT 8080

void error(const char *msg) {
    perror(msg);
    exit(1);
}

int create_socket(int port) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        error(""socket failed"");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(port);

    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        error(""bind failed"");
    }

    if (listen(sockfd, 5) < 0) {
        error(""listen failed"");
    }

    return sockfd;
}

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_LINE];

    while (1) {
        memset(buffer, 0, MAX_LINE);
        int bytes_received = recv(client_socket, buffer, MAX_LINE, 0);
        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = create_socket(PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",71,2.5
VULNERABLE,falcon180b-61168.c,yes,19,5,handle_client,"
  file falcon180b-61168.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    while (1) {","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    while (1) {
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char *request = strtok(buffer, "" "");
        if (request == NULL) {
            continue;
        }

        if (strcmp(request, ""GET"") == 0) {
            char *uri = strtok(NULL, "" "");
            if (uri == NULL) {
                continue;
            }

            if (strstr(uri, ""admin"")!= NULL || strstr(uri, ""login"")!= NULL) {
                printf(""Possible intrusion detected on client %d\n"", client_socket);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",79,5.5
VULNERABLE,falcon180b-41616.c,yes,20,5,handle_client,"
  file falcon180b-41616.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        pthread_mutex_lock(&lock);
        for(int i = 0; i < num_clients; i++) {
            if(client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
        pthread_mutex_unlock(&lock);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_len);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full."", strlen(""Server is full.""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",67,4.0
VULNERABLE,falcon180b-67152.c,yes,20,5,handle_client,"
  file falcon180b-67152.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char message[MAX_MESSAGE_LENGTH];

    while (1) {
        memset(message, 0, MAX_MESSAGE_LENGTH);
        int bytes_received = recv(client_socket, message, MAX_MESSAGE_LENGTH, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MESSAGE_LENGTH 100

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char message[MAX_MESSAGE_LENGTH];

    while (1) {
        memset(message, 0, MAX_MESSAGE_LENGTH);
        int bytes_received = recv(client_socket, message, MAX_MESSAGE_LENGTH, 0);

        if (bytes_received <= 0) {
            printf(""Client %d disconnected.\n"", client_socket);
            close(client_socket);
            return NULL;
        }

        printf(""Client %d: %s"", client_socket, message);
        send(client_socket, message, strlen(message), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is running on port 8080.\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        int i;

        for (i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                pthread_t thread_id;
                pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
                break;
            }
        }
    }

    return 0;
}",68,3.5
VULNERABLE,falcon180b-4385.c,yes,19,5,handle_client,"
  file falcon180b-4385.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_len);

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",78,4.0
VULNERABLE,falcon180b-13261.c,yes,44,5,client_thread,"
  file falcon180b-13261.c line 44 column 5 function client_thread
","
  c:@F@client_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    close(sock);
    pthread_exit(NULL);
}

void *client_thread(void *arg) {
    int sock = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Expense Tracker ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

char *clients[MAX_CLIENTS];
int num_clients = 0;

void *listen_thread(void *arg) {
    int sock = *(int *)arg;
    char buffer[BUFFER_SIZE];
    int new_socket;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message: %s\n"", buffer);

        for (int i = 0; i < num_clients; i++) {
            send(clients[i], buffer, strlen(buffer), 0);
        }
    }

    close(sock);
    pthread_exit(NULL);
}

void *client_thread(void *arg) {
    int sock = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message: %s\n"", buffer);
    }

    close(sock);
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 46, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = (char *)malloc(sizeof(char) * 20);
        sprintf(clients[num_clients], ""Client %d"", num_clients + 1);

        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, client_thread, (void *)&client_socket);
    }

    return 0;
}",96,3.333
VULNERABLE,falcon180b-10577.c,yes,17,5,handle_client,"
  file falcon180b-10577.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Checksum Calculator ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);

    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == client_socket) {
            clients[i] = -1;
        }
    }

    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",78,5.0
VULNERABLE,falcon180b-4002.c,yes,37,5,handle_client,"
  file falcon180b-4002.c line 37 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;

    char buffer[BUFFER_SIZE];
    int bytes_received = 0;

    while ((bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0)) > 0) {","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/wait.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080
#define BACKLOG 10

struct client {
    int sock;
    int index;
};

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;

    char buffer[BUFFER_SIZE];
    int bytes_received = 0;

    while ((bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0)) > 0) {
        send(client_sock, buffer, bytes_received, 0);
    }

    close(client_sock);
    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_sock, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);

        int client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &client_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_sock, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_sock);
            continue;
        }

        client_sockets[num_clients] = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
    }

    return 0;
}",84,2.5
VULNERABLE,falcon180b-1274.c,yes,21,5,handle_client,"
  file falcon180b-1274.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients;
int client_socket_index;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;
int client_socket_index;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        num_clients++;
        client_sockets[num_clients - 1] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-10591.c,yes,29,5,ThreadFunction,"
  file falcon180b-10591.c line 29 column 5 function ThreadFunction
","
  c:@F@ThreadFunction at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"void *ThreadFunction(void *param)
{
    CURL *curl;
    CURLcode res;
    char url[1024];
    int id = *((int*)param);

    sprintf(url, ""imap://%s:%s@imap.gmail.com"", ""your_username"", ""your_password"");

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();","//Falcon-180B DATASET v1.0 Category: Building a IMAP Client ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <curl/curl.h>
#include <openssl/ssl.h>

static size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t realsize = size * nmemb;
    char *data = (char*)contents;
    fwrite(data, realsize, 1, stdout);
    return realsize;
}

static int ProgressCallback(void *clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow)
{
    int id = *((int*)clientp);
    printf(""Thread %d: Download progress: %ld of %ld bytes (%ld%%)\n"", id, dlnow, dltotal, (dlnow * 100) / dltotal);
    return 0;
}

void *ThreadFunction(void *param)
{
    CURL *curl;
    CURLcode res;
    char url[1024];
    int id = *((int*)param);

    sprintf(url, ""imap://%s:%s@imap.gmail.com"", ""your_username"", ""your_password"");

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);
        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, ProgressCallback);
        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &id);

        res = curl_easy_perform(curl);

        if(res!= CURLE_OK)
            fprintf(stderr, ""Thread %d: Download failed: %s\n"", id, curl_easy_strerror(res));

        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
    return 0;
}

int main()
{
    int num_threads = 4;
    pthread_t threads[num_threads];

    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, ThreadFunction, (void*)&i);
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",69,2.0
VULNERABLE,gemini_pro-32375.c,yes,49,94,isMovieAppropriate,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file gemini_pro-32375.c line 49 column 94 function isMovieAppropriate
  c:@F@isMovieAppropriate at file gemini_pro-32375.c line 75 column 23 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `rating'",dereference failure: accessed expired variable pointer,"  if (ageGroup == KIDS) {
    return strcmp(rating, G) == 0;
  } else if (ageGroup == TEENS) {
    return strcmp(rating, G) == 0 || strcmp(rating, PG) == 0 || strcmp(rating, PG13) == 0;
  } else {
    return strcmp(rating, G) == 0 || strcmp(rating, PG) == 0 || strcmp(rating, PG13) == 0 || strcmp(rating, R) == 0;
  }
}

// Print the movie rating system
void printMovieRatingSystem() {","//GEMINI-pro DATASET v1.0 Category: Movie Rating System ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the movie rating system
#define G ""G""
#define PG ""PG""
#define PG13 ""PG-13""
#define R ""R""
#define NC17 ""NC-17""

// Define the age groups
#define KIDS 0
#define TEENS 1
#define ADULTS 2

// Get the user's age group
int getAgeGroup() {
  int age;
  printf(""Enter your age: "");
  scanf(""%d"", &age);

  if (age < 13) {
    return KIDS;
  } else if (age < 18) {
    return TEENS;
  } else {
    return ADULTS;
  }
}

// Get the movie rating
char* getMovieRating() {
  char rating[4];
  printf(""Enter the movie rating: "");
  scanf(""%s"", rating);

  return rating;
}

// Check if the movie is appropriate for the user's age group
int isMovieAppropriate(int ageGroup, char* rating) {
  if (ageGroup == KIDS) {
    return strcmp(rating, G) == 0;
  } else if (ageGroup == TEENS) {
    return strcmp(rating, G) == 0 || strcmp(rating, PG) == 0 || strcmp(rating, PG13) == 0;
  } else {
    return strcmp(rating, G) == 0 || strcmp(rating, PG) == 0 || strcmp(rating, PG13) == 0 || strcmp(rating, R) == 0;
  }
}

// Print the movie rating system
void printMovieRatingSystem() {
  printf(""Movie Rating System:\n"");
  printf(""G: General audiences. No restrictions.\n"");
  printf(""PG: Parental guidance suggested. Some material may not be suitable for children.\n"");
  printf(""PG-13: Parents strongly cautioned. Some material may be inappropriate for children under 13.\n"");
  printf(""R: Restricted. Under 17 requires accompanying parent or adult guardian.\n"");
  printf(""NC-17: No one 17 and under admitted.\n"");
}

// Main function
int main() {
  // Print the movie rating system
  printMovieRatingSystem();

  // Get the user's age group
  int ageGroup = getAgeGroup();

  // Get the movie rating
  char* rating = getMovieRating();

  // Check if the movie is appropriate for the user's age group
  int isAppropriate = isMovieAppropriate(ageGroup, rating);

  // Print the result
  if (isAppropriate) {
    printf(""The movie is appropriate for your age group.\n"");
  } else {
    printf(""The movie is not appropriate for your age group.\n"");
  }

  return 0;
}",85,3.0
VULNERABLE,falcon180b-24511.c,yes,19,5,handle_client,"
  file falcon180b-24511.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    memset(request, 0, MAX_REQUEST_SIZE);
    recv(client_socket, request, MAX_REQUEST_SIZE, 0);
    printf(""Received request from client %d: %s\n"", client_socket, request);
    close(client_socket);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 100
#define MAX_REQUEST_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    memset(request, 0, MAX_REQUEST_SIZE);
    recv(client_socket, request, MAX_REQUEST_SIZE, 0);
    printf(""Received request from client %d: %s\n"", client_socket, request);
    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();
    return 0;
}",54,1.667
VULNERABLE,falcon180b-37671.c,yes,18,5,handle_client,"
  file falcon180b-37671.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");
    accept_connections();

    close(server_socket);
    return 0;
}",73,2.667
VULNERABLE,falcon180b-35947.c,yes,50,5,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-35947.c line 50 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"
    // Get user input
    printf(""Enter your name: "");
    strcpy(name, get_input(""""));
    printf(""Enter your address: "");
    strcpy(address, get_input(""""));

    // Check if input is valid
    if (is_valid_input(name) && is_valid_input(address)) {
        printf(""Name: %s\nAddress: %s\n"", name, address);
    } else {","//Falcon-180B DATASET v1.0 Category: User Input Sanitizer ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_INPUT 1000 // Maximum input length

// Function to sanitize user input
void sanitize_input(char* input) {
    int i = 0;
    while (i < strlen(input)) {
        // Check for invalid characters
        if (input[i] == '\0' || input[i] == '\n' || input[i] == '\r' || input[i] == '\\') {
            input[i] = '\0';
        }
        i++;
    }
}

// Function to check if input is valid
int is_valid_input(char* input) {
    int i = 0;
    while (i < strlen(input)) {
        // Check for invalid characters
        if (input[i] == '\0' || input[i] == '\n' || input[i] == '\r' || input[i] == '\\') {
            return 0;
        }
        i++;
    }
    return 1;
}

// Function to get user input
char* get_input(char* prompt) {
    char input[MAX_INPUT];
    printf(""%s"", prompt);
    fgets(input, MAX_INPUT, stdin);
    sanitize_input(input);
    return input;
}

int main() {
    char name[MAX_INPUT];
    char address[MAX_INPUT];

    // Get user input
    printf(""Enter your name: "");
    strcpy(name, get_input(""""));
    printf(""Enter your address: "");
    strcpy(address, get_input(""""));

    // Check if input is valid
    if (is_valid_input(name) && is_valid_input(address)) {
        printf(""Name: %s\nAddress: %s\n"", name, address);
    } else {
        printf(""Invalid input.\n"");
    }

    return 0;
}",60,4.0
VULNERABLE,falcon180b-65005.c,yes,18,5,handle_client,"
  file falcon180b-65005.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    num_clients--;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return -1;
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        return -1;
    }

    printf(""Server started on port 8080\n"");
    accept_connections();

    close(server_socket);
    return 0;
}",85,3.333
VULNERABLE,falcon180b-59489.c,yes,18,5,handle_client,"
  file falcon180b-59489.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        if (recv(client_socket, buffer, BUFFER_SIZE, 0) <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        if (recv(client_socket, buffer, BUFFER_SIZE, 0) <= 0) {
            close(client_socket);
            printf(""Client %d disconnected\n"", client_socket);
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (client_count >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Too many clients connected\n"");
            continue;
        }

        clients[client_count] = client_socket;
        client_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,3.5
VULNERABLE,falcon180b-21300.c,yes,19,5,handle_client,"
  file falcon180b-21300.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);

    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == client_socket) {
            clients[i] = 0;
            break;
        }
    }

    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 11, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",77,4.0
VULNERABLE,falcon180b-63966.c,yes,21,5,handle_client,"
  file falcon180b-63966.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char recv_msg[MAX_MSG_SIZE];
    int client_socket = *(int *)socket_desc;

    while (1) {
        memset(recv_msg, 0, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, recv_msg, MAX_MSG_SIZE, 0);
","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>
#include <time.h>

#define MAX_CLIENTS 50
#define MAX_MSG_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char recv_msg[MAX_MSG_SIZE];
    int client_socket = *(int *)socket_desc;

    while (1) {
        memset(recv_msg, 0, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, recv_msg, MAX_MSG_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        recv_msg[bytes_received] = '\0';
        printf(""Client %d sent message: %s\n"", client_socket, recv_msg);

        send(client_socket, recv_msg, strlen(recv_msg), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(3000);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port 3000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        num_clients++;

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more connections.\n"");
            continue;
        }

        client_sockets[num_clients - 1] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",76,3.5
VULNERABLE,falcon180b-30688.c,yes,19,5,handle_client,"
  file falcon180b-30688.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,3.5
VULNERABLE,falcon180b-2880.c,yes,18,5,thread_handler,"
  file falcon180b-2880.c line 18 column 5 function thread_handler
","
  c:@F@thread_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#define MAX_MESSAGE_SIZE 1024

int clients[MAX_CLIENTS];

void *thread_handler(void *arg) {
    int client_socket = *(int *) arg;
    char message[MAX_MESSAGE_SIZE];

    while (1) {
        memset(message, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, message, MAX_MESSAGE_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 100
#define MAX_MESSAGE_SIZE 1024

int clients[MAX_CLIENTS];

void *thread_handler(void *arg) {
    int client_socket = *(int *) arg;
    char message[MAX_MESSAGE_SIZE];

    while (1) {
        memset(message, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, message, MAX_MESSAGE_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        send(client_socket, message, bytes_received, 0);
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                pthread_t thread_id;
                pthread_create(&thread_id, NULL, thread_handler, (void *) &client_socket);
                break;
            }
        }
    }

    close(server_socket);
    return 0;
}",83,5.5
VULNERABLE,falcon180b-32167.c,yes,18,5,handle_client,"
  file falcon180b-32167.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8000);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,6.0
VULNERABLE,gemini_pro-6828.c,yes,98,3,handle_client,"
  file gemini_pro-6828.c line 98 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientfd'",dereference failure: accessed expired variable pointer,"  return clientfd;
}

// Handle a client connection
void *handle_client(void *arg) {
  int clientfd = *(int *)arg;

  // Receive the client's message
  char msg[MAX_MSG_LEN];
  int n = read(clientfd, msg, MAX_MSG_LEN);
  if (n == -1) {","//GEMINI-pro DATASET v1.0 Category: Email Client ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>

// Define the maximum number of clients
#define MAX_CLIENTS 10

// Define the maximum length of a message
#define MAX_MSG_LEN 1024

// Define the port number
#define PORT 8080

// Define the email server address
#define EMAIL_SERVER ""localhost""

// Define the email server port number
#define EMAIL_PORT 25

// Define the email sender address
#define EMAIL_SENDER ""sender@example.com""

// Define the email recipient address
#define EMAIL_RECIPIENT ""recipient@example.com""

// Define the email subject
#define EMAIL_SUBJECT ""Test email""

// Define the email body
#define EMAIL_BODY ""This is a test email.""

// Define the email message
#define EMAIL_MSG ""From: %s\nTo: %s\nSubject: %s\n\n%s\n""

// Create a socket
int create_socket() {
  int sockfd;
  struct sockaddr_in servaddr;

  // Create a socket
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    perror(""socket"");
    exit(EXIT_FAILURE);
  }

  // Set the socket options
  int optval = 1;
  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
    perror(""setsockopt"");
    exit(EXIT_FAILURE);
  }

  // Set the server address
  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port = htons(PORT);

  // Bind the socket to the server address
  if (bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1) {
    perror(""bind"");
    exit(EXIT_FAILURE);
  }

  // Listen for incoming connections
  if (listen(sockfd, MAX_CLIENTS) == -1) {
    perror(""listen"");
    exit(EXIT_FAILURE);
  }

  return sockfd;
}

// Accept a client connection
int accept_client(int sockfd) {
  struct sockaddr_in cliaddr;
  socklen_t addrlen = sizeof(cliaddr);

  // Accept a client connection
  int clientfd = accept(sockfd, (struct sockaddr *)&cliaddr, &addrlen);
  if (clientfd == -1) {
    perror(""accept"");
    exit(EXIT_FAILURE);
  }

  return clientfd;
}

// Handle a client connection
void *handle_client(void *arg) {
  int clientfd = *(int *)arg;

  // Receive the client's message
  char msg[MAX_MSG_LEN];
  int n = read(clientfd, msg, MAX_MSG_LEN);
  if (n == -1) {
    perror(""read"");
    exit(EXIT_FAILURE);
  }

  // Send a response to the client
  char resp[MAX_MSG_LEN];
  sprintf(resp, ""Received message: %s"", msg);
  n = write(clientfd, resp, strlen(resp));
  if (n == -1) {
    perror(""write"");
    exit(EXIT_FAILURE);
  }

  // Close the client connection
  close(clientfd);

  return NULL;
}

// Send an email
int send_email(char *subject, char *body) {
  int sockfd;
  struct sockaddr_in servaddr;

  // Create a socket
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    perror(""socket"");
    exit(EXIT_FAILURE);
  }

  // Set the server address
  bzero(&servaddr, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = inet_addr(EMAIL_SERVER);
  servaddr.sin_port = htons(EMAIL_PORT);

  // Connect to the server
  if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1) {
    perror(""connect"");
    exit(EXIT_FAILURE);
  }

  // Send the email message
  char msg[MAX_MSG_LEN];
  sprintf(msg, EMAIL_MSG, EMAIL_SENDER, EMAIL_RECIPIENT, subject, body);
  int n = write(sockfd, msg, strlen(msg));
  if (n == -1) {
    perror(""write"");
    exit(EXIT_FAILURE);
  }

  // Close the socket
  close(sockfd);

  return 0;
}

// Main function
int main() {
  // Create a socket
  int sockfd = create_socket();

  // Accept client connections and handle them in separate threads
  while (1) {
    int clientfd = accept_client(sockfd);

    pthread_t tid;
    pthread_create(&tid, NULL, handle_client, &clientfd);
  }

  // Send an email
  send_email(EMAIL_SUBJECT, EMAIL_BODY);

  return 0;
}",179,3.2
VULNERABLE,falcon180b-67969.c,yes,17,5,thread_func,"
  file falcon180b-67969.c line 17 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Number of threads
#define NUM_THREADS 5

// Function to be executed by each thread
void* thread_func(void* arg) {
    int id = *(int*) arg;
    printf(""Thread %d started\n"", id);

    // Lock the mutex
    pthread_mutex_lock(&mutex);
","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex for thread synchronization
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for thread synchronization
pthread_cond_t condition = PTHREAD_COND_INITIALIZER;

// Number of threads
#define NUM_THREADS 5

// Function to be executed by each thread
void* thread_func(void* arg) {
    int id = *(int*) arg;
    printf(""Thread %d started\n"", id);

    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Signal the main thread that a new thread has started
    pthread_cond_signal(&condition);

    // Wait for the main thread to signal that it's time to exit
    pthread_cond_wait(&condition, &mutex);

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    printf(""Thread %d exited\n"", id);
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];

    // Create threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void*) &i);
    }

    // Wait for threads to finish
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    printf(""Main thread exited\n"");
    return 0;
}",51,2.0
VULNERABLE,falcon180b-71040.c,yes,20,5,handle_client,"
  file falcon180b-71040.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            break;
        }
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        client_sockets[num_clients++] = client_socket;
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        printf(""Server listening on port %d\n"", PORT);
        accept_connections();
    }

    return 0;
}",62,3.333
VULNERABLE,gemini_pro-690.c,yes,29,9,execute,"
  file gemini_pro-690.c line 29 column 9 function execute
","
  c:@F@execute at file gemini_pro-690.c line 55 column 9 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `args'",dereference failure: accessed expired variable pointer,"}

void execute(char **args) {
    pid_t pid = fork();
    if (pid == 0) {
        execvp(args[0], args);
        exit(1);
    } else {
        wait(NULL);
    }
}","//GEMINI-pro DATASET v1.0 Category: Basic Unix-like Shell ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

char **parseArgs(const char *line) {
    char *args[10];
    char *arg;
    char tmp[strlen(line)+1];
    strcpy(tmp, line);

    arg = strtok(tmp, "" "");
    int i = 0;
    while (arg && i < 10) {
        args[i] = arg;
        i++;
        arg = strtok(NULL, "" "");
    }
    args[i] = NULL;

    return args;
}

void execute(char **args) {
    pid_t pid = fork();
    if (pid == 0) {
        execvp(args[0], args);
        exit(1);
    } else {
        wait(NULL);
    }
}

int main() {
    char line[100];

    while (1) {
        printf(""# "");
        fgets(line, sizeof(line), stdin);
        if (strlen(line) == 0) {
            continue;
        }
        if (strcmp(line, ""exit\n"") == 0) {
            break;
        }

        char **args = parseArgs(line);

        if (args == NULL) {
            continue;
        }

        execute(args);
    }

    return 0;
}",59,3.333
VULNERABLE,falcon180b-9941.c,yes,17,5,handle_client,"
  file falcon180b-9941.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        if (recv(client_socket, buffer, BUFFER_SIZE, 0) <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        if (recv(client_socket, buffer, BUFFER_SIZE, 0) <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        if (strncmp(buffer, ""on"", 3) == 0) {
            system(""echo 1 > /dev/ttyACM0"");
        } else if (strncmp(buffer, ""off"", 4) == 0) {
            system(""echo 0 > /dev/ttyACM0"");
        }
    }

    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(1234);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port 1234\n"");
    accept_connections(server_socket);

    return 0;
}",68,3.0
VULNERABLE,falcon180b-57063.c,yes,18,5,handle_client,"
  file falcon180b-57063.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        bzero(buffer, 1024);
        int bytes_received = recv(client_socket, buffer, 1024, 0);","//Falcon-180B DATASET v1.0 Category: Drone Remote Control ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        bzero(buffer, 1024);
        int bytes_received = recv(client_socket, buffer, 1024, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",67,4.0
VULNERABLE,codellama_13b-5131.c,yes,93,13,oct_to_hex,"
  file string.c line 78 column 3 function strlen
","
  c:@F@strlen at file codellama_13b-5131.c line 93 column 13 function oct_to_hex
  c:@F@oct_to_hex at file codellama_13b-5131.c line 134 column 16 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `oct'",dereference failure: accessed expired variable pointer,"
// Define a function to convert binary to hexadecimal
char* oct_to_hex(char* oct) {
  char hex[10];
  int i = 0;
  int len = strlen(oct);
  while (i < len) {
    int digit = oct[i] - '0';
    if (digit < 0 || digit > 7) {
      digit = (oct[i] - 'A' + 8) % 16;
    }","//Code Llama-13B DATASET v1.0 Category: Hexadecimal Converter ; Style: futuristic
// C Hexadecimal Converter
// Written in a futuristic style

#include <stdio.h>
#include <string.h>

// Define a function to convert hexadecimal to decimal
int hex_to_dec(char* hex) {
  int dec = 0;
  int i = 0;
  int len = strlen(hex);
  while (i < len) {
    int digit = hex[i] - '0';
    if (digit < 0 || digit > 9) {
      digit = (hex[i] - 'A' + 10) % 16;
    }
    dec = dec * 16 + digit;
    i++;
  }
  return dec;
}

// Define a function to convert decimal to hexadecimal
char* dec_to_hex(int dec) {
  char hex[10];
  int i = 0;
  while (dec > 0) {
    int digit = dec % 16;
    hex[i] = (digit < 10) ? '0' + digit : 'A' + digit - 10;
    i++;
    dec = dec / 16;
  }
  hex[i] = '\0';
  return hex;
}

// Define a function to convert hexadecimal to binary
char* hex_to_bin(char* hex) {
  char bin[10];
  int i = 0;
  int len = strlen(hex);
  while (i < len) {
    int digit = hex[i] - '0';
    if (digit < 0 || digit > 9) {
      digit = (hex[i] - 'A' + 10) % 16;
    }
    bin[i] = (digit < 2) ? '0' + digit : 'A' + digit - 2;
    i++;
  }
  bin[i] = '\0';
  return bin;
}

// Define a function to convert binary to hexadecimal
char* bin_to_hex(char* bin) {
  char hex[10];
  int i = 0;
  int len = strlen(bin);
  while (i < len) {
    int digit = bin[i] - '0';
    if (digit < 0 || digit > 1) {
      digit = (bin[i] - 'A' + 2) % 4;
    }
    hex[i] = (digit < 10) ? '0' + digit : 'A' + digit - 10;
    i++;
  }
  hex[i] = '\0';
  return hex;
}

// Define a function to convert hexadecimal to binary
char* hex_to_oct(char* hex) {
  char oct[10];
  int i = 0;
  int len = strlen(hex);
  while (i < len) {
    int digit = hex[i] - '0';
    if (digit < 0 || digit > 9) {
      digit = (hex[i] - 'A' + 10) % 16;
    }
    oct[i] = (digit < 8) ? '0' + digit : 'A' + digit - 8;
    i++;
  }
  oct[i] = '\0';
  return oct;
}

// Define a function to convert binary to hexadecimal
char* oct_to_hex(char* oct) {
  char hex[10];
  int i = 0;
  int len = strlen(oct);
  while (i < len) {
    int digit = oct[i] - '0';
    if (digit < 0 || digit > 7) {
      digit = (oct[i] - 'A' + 8) % 16;
    }
    hex[i] = (digit < 10) ? '0' + digit : 'A' + digit - 10;
    i++;
  }
  hex[i] = '\0';
  return hex;
}

// Main function
int main() {
  // Take input from the user
  char hex[10];
  printf(""Enter a hexadecimal number: "");
  scanf(""%s"", hex);

  // Convert hexadecimal to decimal
  int dec = hex_to_dec(hex);
  printf(""Decimal equivalent: %d\n"", dec);

  // Convert decimal to hexadecimal
  char* hex2 = dec_to_hex(dec);
  printf(""Hexadecimal equivalent: %s\n"", hex2);

  // Convert hexadecimal to binary
  char* bin = hex_to_bin(hex);
  printf(""Binary equivalent: %s\n"", bin);

  // Convert binary to hexadecimal
  char* hex3 = bin_to_hex(bin);
  printf(""Hexadecimal equivalent: %s\n"", hex3);

  // Convert hexadecimal to octal
  char* oct = hex_to_oct(hex);
  printf(""Octal equivalent: %s\n"", oct);

  // Convert octal to hexadecimal
  char* hex4 = oct_to_hex(oct);
  printf(""Hexadecimal equivalent: %s\n"", hex4);

  return 0;
}",138,4.0
VULNERABLE,falcon180b-69706.c,yes,19,5,handle_client,"
  file falcon180b-69706.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int connections[MAX_CONNECTIONS];
int num_connections = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CONNECTIONS 100
#define BUFFER_SIZE 1024

int connections[MAX_CONNECTIONS];
int num_connections = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message: %s\n"", buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int listening_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (listening_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    if (bind(listening_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(listening_socket, MAX_CONNECTIONS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Firewall is running...\n"");

    while (1) {
        int client_socket = accept(listening_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_connections >= MAX_CONNECTIONS) {
            printf(""Maximum connections reached\n"");
            close(client_socket);
            continue;
        }

        connections[num_connections] = client_socket;
        num_connections++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",86,5.0
VULNERABLE,falcon180b-42104.c,yes,19,5,handle_client,"
  file falcon180b-42104.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_DATA_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8000);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        clients[num_clients++] = client_socket;
    }

    return 0;
}",63,4.0
VULNERABLE,falcon180b-16197.c,yes,20,5,handle_client,"
  file falcon180b-16197.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int main_socket;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 100
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int main_socket;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        send(client_socket_copy, buffer, bytes_received, 0);
    }
    close(client_socket_copy);
    return NULL;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(main_socket, NULL, NULL);
        if (client_socket == -1) {
            continue;
        }
        clients[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(main_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(main_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(main_socket, 10);

    accept_connections();

    return 0;
}",63,2.333
VULNERABLE,falcon180b-53797.c,yes,19,5,handle_client,"
  file falcon180b-53797.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", sock, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= sock) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(sock);
    return NULL;
}

int main() {
    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(12345);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port 12345\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_create(&thread_ids[num_clients - 1], NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,gemini_pro-31620.c,yes,35,5,player_thread,"
  file gemini_pro-31620.c line 35 column 5 function player_thread
","
  c:@F@player_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

void *player_thread(void *arg) {
    int id = *(int *)arg;

    while (1) {
        pthread_mutex_lock(&mutex);

        while (current_player != id) {","//GEMINI-pro DATASET v1.0 Category: Scientific Calculator Implementation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <pthread.h>
#include <signal.h>

#define MAX_PLAYERS 4
#define MAX_OPERATIONS 5

typedef struct {
    int id;
    int score;
    char name[32];
} player_t;

typedef struct {
    int num1;
    int num2;
    char op;
} operation_t;

player_t players[MAX_PLAYERS];
operation_t operations[MAX_OPERATIONS];

int current_player = 0;
int current_operation = 0;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

void *player_thread(void *arg) {
    int id = *(int *)arg;

    while (1) {
        pthread_mutex_lock(&mutex);

        while (current_player != id) {
            pthread_cond_wait(&cond, &mutex);
        }

        printf(""Player %d's turn\n"", id);

        operation_t op = operations[current_operation];

        int result;
        switch (op.op) {
            case '+':
                result = op.num1 + op.num2;
                break;
            case '-':
                result = op.num1 - op.num2;
                break;
            case '*':
                result = op.num1 * op.num2;
                break;
            case '/':
                result = op.num1 / op.num2;
                break;
            case '%':
                result = op.num1 % op.num2;
                break;
        }

        int answer;
        printf(""What is the answer to %d %c %d? "", op.num1, op.op, op.num2);
        scanf(""%d"", &answer);

        if (answer == result) {
            players[id].score++;
            printf(""Correct!\n"");
        } else {
            printf(""Incorrect!\n"");
        }

        current_player = (current_player + 1) % MAX_PLAYERS;
        current_operation = (current_operation + 1) % MAX_OPERATIONS;

        pthread_cond_broadcast(&cond);
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

int main() {
    srand(time(NULL));

    for (int i = 0; i < MAX_PLAYERS; i++) {
        players[i].id = i;
        players[i].score = 0;
        strcpy(players[i].name, ""Player X""); // Replace with real names
    }

    for (int i = 0; i < MAX_OPERATIONS; i++) {
        operations[i].num1 = rand() % 100;
        operations[i].num2 = rand() % 100;
        operations[i].op = ""+-*/%""[rand() % 5];
    }

    pthread_t threads[MAX_PLAYERS];

    for (int i = 0; i < MAX_PLAYERS; i++) {
        pthread_create(&threads[i], NULL, player_thread, &i);
    }

    for (int i = 0; i < MAX_PLAYERS; i++) {
        pthread_join(threads[i], NULL);
    }

    printf(""Final scores:\n"");

    for (int i = 0; i < MAX_PLAYERS; i++) {
        printf(""%s: %d\n"", players[i].name, players[i].score);
    }

    return 0;
}",120,7.5
VULNERABLE,falcon180b-25949.c,yes,19,5,handle_client,"
  file falcon180b-25949.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            printf(""Client %d disconnected\n"", client_socket);
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server full, client %d rejected\n"", client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;
            printf(""Client %d connected\n"", client_socket);
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",62,3.0
VULNERABLE,falcon180b-56400.c,yes,23,5,generate_primes,"
  file falcon180b-56400.c line 23 column 5 function generate_primes
","
  c:@F@generate_primes at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `start'",dereference failure: accessed expired variable pointer,"    }
    return 1;
}

void *generate_primes(void *arg) {
    int start = *(int *) arg;
    int end = start + 100;
    int count = 0;

    for (int i = start; i < end; i++) {
        if (is_prime(i)) {","//Falcon-180B DATASET v1.0 Category: Prime Number Generator ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>

#define MAX_NUM 1000000

int is_prime(int num) {
    if (num < 2) {
        return 0;
    }
    int sqrt_num = sqrt(num);
    for (int i = 2; i <= sqrt_num; i++) {
        if (num % i == 0) {
            return 0;
        }
    }
    return 1;
}

void *generate_primes(void *arg) {
    int start = *(int *) arg;
    int end = start + 100;
    int count = 0;

    for (int i = start; i < end; i++) {
        if (is_prime(i)) {
            printf(""%d "", i);
            count++;
        }
    }

    pthread_exit(0);
}

int main() {
    pthread_t threads[10];
    int ids[10];
    int num_threads = 10;
    int chunk_size = MAX_NUM / num_threads;

    for (int i = 0; i < num_threads; i++) {
        int start = i * chunk_size;
        int end = (i == num_threads - 1)? MAX_NUM : (i + 1) * chunk_size;
        pthread_create(&threads[i], NULL, generate_primes, &start);
        ids[i] = i;
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",55,3.667
VULNERABLE,falcon180b-36514.c,yes,19,5,handle_client,"
  file falcon180b-36514.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket = -1;
int client_sockets[MAX_CLIENTS] = {-1};
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Traffic Light Controller ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int server_socket = -1;
int client_sockets[MAX_CLIENTS] = {-1};
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 51, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-20239.c,yes,21,5,handle_client,"
  file falcon180b-20239.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i][0]!= client_socket) {
                send(clients[i][0], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is running on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",94,6.0
VULNERABLE,gemini_pro-10319.c,yes,16,5,handle_connection,"
  file gemini_pro-10319.c line 16 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"// Our own special port for sending happiness
#define HAPPY_PORT 9999

// A thread to handle each incoming connection
void* handle_connection(void* arg) {
    int client_socket = *(int*)arg;

    // Receive the message from the client
    char message[1024] = {0};
    recv(client_socket, message, sizeof(message), 0);
","//GEMINI-pro DATASET v1.0 Category: Networking ; Style: cheerful
// A whimsical C networking program to spread joy

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

// Our own special port for sending happiness
#define HAPPY_PORT 9999

// A thread to handle each incoming connection
void* handle_connection(void* arg) {
    int client_socket = *(int*)arg;

    // Receive the message from the client
    char message[1024] = {0};
    recv(client_socket, message, sizeof(message), 0);

    // Spread the joy!
    printf(""Received message: %s\n"", message);
    send(client_socket, ""You're welcome! :)"", strlen(""You're welcome! :)""), 0);

    // Close the connection
    close(client_socket);
    return NULL;
}

int main() {
    // Create the server socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""Failed to create server socket"");
        return 1;
    }

    // Bind the socket to our special port
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(HAPPY_PORT);
    if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) == -1) {
        perror(""Failed to bind server socket"");
        return 1;
    }

    // Listen for incoming connections
    if (listen(server_socket, 5) == -1) {
        perror(""Failed to listen on server socket"");
        return 1;
    }

    printf(""Server is up and running, waiting for connections...\n"");

    // Handle incoming connections in separate threads
    int client_socket;
    pthread_t thread;
    while ((client_socket = accept(server_socket, NULL, NULL)) != -1) {
        if (pthread_create(&thread, NULL, handle_connection, (void*)&client_socket) != 0) {
            perror(""Failed to create thread"");
            return 1;
        }
        pthread_detach(thread);
    }

    // Close the server socket
    close(server_socket);
    return 0;
}",72,3.5
VULNERABLE,falcon180b-65223.c,yes,17,5,handle_client,"
  file falcon180b-65223.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Database Indexing System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",65,3.0
VULNERABLE,falcon180b-13823.c,yes,19,5,handle_client,"
  file falcon180b-13823.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[MAX_MSG_SIZE];

    while (1) {
        bzero(buffer, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 100
#define MAX_MSG_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[MAX_MSG_SIZE];

    while (1) {
        bzero(buffer, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 51, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",67,3.0
VULNERABLE,gpt35-34852.c,yes,72,5,connection_handler,"
  file gpt35-34852.c line 72 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *connection_handler(void *socket_fd) {
    int client_fd = *(int *)socket_fd;
    char buffer[1024] = {0};
    char message[1024] = {0};

    // Sending welcome message to client
    strcpy(message, ""Welcome to the server!"");","//FormAI DATASET v1.0 Category: Client Server Application ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8888

// Function to handle communication with the client
void *connection_handler(void *);

int main(int argc, char *argv[]) {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    int opt = 1;
    int addrlen = sizeof(server_addr);

    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    // Setting socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    // Setting server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Binding socket to the specified address and port
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listening for incoming connections
    if (listen(server_fd, 1) < 0) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    puts(""Waiting for incoming connections..."");

    // Accepting incoming connections and handling them using threads
    while ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, (socklen_t *)&addrlen))) {
        puts(""Connection accepted"");

        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, connection_handler, (void *)&client_fd) < 0) {
            perror(""pthread_create"");
            exit(EXIT_FAILURE);
        }
    }

    if (client_fd < 0) {
        perror(""accept"");
        exit(EXIT_FAILURE);
    }

    return 0;
}

void *connection_handler(void *socket_fd) {
    int client_fd = *(int *)socket_fd;
    char buffer[1024] = {0};
    char message[1024] = {0};

    // Sending welcome message to client
    strcpy(message, ""Welcome to the server!"");
    if (send(client_fd, message, strlen(message), 0) < 0) {
        perror(""send"");
        exit(EXIT_FAILURE);
    }

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        memset(message, 0, sizeof(message));

        // Receiving message from client
        if (recv(client_fd, buffer, sizeof(buffer), 0) < 0) {
            perror(""recv"");
            exit(EXIT_FAILURE);
        }

        // Preparing message to be sent back to client
        strcpy(message, ""Server received: "");
        strcat(message, buffer);

        // Sending message back to client
        if (send(client_fd, message, strlen(message), 0) < 0) {
            perror(""send"");
            exit(EXIT_FAILURE);
        }
    }

    // Closing client connection
    close(client_fd);

    return NULL;
}",108,6.5
VULNERABLE,falcon180b-23592.c,yes,18,5,handle_client,"
  file falcon180b-23592.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Packet Monitoring ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-34119.c,yes,19,5,handle_client,"
  file falcon180b-34119.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void* handle_client(void* arg) {
    int client_socket = *((int*) arg);
    char buffer[MAX_MSG_LEN];

    while (1) {
        memset(buffer, 0, MAX_MSG_LEN);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_LEN, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <pthread.h>

#define SERVER_PORT 8080
#define MAX_CLIENTS 10
#define MAX_MSG_LEN 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void* handle_client(void* arg) {
    int client_socket = *((int*) arg);
    char buffer[MAX_MSG_LEN];

    while (1) {
        memset(buffer, 0, MAX_MSG_LEN);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_LEN, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        // Broadcast the message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (client_socket!= client_sockets[i]) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Please try again later.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void*) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-11029.c,yes,23,5,handle_client,"
  file falcon180b-11029.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Metadata Extractor ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent request: %s\n"", client_socket, request);

        // Do something with the request here
        sleep(1);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket!= -1) {
            pthread_mutex_lock(&lock);

            for (int i = 0; i < num_clients; i++) {
                if (client_sockets[i] == -1) {
                    client_sockets[i] = client_socket;
                    printf(""Client %d connected\n"", i + 1);
                    num_clients++;
                    break;
                }
            }

            pthread_mutex_unlock(&lock);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }
}

int main() {
    accept_connections();

    return 0;
}",85,3.0
VULNERABLE,gemini_pro-30004.c,yes,106,5,free_book,"
  file gemini_pro-30004.c line 106 column 5 function free_book
","
  c:@F@free_book at file gemini_pro-30004.c line 130 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `author'",dereference failure: accessed expired variable pointer,"}

// Free the memory allocated for a book
void free_book(book *book) {
    free(book->title);
    free(book->author);
    free(book->text);
    free(book);
}

// Main function","//GEMINI-pro DATASET v1.0 Category: Ebook reader ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a book
typedef struct book {
    char *title;
    char *author;
    int num_pages;
    char *text;
} book;

// Create a new book
book *create_book(char *title, char *author, int num_pages, char *text) {
    book *new_book = malloc(sizeof(book));
    new_book->title = title;
    new_book->author = author;
    new_book->num_pages = num_pages;
    new_book->text = text;
    return new_book;
}

// Print the details of a book
void print_book(book *book) {
    printf(""Title: %s\n"", book->title);
    printf(""Author: %s\n"", book->author);
    printf(""Number of pages: %d\n"", book->num_pages);
    printf(""Text: %s\n"", book->text);
}

// Read a book from a file
book *read_book_from_file(char *filename) {
    FILE *file = fopen(filename, ""r"");
    if (file == NULL) {
        perror(""Error opening file"");
        return NULL;
    }

    // Read the title of the book
    char title[256];
    if (fgets(title, sizeof(title), file) == NULL) {
        perror(""Error reading title"");
        fclose(file);
        return NULL;
    }

    // Read the author of the book
    char author[256];
    if (fgets(author, sizeof(author), file) == NULL) {
        perror(""Error reading author"");
        fclose(file);
        return NULL;
    }

    // Read the number of pages in the book
    int num_pages;
    if (fscanf(file, ""%d"", &num_pages) != 1) {
        perror(""Error reading number of pages"");
        fclose(file);
        return NULL;
    }

    // Read the text of the book
    char *text = malloc(sizeof(char) * (num_pages + 1));
    if (fread(text, sizeof(char), num_pages, file) != num_pages) {
        perror(""Error reading text"");
        fclose(file);
        return NULL;
    }

    // Close the file
    fclose(file);

    // Create a new book
    book *new_book = create_book(title, author, num_pages, text);
    return new_book;
}

// Write a book to a file
void write_book_to_file(char *filename, book *book) {
    FILE *file = fopen(filename, ""w"");
    if (file == NULL) {
        perror(""Error opening file"");
        return;
    }

    // Write the title of the book
    fprintf(file, ""%s\n"", book->title);

    // Write the author of the book
    fprintf(file, ""%s\n"", book->author);

    // Write the number of pages in the book
    fprintf(file, ""%d\n"", book->num_pages);

    // Write the text of the book
    fwrite(book->text, sizeof(char), book->num_pages, file);

    // Close the file
    fclose(file);
}

// Free the memory allocated for a book
void free_book(book *book) {
    free(book->title);
    free(book->author);
    free(book->text);
    free(book);
}

// Main function
int main(int argc, char **argv) {
    // Check if a filename was provided
    if (argc != 2) {
        fprintf(stderr, ""Usage: %s <filename>\n"", argv[0]);
        return EXIT_FAILURE;
    }

    // Read the book from the file
    book *book = read_book_from_file(argv[1]);
    if (book == NULL) {
        fprintf(stderr, ""Error reading book from file\n"");
        return EXIT_FAILURE;
    }

    // Print the details of the book
    print_book(book);

    // Free the memory allocated for the book
    free_book(book);

    return EXIT_SUCCESS;
}",133,2.333
VULNERABLE,falcon180b-32041.c,yes,19,5,handle_client,"
  file falcon180b-32041.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int clients_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int client_sockets[MAX_CLIENTS];
int clients_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        if (clients_count >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[clients_count++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();

    return 0;
}",87,3.667
VULNERABLE,falcon180b-5006.c,yes,18,5,handle_client,"
  file falcon180b-5006.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full. Please try later.\n"", 37, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-46171.c,yes,71,5,handle_client,"
  file falcon180b-46171.c line 71 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *handle_client(void *param) {
    int client_socket = *(int *)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *param);

int main() {
    int opt = 1;
    struct sockaddr_in server_addr, client_addr;
    char buffer[BUFFER_SIZE];

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server is running on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int new_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (new_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        client_sockets[num_clients] = new_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&new_socket);
    }

    return 0;
}

void *handle_client(void *param) {
    int client_socket = *(int *)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client disconnected\n"");
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Received message: %s\n"", buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}",92,5.5
VULNERABLE,gemini_pro-38137.c,yes,17,3,thread_function,"
  file gemini_pro-38137.c line 17 column 3 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"pthread_mutex_t lock;

// Define the thread function
void *thread_function(void *arg) {
  // Get the thread ID
  int thread_id = *(int *)arg;

  // Perform the task
  for (int i = 0; i < 100000; i++) {
    // Lock the mutex
    pthread_mutex_lock(&lock);","//GEMINI-pro DATASET v1.0 Category: Threading Library Implementation ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>

// Define the number of threads
#define NUM_THREADS 4

// Define the global variables
int shared_variable = 0;
pthread_mutex_t lock;

// Define the thread function
void *thread_function(void *arg) {
  // Get the thread ID
  int thread_id = *(int *)arg;

  // Perform the task
  for (int i = 0; i < 100000; i++) {
    // Lock the mutex
    pthread_mutex_lock(&lock);

    // Increment the shared variable
    shared_variable++;

    // Unlock the mutex
    pthread_mutex_unlock(&lock);
  }

  // Return NULL
  return NULL;
}

// Main function
int main() {
  // Initialize the mutex
  pthread_mutex_init(&lock, NULL);

  // Create the threads
  pthread_t threads[NUM_THREADS];
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_create(&threads[i], NULL, thread_function, (void *)&i);
  }

  // Join the threads
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  // Print the shared variable
  printf(""The shared variable is: %d\n"", shared_variable);

  // Destroy the mutex
  pthread_mutex_destroy(&lock);

  // Return 0
  return 0;
}",59,2.5
VULNERABLE,falcon180b-60732.c,yes,32,5,handle_client,"
  file falcon180b-60732.c line 32 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket_fd'",dereference failure: accessed expired variable pointer,"void unlock_semaphore() {
    sem_post(&mutex);
}

void *handle_client(void *client_socket) {
    int client_socket_fd = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/time.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
sem_t mutex;

void init_semaphore() {
    sem_init(&mutex, 0, 1);
}

void lock_semaphore() {
    sem_wait(&mutex);
}

void unlock_semaphore() {
    sem_post(&mutex);
}

void *handle_client(void *client_socket) {
    int client_socket_fd = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket_fd, buffer);
    }

    close(client_socket_fd);
}

int main() {
    init_semaphore();

    int server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket_fd, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket_fd, MAX_CLIENTS);

    while (1) {
        int client_socket_fd = accept(server_socket_fd, NULL, NULL);

        if (client_socket_fd < 0) {
            printf(""Error accepting client\n"");
            continue;
        }

        lock_semaphore();

        int i = 0;
        while (clients[i]!= 0) {
            i++;
        }

        clients[i] = client_socket_fd;
        printf(""Client %d connected\n"", client_socket_fd);

        unlock_semaphore();

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket_fd);
    }

    close(server_socket_fd);
    sem_destroy(&mutex);

    return 0;
}",92,2.0
VULNERABLE,falcon180b-26781.c,yes,18,5,thread_client,"
  file falcon180b-26781.c line 18 column 5 function thread_client
","
  c:@F@thread_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        if (recv(client_socket, buffer, sizeof(buffer), 0) <= 0) {
            break;","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        if (recv(client_socket, buffer, sizeof(buffer), 0) <= 0) {
            break;
        }
        printf(""Client %d says: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket!= -1) {
            printf(""Client connected: %d\n"", client_socket);
            for (int i = 0; i < num_clients; i++) {
                if (clients[i] == -1) {
                    clients[i] = client_socket;
                    num_clients++;
                    break;
                }
            }
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, thread_client, (void *) &client_socket);
        }
    }

    return 0;
}",78,6.5
VULNERABLE,falcon180b-10930.c,yes,30,5,handle_client,"
  file falcon180b-10930.c line 30 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"sem_t clients;
int num_clients = 0;
struct client clients_list[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: decentralized
// This program analyzes the Wi-Fi signal strength in a decentralized style

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080
#define SSID_MAX_LEN 32
#define PASSWORD_MAX_LEN 64

struct client {
    int sock;
    char ssid[SSID_MAX_LEN];
    char password[PASSWORD_MAX_LEN];
};

sem_t clients;
int num_clients = 0;
struct client clients_list[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_sock, buffer);
    }

    close(client_sock);

    sem_post(&clients);
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_sock, 3);

    sem_init(&clients, 0, MAX_CLIENTS);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &client_addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_sock);
            continue;
        }

        sem_wait(&clients);

        strcpy(clients_list[num_clients].ssid, """");
        strcpy(clients_list[num_clients].password, """");

        clients_list[num_clients].sock = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
    }

    close(server_sock);

    return 0;
}",89,3.0
VULNERABLE,falcon180b-22269.c,yes,18,5,handle_client,"
  file falcon180b-22269.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket_copy, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket_copy, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s"", client_socket_copy, buffer);
        send(client_socket_copy, buffer, strlen(buffer), 0);
    }

    close(client_socket_copy);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server is running on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,3.5
VULNERABLE,gpt35-25282.c,yes,21,3,client_handler,"
  file gpt35-25282.c line 21 column 3 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_id'",dereference failure: accessed expired variable pointer,"char client_names[MAX_CLIENTS][BUF_SIZE];

void send_all(char* message, int sender_id);

void* client_handler(void* arg) {
  int client_id = *(int*) arg;
  int client_socket = client_sockets[client_id];
  char client_name[BUF_SIZE] = """";
  char buf[BUF_SIZE] = """";

  // Get client name","//FormAI DATASET v1.0 Category: Chat server ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 256

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int client_count = 0;
int client_sockets[MAX_CLIENTS];
char client_names[MAX_CLIENTS][BUF_SIZE];

void send_all(char* message, int sender_id);

void* client_handler(void* arg) {
  int client_id = *(int*) arg;
  int client_socket = client_sockets[client_id];
  char client_name[BUF_SIZE] = """";
  char buf[BUF_SIZE] = """";

  // Get client name
  strcpy(buf, ""Enter your name: "");
  send(client_socket, buf, strlen(buf), 0);
  recv(client_socket, client_name, BUF_SIZE, 0);
  strcpy(client_names[client_id], client_name);

  while (1) {
    // Receive message
    memset(buf, 0, BUF_SIZE);
    if (recv(client_socket, buf, BUF_SIZE, 0) == 0) {
      printf(""Client %d (%s) disconnected.\n"", client_id, client_name);
      pthread_mutex_lock(&mutex);
      client_count--;
      client_sockets[client_id] = 0;
      strcpy(client_names[client_id], """");
      send_all("""", client_id); // Notify other clients of disconnection
      pthread_mutex_unlock(&mutex);
      break;
    }

    // Handle command message
    if (strlen(buf) > 1 && buf[0] == '/') {
      if (strcmp(buf, ""/list"") == 0) {
        // Send list of connected clients
        char message[BUF_SIZE] = ""Connected clients:\n"";
        pthread_mutex_lock(&mutex);
        for (int i = 0; i < MAX_CLIENTS; i++) {
          if (client_sockets[i] > 0) {
            strcat(message, client_names[i]);
            strcat(message, ""\n"");
          }
        }
        pthread_mutex_unlock(&mutex);
        send(client_socket, message, strlen(message), 0);
      } else {
        printf(""Invalid command from client %d (%s): %s\n"",
               client_id, client_name, buf);
      }
      continue;
    }

    // Send message to all clients
    char message[BUF_SIZE] = """";
    pthread_mutex_lock(&mutex);
    sprintf(message, ""%s: %s"", client_name, buf);
    send_all(message, client_id);
    pthread_mutex_unlock(&mutex);
  }

  close(client_socket);
  return NULL;
}

void send_all(char* message, int sender_id) {
  for (int i = 0; i < MAX_CLIENTS; i++) {
    int client_socket = client_sockets[i];
    if (client_socket > 0 && i != sender_id) {
      send(client_socket, message, strlen(message), 0);
    }
  }
}

int main() {
  int server_socket;
  struct sockaddr_in server_address;

  // Create socket
  if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    printf(""Failed to create socket.\n"");
    exit(1);
  }

  // Configure server address
  server_address.sin_family = AF_INET;
  server_address.sin_addr.s_addr = htonl(INADDR_ANY);
  server_address.sin_port = htons(5000);

  // Bind socket to address
  if (bind(server_socket, (struct sockaddr*) &server_address, sizeof(server_address)) == -1) {
    printf(""Failed to bind socket.\n"");
    close(server_socket);
    exit(1);
  }

  // Listen for connections
  if (listen(server_socket, MAX_CLIENTS) == -1) {
    printf(""Failed to listen for connections.\n"");
    close(server_socket);
    exit(1);
  }

  printf(""Chat server started.\n"");

  while (1) {
    // Accept incoming connection
    struct sockaddr_in client_address;
    memset(&client_address, 0, sizeof(client_address));
    socklen_t addr_size = sizeof(client_address);
    int client_socket = accept(server_socket, (struct sockaddr*) &client_address, &addr_size);
    if (client_socket == -1) {
      printf(""Failed to accept connection.\n"");
      continue;
    }

    // Handle connection in new thread
    pthread_t thread_id;
    int client_id = -1;
    pthread_mutex_lock(&mutex);
    if (client_count < MAX_CLIENTS) {
      // Find first available client slot
      for (int i = 0; i < MAX_CLIENTS; i++) {
        if (client_sockets[i] == 0) {
          client_id = i;
          client_sockets[client_id] = client_socket;
          client_count++;
          break;
        }
      }
    }
    pthread_mutex_unlock(&mutex);
    if (client_id == -1) {
      printf(""Max clients reached. Connection closed.\n"");
      close(client_socket);
      continue;
    }
    if (pthread_create(&thread_id, NULL, client_handler, (void*) &client_id) != 0) {
      printf(""Failed to create client thread.\n"");
      close(client_socket);
      continue;
    }
  }

  close(server_socket);
  return 0;
}",160,7.667
VULNERABLE,falcon180b-56680.c,yes,18,5,handle_client,"
  file falcon180b-56680.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",84,6.0
VULNERABLE,falcon180b-11200.c,yes,20,5,handle_client,"
  file falcon180b-11200.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Topology Mapper ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            return NULL;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",88,6.0
VULNERABLE,falcon180b-5196.c,yes,19,5,handle_client,"
  file falcon180b-5196.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void broadcast_message(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 46, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",80,3.667
VULNERABLE,gpt35-7751.c,yes,20,5,handle_client,"
  file gpt35-7751.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;

// Thread function to handle each client connection
void *handle_client(void *arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    // Receive messages until client disconnects
    while (1) {
        // Receive message from client","//FormAI DATASET v1.0 Category: Networking ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

// Global variables
int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

// Thread function to handle each client connection
void *handle_client(void *arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    // Receive messages until client disconnects
    while (1) {
        // Receive message from client
        int data_len = recv(client_socket, buffer, BUFFER_SIZE, 0);

        // Check for disconnect
        if (data_len == 0) {
            printf(""Client disconnected\n"");
            close(client_socket);

            // Remove client from array of active clients
            for (int i = 0; i < num_clients; i++) {
                if (client_sockets[i] == client_socket) {
                    client_sockets[i] = client_sockets[num_clients-1];
                    num_clients--;
                    break;
                }
            }

            // Exit thread
            pthread_exit(NULL);
        }

        // Print message
        printf(""Received: %s"", buffer);

        // Forward message to all other clients
        for (int i = 0; i < num_clients; i++) {
            int socket_fd = client_sockets[i];

            // Skip if this is the original client
            if (socket_fd == client_socket) {
                continue;
            }

            // Send message to other clients
            if (send(socket_fd, buffer, data_len, 0) != data_len) {
                printf(""Error sending message to client\n"");
            }
        }
    }
}

int main() {
    // Create server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating server socket\n"");
        return 1;
    }

    // Set socket options to reuse address
    int opt = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        printf(""Error setting socket options\n"");
        return 1;
    }

    // Set server address
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8888);

    // Bind server socket to address
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding server socket to address\n"");
        return 1;
    }

    // Listen for incoming connections
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening for incoming connections\n"");
        return 1;
    }

    printf(""Server started\n"");

    // Accept incoming connections and spawn thread to handle each one
    while (1) {
        // Accept connection
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &addr_len);
        if (client_socket == -1) {
            printf(""Error accepting client connection\n"");
            continue;
        }

        // Add client to array of active clients
        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;

        // Spawn thread to handle client connection
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, &client_socket) == -1) {
            printf(""Error creating thread to handle client connection\n"");
            return 1;
        }
    }

    // Close server socket
    close(server_socket);

    return 0;
}",133,8.5
VULNERABLE,falcon180b-24820.c,yes,20,5,handle_client,"
  file falcon180b-24820.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Failed to create socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Failed to bind socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Failed to listen on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);
        if (client_socket == -1) {
            printf(""Failed to accept connection\n"");
            continue;
        }

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
        } else {
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",86,6.0
VULNERABLE,gpt35-36390.c,yes,17,5,handle_client,"
  file gpt35-36390.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_read = read(client_socket, buffer, sizeof(buffer));
        if (bytes_read < 0) {","//FormAI DATASET v1.0 Category: Socket programming ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 50

int client_sockets[MAX_CLIENTS];
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_read = read(client_socket, buffer, sizeof(buffer));
        if (bytes_read < 0) {
            perror(""Error reading from client"");
            close(client_socket);
            return NULL;
        }
        if (bytes_read == 0 || strcmp(buffer, ""quit\n"") == 0) {
            printf(""Client disconnected\n"");
            close(client_socket);
            return NULL;
        }
        printf(""Received message: %s"", buffer);
        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (client_sockets[i] > 0 && client_sockets[i] != client_socket) {
                write(client_sockets[i], buffer, strlen(buffer));
            }
        }
    }
}

int main() {
    int server_socket, client_socket;
    struct sockaddr_in server_address, client_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(PORT);
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror(""Error creating socket"");
        return 1;
    }
    if (bind(server_socket, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {
        perror(""Error binding socket"");
        return 1;
    }
    if (listen(server_socket, MAX_CLIENTS) < 0) {
        perror(""Error listening on socket"");
        return 1;
    }
    printf(""Server started on port %d\n"", PORT);
    int index = 0;
    while (1) {
        int client_size = sizeof(client_address);
        if ((client_socket = accept(server_socket, (struct sockaddr *) &client_address, &client_size)) < 0) {
            perror(""Error accepting client connection"");
            return 1;
        }
        printf(""Accepted new connection from %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));
        if (index == MAX_CLIENTS) {
            printf(""Max clients reached\n"");
            close(client_socket);
        } else {
            client_sockets[index] = client_socket;
            pthread_create(&threads[index], NULL, handle_client, (void *) &client_socket);
            index++;
        }
    }
    return 0;
}",79,7.5
VULNERABLE,falcon180b-46303.c,yes,18,5,handle_client,"
  file falcon180b-46303.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Log analysis ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, sizeof(client_addr));

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        int i;
        for (i = 0; i < MAX_CLIENTS; i++) {
            if (client_sockets[i] == 0) {
                client_sockets[i] = client_socket;
                pthread_create(&thread_ids[i], NULL, handle_client, (void *) &client_socket);
                break;
            }
        }

        if (i == MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
        }
    }

    return 0;
}",73,4.5
VULNERABLE,falcon180b-12796.c,yes,38,5,run_task,"
  file falcon180b-12796.c line 38 column 5 function run_task
","
  c:@F@run_task at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `task_id'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *run_task(void *arg) {
    int task_id = *((int *) arg);
    int interval = 1000; // 1 second
    int duration = 5000; // 5 seconds

    while (duration > 0) {
        printf(""Task %d is running...\n"", task_id);","//Falcon-180B DATASET v1.0 Category: Task Scheduler ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

// Function prototypes
void *run_task(void *arg);
void schedule_task(int task_id, int interval, int duration);

int main() {
    int num_tasks = 5;
    int task_ids[num_tasks];
    int intervals[num_tasks];
    int durations[num_tasks];

    // Initialize task IDs, intervals, and durations
    for (int i = 0; i < num_tasks; i++) {
        task_ids[i] = i + 1;
        intervals[i] = 1000; // 1 second
        durations[i] = 5000; // 5 seconds
    }

    // Schedule tasks
    for (int i = 0; i < num_tasks; i++) {
        schedule_task(task_ids[i], intervals[i], durations[i]);
    }

    // Join scheduled tasks
    for (int i = 0; i < num_tasks; i++) {
        pthread_join(task_ids[i], NULL);
    }

    return 0;
}

void *run_task(void *arg) {
    int task_id = *((int *) arg);
    int interval = 1000; // 1 second
    int duration = 5000; // 5 seconds

    while (duration > 0) {
        printf(""Task %d is running...\n"", task_id);
        sleep(interval);
        duration -= interval;
    }

    printf(""Task %d has completed.\n"", task_id);
    return NULL;
}

void schedule_task(int task_id, int interval, int duration) {
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, run_task, &task_id);
    sleep(interval);
    pthread_cancel(thread_id);
}",57,2.333
VULNERABLE,falcon180b-4935.c,yes,68,16,execute_command,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file falcon180b-4935.c line 68 column 16 function execute_command
  c:@F@execute_command at file falcon180b-4935.c line 27 column 13 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `argv'",dereference failure: accessed expired variable pointer,"    pid_t pid;
    int status;

    if (strcmp(arguments[0], ""exit"") == 0) {
        return 0;
    } else if (strcmp(arguments[0], ""cd"") == 0) {
        if (arguments[1] == NULL) {
            printf(""Usage: cd [directory]\n"");
        } else {
            if (chdir(arguments[1])!= 0) {
                perror(""chdir"");","//Falcon-180B DATASET v1.0 Category: Basic Unix-like Shell ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_COMMAND_LENGTH 1024
#define MAX_ARGUMENTS 256

// Function prototypes
int parse_command(char* command, char*** arguments);
int execute_command(char** arguments);
void print_prompt();

int main() {
    char command[MAX_COMMAND_LENGTH];
    char* arguments[MAX_ARGUMENTS];
    int status;

    print_prompt();

    while (fgets(command, MAX_COMMAND_LENGTH, stdin)!= NULL) {
        status = parse_command(command, &arguments);

        if (status == 0) {
            execute_command(arguments);
        } else {
            printf(""Invalid command.\n"");
        }

        print_prompt();
    }

    return 0;
}

int parse_command(char* command, char*** arguments) {
    int argc = 0;
    char* argv[MAX_ARGUMENTS];
    char* token;

    token = strtok(command, "" "");
    while (token!= NULL) {
        argv[argc++] = token;
        if (argc >= MAX_ARGUMENTS) {
            printf(""Too many arguments.\n"");
            return 1;
        }
        token = strtok(NULL, "" "");
    }

    if (argc == 0) {
        printf(""Invalid command.\n"");
        return 1;
    }

    *arguments = argv;
    return 0;
}

int execute_command(char** arguments) {
    pid_t pid;
    int status;

    if (strcmp(arguments[0], ""exit"") == 0) {
        return 0;
    } else if (strcmp(arguments[0], ""cd"") == 0) {
        if (arguments[1] == NULL) {
            printf(""Usage: cd [directory]\n"");
        } else {
            if (chdir(arguments[1])!= 0) {
                perror(""chdir"");
            }
        }
    } else {
        pid = fork();

        if (pid == 0) {
            if (execvp(arguments[0], arguments) == -1) {
                perror(""execvp"");
            }
            exit(EXIT_FAILURE);
        } else if (pid < 0) {
            perror(""fork"");
        } else {
            waitpid(pid, &status, 0);
        }
    }

    return 0;
}

void print_prompt() {
    printf(""> "");
}",96,4.0
VULNERABLE,gemini_pro-15740.c,yes,22,5,thread_func,"
  file gemini_pro-15740.c line 22 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Thread function
void *thread_func(void *arg) {
    // Get the thread number
    int thread_num = *(int *)arg;

    // Connect to the database
    sqlite3 *db;
    int rc = sqlite3_open(DB_FILE, &db);
    if (rc != SQLITE_OK) {","//GEMINI-pro DATASET v1.0 Category: Database querying ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sqlite3.h>

// Database file name
#define DB_FILE ""mydb.db""

// Number of threads
#define NUM_THREADS 4

// Query to execute
#define QUERY ""SELECT * FROM users""

// Mutex to protect shared data
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Thread function
void *thread_func(void *arg) {
    // Get the thread number
    int thread_num = *(int *)arg;

    // Connect to the database
    sqlite3 *db;
    int rc = sqlite3_open(DB_FILE, &db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, ""Error opening database: %s\n"", sqlite3_errmsg(db));
        sqlite3_close(db);
        return NULL;
    }

    // Prepare the query
    sqlite3_stmt *stmt;
    rc = sqlite3_prepare_v2(db, QUERY, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, ""Error preparing query: %s\n"", sqlite3_errmsg(db));
        sqlite3_close(db);
        return NULL;
    }

    // Execute the query
    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        // Get the column values
        int id = sqlite3_column_int(stmt, 0);
        char *name = (char *)sqlite3_column_text(stmt, 1);

        // Print the results
        pthread_mutex_lock(&mutex);
        printf(""Thread %d: id=%d, name=%s\n"", thread_num, id, name);
        pthread_mutex_unlock(&mutex);
    }

    // Finalize the statement
    sqlite3_finalize(stmt);

    // Close the database
    sqlite3_close(db);

    return NULL;
}

int main() {
    // Create the threads
    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_func, &i);
    }

    // Wait for the threads to finish
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destroy the mutex
    pthread_mutex_destroy(&mutex);

    return 0;
}",79,3.5
VULNERABLE,gpt35-37509.c,yes,17,5,handle_client,"
  file gpt35-37509.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"int clients[20]; // an array to keep track of all the connected clients
int num_clients = 0; // keep track of the number of clients currently connected

void *handle_client(void *client_socket)
{
    int sock = *(int *)client_socket;

    char buffer[1024] = {0};
    char incoming_message[1024] = {0};

    // add the new client socket to the list of clients","//FormAI DATASET v1.0 Category: Chat server ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

int clients[20]; // an array to keep track of all the connected clients
int num_clients = 0; // keep track of the number of clients currently connected

void *handle_client(void *client_socket)
{
    int sock = *(int *)client_socket;

    char buffer[1024] = {0};
    char incoming_message[1024] = {0};

    // add the new client socket to the list of clients
    clients[num_clients++] = sock;

    while (1)
    {
        memset(buffer, 0, sizeof(buffer));
        memset(incoming_message, 0, sizeof(incoming_message));

        // read the incoming message from the current client
        int valread = read(sock, incoming_message, 1024);

        // if the client has disconnected, stop handling incoming messages
        if (valread == 0)
        {
            for (int i = 0; i < num_clients; i++)
            {
                if (clients[i] == sock)
                {
                    for (int j = i; j < num_clients - 1; j++)
                    {
                        clients[j] = clients[j + 1];
                    }

                    num_clients--;
                    break;
                }
            }

            break;
        }

        // send the incoming message to all connected clients (except the sender)
        for (int i = 0; i < num_clients; i++)
        {
            if (clients[i] != sock)
            {
                send(clients[i], incoming_message, strlen(incoming_message), 0);
            }
        }
    }

    // close the client socket once the while loop has finished
    close(sock);

    return NULL;
}

int main(int argc, char const *argv[])
{
    int server_fd;
    struct sockaddr_in address;
    int opt = 1;

    // create a TCP socket for the server
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    // set socket options to allow reuse of the address and port
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
    {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // bind the socket to the specified address and port
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    // listen for incoming connections
    if (listen(server_fd, 3) < 0)
    {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    while (1)
    {
        int new_socket;
        struct sockaddr_in client_address;
        int addrlen = sizeof(client_address);

        // accept incoming connection requests
        if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t *)&addrlen)) < 0)
        {
            perror(""accept"");
            exit(EXIT_FAILURE);
        }

        pthread_t thread_id;

        // create a new thread to handle each connected client
        if (pthread_create(&thread_id, NULL, handle_client, (void *)&new_socket) < 0)
        {
            perror(""pthread_create"");
            exit(EXIT_FAILURE);
        }
    }

    return 0;
}",131,8.0
VULNERABLE,gpt35-59112.c,yes,92,5,handle_client,"
  file gpt35-59112.c line 92 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket_fd'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *handle_client(void *sock_fd) {
    int client_socket_fd = *(int *) sock_fd;
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    while (true) {
        ssize_t data_size = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);","//FormAI DATASET v1.0 Category: Client Server Application ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

pthread_t thread_ids[MAX_CLIENTS];
int client_socket[MAX_CLIENTS];
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *);

int main(int argc, char *argv[]) {
    int server_socket, client_count = 0;
    struct sockaddr_in server_address, client_address;
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    // Creating socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror(""Failed to create socket"");
        exit(EXIT_FAILURE);
    }

    // Setting up server address information
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(8888);
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);

    // Binding socket to server address
    if (bind(server_socket, (struct sockaddr *) &server_address, sizeof(server_address)) != 0) {
        perror(""Failed to bind socket"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, 5) != 0) {
        perror(""Failed to listen on socket"");
        exit(EXIT_FAILURE);
    }

    printf(""Server started, waiting for incoming connections...\n"");

    // Accepting incoming connections from clients
    while (client_count < MAX_CLIENTS) {
        socklen_t client_address_len = sizeof(client_address);
        int client_socket_fd = accept(server_socket, (struct sockaddr *) &client_address, &client_address_len);

        if (client_socket_fd == -1) {
            perror(""Failed to accept client connection"");
            continue;
        }

        printf(""Client %d connected\n"", client_count + 1);

        // Locking mutex to prevent race condition between threads
        pthread_mutex_lock(&mutex);

        // Creating a new thread to handle client requests
        if (pthread_create(&thread_ids[client_count], NULL, handle_client, &client_socket_fd) != 0) {
            perror(""Failed to create thread"");
            exit(EXIT_FAILURE);
        }

        client_socket[client_count] = client_socket_fd;
        client_count++;

        // Unlocking mutex
        pthread_mutex_unlock(&mutex);
    }

    // Closing all client sockets and joining threads
    for (int i = 0; i < MAX_CLIENTS; i++) {
        pthread_join(thread_ids[i], NULL);
        close(client_socket[i]);
    }

    // Closing server socket
    close(server_socket);

    return 0;
}

void *handle_client(void *sock_fd) {
    int client_socket_fd = *(int *) sock_fd;
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    while (true) {
        ssize_t data_size = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);

        if (data_size == -1) {
            perror(""Failed to receive data from client"");
            break;
        } else if (data_size == 0) {
            printf(""Client disconnected\n"");
            break;
        }

        printf(""Received message from client: %s"", buffer);

        if (send(client_socket_fd, buffer, strlen(buffer), 0) == -1) {
            perror(""Failed to send message to client"");
            break;
        }

        // Resetting buffer
        memset(buffer, 0, BUFFER_SIZE);
    }

    close(client_socket_fd);
    pthread_exit(NULL);
}",120,6.5
VULNERABLE,falcon180b-49192.c,yes,21,5,handle_client,"
  file falcon180b-49192.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_connection'",dereference failure: accessed expired variable pointer,"    int sock;
    struct sockaddr_in address;
} connection_t;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: introspective
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CONNECTIONS 10

typedef struct {
    int sock;
    struct sockaddr_in address;
} connection_t;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message: %s\n"", buffer);
    }

    close(client_sock);
    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_sock, MAX_CONNECTIONS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        connection_t new_connection;
        socklen_t addr_size = sizeof(new_connection.address);

        if ((new_connection.sock = accept(server_sock, (struct sockaddr *) &new_connection.address, &addr_size)) == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &new_connection.sock);
    }

    close(server_sock);
    return 0;
}",81,4.5
VULNERABLE,falcon180b-809.c,yes,26,5,thread_func,"
  file falcon180b-809.c line 26 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
client_t clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_func(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

typedef struct {
    int sock;
    struct sockaddr_in addr;
    char name[20];
} client_t;

client_t clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_func(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_sock, buffer, bytes_received, 0);
    }

    close(client_sock);
    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_sock, 3) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(struct sockaddr_in);
        int client_sock = accept(server_sock, (struct sockaddr *) &clients[num_clients].addr, &addr_size);

        if (client_sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        inet_ntop(AF_INET, &clients[num_clients].addr.sin_addr, clients[num_clients].name, 20);
        clients[num_clients].sock = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_func, (void *) &client_sock);
    }

    return 0;
}",87,4.5
VULNERABLE,falcon180b-41619.c,yes,18,5,handle_client,"
  file falcon180b-41619.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Log analysis ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    accept_connections(server_socket);

    return 0;
}",79,3.333
VULNERABLE,falcon180b-59307.c,yes,19,5,thread,"
  file falcon180b-59307.c line 19 column 5 function thread
","
  c:@F@thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_sock'",dereference failure: accessed expired variable pointer,"int sock;
int addrlen = sizeof(struct sockaddr_in);
struct sockaddr_in serv_addr, cli_addr;

void *thread(void *socket) {
    int sock = *((int *) socket);
    char buffer[MAX];

    while(1) {
        bzero(buffer, MAX);
        int bytes_recv = recv(sock, buffer, MAX, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX 100

int sock;
int addrlen = sizeof(struct sockaddr_in);
struct sockaddr_in serv_addr, cli_addr;

void *thread(void *socket) {
    int sock = *((int *) socket);
    char buffer[MAX];

    while(1) {
        bzero(buffer, MAX);
        int bytes_recv = recv(sock, buffer, MAX, 0);
        if(bytes_recv <= 0) {
            break;
        }
        printf(""Thread %d received message: %s\n"", sock, buffer);
    }

    close(sock);
    pthread_exit(0);
}

int main() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock < 0) {
        printf(""Error: Unable to create socket\n"");
        exit(1);
    }

    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);

    if(bind(sock, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        printf(""Error: Unable to bind socket\n"");
        exit(1);
    }

    if(listen(sock, 5) < 0) {
        printf(""Error: Unable to listen on socket\n"");
        exit(1);
    }

    printf(""Server is listening on port %d\n"", PORT);

    while(1) {
        socklen_t addr_size = sizeof(cli_addr);
        int new_sock = accept(sock, (struct sockaddr *) &cli_addr, &addr_size);
        if(new_sock < 0) {
            printf(""Error: Unable to accept connection\n"");
            exit(1);
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread, (void *) &new_sock);
    }

    return 0;
}",72,4.5
VULNERABLE,falcon180b-46681.c,yes,19,5,handle_client,"
  file falcon180b-46681.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_client'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients;
int client_color[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Graph Coloring Problem ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MSG_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;
int client_color[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        // Broadcast the message to all other clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        socklen_t client_size = sizeof(client_sockets[0]);
        int new_client = accept(server_socket, (struct sockaddr *) &client_sockets[num_clients], &client_size);

        if (new_client > 0) {
            num_clients++;
            client_color[num_clients - 1] = 0;
            printf(""Client %d connected\n"", new_client);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &new_client);
        }
    }

    return 0;
}",74,4.0
VULNERABLE,gpt35-50000.c,yes,34,5,read_file,"
  file gpt35-50000.c line 34 column 5 function read_file
","
  c:@F@read_file at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `req'",dereference failure: accessed expired variable pointer,"void signal_handler(int sig) {
    should_stop = true;
}

void *read_file(void *arg) {
    read_request req = *(read_request*)arg;
    read_response res;
    res.fd = req.fd;
    res.buf = (char*) malloc(req.len);
    res.len = 0;
","//FormAI DATASET v1.0 Category: Text processing ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>

#define BUF_SIZE 1024

typedef struct {
    int fd;
    char *buf;
    size_t len;
} read_request;

typedef struct {
    int fd;
    char *buf;
    ssize_t len;
} read_response;

bool should_stop = false;

void signal_handler(int sig) {
    should_stop = true;
}

void *read_file(void *arg) {
    read_request req = *(read_request*)arg;
    read_response res;
    res.fd = req.fd;
    res.buf = (char*) malloc(req.len);
    res.len = 0;
    
    while (true) {
        ssize_t read_count = read(res.fd, res.buf + res.len, req.len - res.len);
        if (read_count < 0) {
            if (errno == EINTR) {
                continue;
            }
            perror(""read"");
            break;
        }
        if (read_count == 0) {
            break;
        }
        res.len += read_count;
    }
    
    return (void*) &res;
}

void *process_data(void *arg) {
    read_response res = *(read_response*)arg;
    char *buf = res.buf;
    ssize_t len = res.len;
    
    // Process data here
    printf(""Data read from file:\n%s\n"", buf);
    
    free(buf);
    return NULL;
}

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, ""Usage: %s file\n"", argv[0]);
        return EXIT_FAILURE;
    }
    
    signal(SIGINT, signal_handler);
    
    pthread_t read_thread;
    int fd = open(argv[1], O_RDONLY);
    if (fd < 0) {
        perror(""open"");
        return EXIT_FAILURE;
    }
    read_request req = { fd, (char*) malloc(BUF_SIZE), BUF_SIZE };
    if (pthread_create(&read_thread, NULL, read_file, (void*) &req) != 0) {
        perror(""pthread_create"");
        return EXIT_FAILURE;
    }
    
    while (!should_stop) {
        void *response;
        if (pthread_tryjoin_np(read_thread, &response) == 0) {
            pthread_t process_thread;
            if (pthread_create(&process_thread, NULL, process_data, response) != 0) {
                perror(""pthread_create"");
                return EXIT_FAILURE;
            }
            
            close(fd);
            return EXIT_SUCCESS;
        }
        
        sleep(1);
    }
    
    close(fd);
    return EXIT_SUCCESS;
}",108,3.5
VULNERABLE,falcon180b-5414.c,yes,18,5,handle_client,"
  file falcon180b-5414.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;
    int opt = 1;

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, BACKLOG) < 0) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        socklen_t client_size;
        int client_socket;

        if ((client_socket = accept(server_socket, NULL, &client_size)) < 0) {
            perror(""accept"");
            continue;
        }

        printf(""New client connected: %d\n"", client_socket);

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                pthread_t thread_id;
                pthread_create(&thread_id, NULL, handle_client, &client_socket);
                break;
            }
        }
    }

    return 0;
}",90,6.0
VULNERABLE,gemini_pro-33682.c,yes,152,17,main,"
  file gemini_pro-33682.c line 152 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `filename'",dereference failure: accessed expired variable pointer,"                }
                break;
            case 4:
                // Save an email to a file
                printf(""Enter the filename: "");
                scanf(""%s"", filename);
                save_email_to_file(email, filename);
                printf(""Email saved to file\n"");
                break;
            case 5:
                // Quit","//GEMINI-pro DATASET v1.0 Category: Email Client ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Structure to represent an email
typedef struct email {
    char *sender;
    char *recipient;
    char *subject;
    char *body;
} Email;

// Function to create a new email
Email *create_email(char *sender, char *recipient, char *subject, char *body) {
    Email *email = (Email *)malloc(sizeof(Email));
    email->sender = sender;
    email->recipient = recipient;
    email->subject = subject;
    email->body = body;
    return email;
}

// Function to send an email
void send_email(Email *email) {
    printf(""From: %s\n"", email->sender);
    printf(""To: %s\n"", email->recipient);
    printf(""Subject: %s\n"", email->subject);
    printf(""Body: %s\n"", email->body);
}

// Function to read an email from a file
Email *read_email_from_file(char *filename) {
    FILE *fp = fopen(filename, ""r"");
    if (fp == NULL) {
        return NULL;
    }

    // Read the sender
    char sender[100];
    fgets(sender, 100, fp);

    // Read the recipient
    char recipient[100];
    fgets(recipient, 100, fp);

    // Read the subject
    char subject[100];
    fgets(subject, 100, fp);

    // Read the body
    char body[1000];
    fgets(body, 1000, fp);

    // Create the email
    Email *email = create_email(sender, recipient, subject, body);

    // Close the file
    fclose(fp);

    return email;
}

// Function to save an email to a file
void save_email_to_file(Email *email, char *filename) {
    FILE *fp = fopen(filename, ""w"");
    if (fp == NULL) {
        return;
    }

    // Write the sender
    fprintf(fp, ""%s\n"", email->sender);

    // Write the recipient
    fprintf(fp, ""%s\n"", email->recipient);

    // Write the subject
    fprintf(fp, ""%s\n"", email->subject);

    // Write the body
    fprintf(fp, ""%s\n"", email->body);

    // Close the file
    fclose(fp);
}

// Function to print the menu
void print_menu() {
    printf(""1. Create a new email\n"");
    printf(""2. Send an email\n"");
    printf(""3. Read an email from a file\n"");
    printf(""4. Save an email to a file\n"");
    printf(""5. Quit\n"");
}

// Function to get the user's choice
int get_user_choice() {
    int choice;
    printf(""Enter your choice: "");
    scanf(""%d"", &choice);
    return choice;
}

// Main function
int main() {
    // Create an email client
    Email *email = NULL;

    // Loop until the user quits
    while (true) {
        // Print the menu
        print_menu();

        // Get the user's choice
        int choice = get_user_choice();

        // Handle the user's choice
        switch (choice) {
            case 1:
                // Create a new email
                email = create_email(NULL, NULL, NULL, NULL);
                printf(""Enter the sender: "");
                scanf(""%s"", email->sender);
                printf(""Enter the recipient: "");
                scanf(""%s"", email->recipient);
                printf(""Enter the subject: "");
                scanf(""%s"", email->subject);
                printf(""Enter the body: "");
                scanf(""%s"", email->body);
                break;
            case 2:
                // Send an email
                send_email(email);
                break;
            case 3:
                // Read an email from a file
                printf(""Enter the filename: "");
                char filename[100];
                scanf(""%s"", filename);
                email = read_email_from_file(filename);
                if (email == NULL) {
                    printf(""Error: could not read email from file\n"");
                } else {
                    printf(""Email read from file:\n"");
                    send_email(email);
                }
                break;
            case 4:
                // Save an email to a file
                printf(""Enter the filename: "");
                scanf(""%s"", filename);
                save_email_to_file(email, filename);
                printf(""Email saved to file\n"");
                break;
            case 5:
                // Quit
                return 0;
            default:
                // Invalid choice
                printf(""Invalid choice\n"");
        }
    }

    return 0;
}",166,2.286
VULNERABLE,gemini_pro-1786.c,yes,18,3,handle_client,"
  file gemini_pro-1786.c line 18 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `newsockfd'",dereference failure: accessed expired variable pointer,"int sockfd;
struct sockaddr_in serv_addr;

// Function to handle client connections
void *handle_client(void *arg) {
  int newsockfd = *(int *)arg;
  char buffer[256];

  // Receive data from the client
  int n = read(newsockfd, buffer, sizeof(buffer));
  if (n < 0) {","//GEMINI-pro DATASET v1.0 Category: Intrusion detection system ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

// Global variables
int sockfd;
struct sockaddr_in serv_addr;

// Function to handle client connections
void *handle_client(void *arg) {
  int newsockfd = *(int *)arg;
  char buffer[256];

  // Receive data from the client
  int n = read(newsockfd, buffer, sizeof(buffer));
  if (n < 0) {
    perror(""Error reading from socket"");
    exit(1);
  }

  // Check for suspicious activity
  if (strstr(buffer, ""DROP"") || strstr(buffer, ""DELETE"") || strstr(buffer, ""TRUNCATE"")) {
    // Log the suspicious activity
    printf(""Suspicious activity detected: %s\n"", buffer);

    // Send an alert to the administrator
    char message[256];
    sprintf(message, ""Suspicious activity detected: %s"", buffer);
    send(sockfd, message, strlen(message), 0);
  }

  // Close the client connection
  close(newsockfd);

  return NULL;
}

int main() {
  // Create a socket
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) {
    perror(""Error creating socket"");
    exit(1);
  }

  // Set up the server address
  memset(&serv_addr, 0, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_port = htons(5000);
  serv_addr.sin_addr.s_addr = INADDR_ANY;

  // Bind the socket to the server address
  if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
    perror(""Error binding socket"");
    exit(1);
  }

  // Listen for incoming connections
  if (listen(sockfd, 5) < 0) {
    perror(""Error listening on socket"");
    exit(1);
  }

  // Main loop
  while (1) {
    // Accept a new connection
    int newsockfd = accept(sockfd, (struct sockaddr *)NULL, NULL);
    if (newsockfd < 0) {
      perror(""Error accepting connection"");
      continue;
    }

    // Create a new thread to handle the client connection
    pthread_t tid;
    pthread_create(&tid, NULL, handle_client, (void *)&newsockfd);
  }

  // Close the server socket
  close(sockfd);

  return 0;
}",89,5.5
VULNERABLE,gemini_pro-643.c,yes,21,5,handle_client,"
  file gemini_pro-643.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"pthread_mutex_t mutex;

// Thread function to handle client requests
void *handle_client(void *arg) {
    // Get the client socket descriptor
    int client_fd = *(int *)arg;

    // Lock the mutex to ensure exclusive access to global variables
    pthread_mutex_lock(&mutex);

    // Read the HTTP request from the client","//GEMINI-pro DATASET v1.0 Category: Simple Web Server ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080

// Global variables
int server_fd;
struct sockaddr_in server_addr;
pthread_mutex_t mutex;

// Thread function to handle client requests
void *handle_client(void *arg) {
    // Get the client socket descriptor
    int client_fd = *(int *)arg;
    
    // Lock the mutex to ensure exclusive access to global variables
    pthread_mutex_lock(&mutex);
    
    // Read the HTTP request from the client
    char request[1024];
    int bytes_read = read(client_fd, request, sizeof(request));
    if (bytes_read == 0) {
        // Client closed the connection
        printf(""Client closed the connection\n"");
    } else if (bytes_read < 0) {
        // Error reading the request
        perror(""read"");
    } else {
        // Parse the HTTP request
        char *method = strtok(request, "" "");
        char *path = strtok(NULL, "" "");
        char *version = strtok(NULL, ""\r\n"");
        
        // Check if the request is valid
        if (strcmp(method, ""GET"") != 0) {
            // Invalid method
            printf(""Invalid method: %s\n"", method);
            write(client_fd, ""HTTP/1.1 405 Method Not Allowed\r\n\r\n"", 35);
        } else if (strcmp(version, ""HTTP/1.1"") != 0) {
            // Invalid version
            printf(""Invalid version: %s\n"", version);
            write(client_fd, ""HTTP/1.1 505 HTTP Version Not Supported\r\n\r\n"", 45);
        } else {
            // Valid request
            
            // Get the file path
            char file_path[1024];
            if (strcmp(path, ""/"") == 0) {
                strcpy(file_path, ""index.html"");
            } else {
                strcpy(file_path, path);
            }
            
            // Open the file
            FILE *file = fopen(file_path, ""r"");
            if (file == NULL) {
                // File not found
                printf(""File not found: %s\n"", file_path);
                write(client_fd, ""HTTP/1.1 404 Not Found\r\n\r\n"", 29);
            } else {
                // File found
                
                // Get the file size
                fseek(file, 0, SEEK_END);
                int file_size = ftell(file);
                fseek(file, 0, SEEK_SET);
                
                // Send the HTTP response header
                char header[1024];
                sprintf(header, ""HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n"", file_size);
                write(client_fd, header, strlen(header));
                
                // Send the file content
                char buffer[1024];
                while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
                    write(client_fd, buffer, bytes_read);
                }
                
                // Close the file
                fclose(file);
            }
        }
    }
    
    // Unlock the mutex
    pthread_mutex_unlock(&mutex);
    
    // Close the client socket
    close(client_fd);
    
    return NULL;
}

int main() {
    // Create the server socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror(""socket"");
        return EXIT_FAILURE;
    }
    
    // Set the server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // Bind the server socket to the server address
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        return EXIT_FAILURE;
    }
    
    // Listen for client connections
    if (listen(server_fd, 5) == -1) {
        perror(""listen"");
        return EXIT_FAILURE;
    }
    
    // Initialize the mutex
    pthread_mutex_init(&mutex, NULL);
    
    // Main loop
    while (1) {
        // Accept a client connection
        int client_fd = accept(server_fd, NULL, NULL);
        if (client_fd == -1) {
            perror(""accept"");
            continue;
        }
        
        // Create a new thread to handle the client request
        pthread_t tid;
        if (pthread_create(&tid, NULL, handle_client, &client_fd) != 0) {
            perror(""pthread_create"");
            close(client_fd);
            continue;
        }
    }
    
    // Close the server socket
    close(server_fd);
    
    // Destroy the mutex
    pthread_mutex_destroy(&mutex);
    
    return EXIT_SUCCESS;
}",155,7.5
VULNERABLE,gpt35-33298.c,yes,122,14,main,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file gpt35-33298.c line 122 column 14 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `state'",dereference failure: accessed expired variable pointer,"    else if (strcmp(switch1State, OFF) == 0 && strcmp(switch2State, OFF) == 0 && strcmp(switch3State, ON) == 0) {
      writeCommand(LIGHT1, OFF);
      writeCommand(LIGHT2, OFF);
      writeCommand(LIGHT3, BRIGHTEN);
    }
    else if (strcmp(switch1State, OFF) == 0 && strcmp(switch2State, OFF) == 0 && strcmp(switch3State, OFF) == 0) {
      writeCommand(LIGHT1, DIM);
      writeCommand(LIGHT2, DIM);
      writeCommand(LIGHT3, DIM);
    }
","//FormAI DATASET v1.0 Category: Smart home light control ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Define Light Control Commands
#define ON ""1""
#define OFF ""0""
#define DIM ""2""
#define BRIGHTEN ""3""

// Define Switch GPIO Pins
#define SWITCH1 2
#define SWITCH2 3
#define SWITCH3 4

// Define Light GPIO Pins
#define LIGHT1 17
#define LIGHT2 18
#define LIGHT3 19

// Define Function to Read Switch State
char* switchState(int pin) {
  FILE *fp;
  char state[5];

  // Open GPIO Value File
  fp = fopen(""/sys/class/gpio/gpio%d/value"", ""r"");
  if (fp == NULL) {
    printf(""Error: Unable to Open GPIO Value File\n"");
    exit(EXIT_FAILURE);
  }

  // Read State
  fgets(state, 5, fp);

  // Close File Pointer
  fclose(fp);

  return state;
}

// Define Function to Write Light Command
void writeCommand(int pin, char* command) {
  FILE *fp;

  // Open GPIO Direction File
  fp = fopen(""/sys/class/gpio/gpio%d/direction"", ""w"");
  if (fp == NULL) {
    printf(""Error: Unable to Open GPIO Direction File\n"");
    exit(EXIT_FAILURE);
  }

  // Set GPIO Direction to Output
  fprintf(fp, ""out"");

  // Close File Pointer
  fclose(fp);

  // Open GPIO Value File
  fp = fopen(""/sys/class/gpio/gpio%d/value"", ""w"");
  if (fp == NULL) {
    printf(""Error: Unable to Open GPIO Value File\n"");
    exit(EXIT_FAILURE);
  }

  // Write Command to GPIO Value File
  fprintf(fp, command);

  // Close File Pointer
  fclose(fp);
}

int main(void) {
  char* switch1State;
  char* switch2State;
  char* switch3State;

  // Set GPIO Pin Directions for Switches
  FILE *fp = fopen(""/sys/class/gpio/export"", ""w"");
  fprintf(fp, ""%d"", SWITCH1);
  fprintf(fp, ""%d"", SWITCH2);
  fprintf(fp, ""%d"", SWITCH3);
  fclose(fp);

  // Set GPIO Pin Directions for Lights
  fp = fopen(""/sys/class/gpio/export"", ""w"");
  fprintf(fp, ""%d"", LIGHT1);
  fprintf(fp, ""%d"", LIGHT2);
  fprintf(fp, ""%d"", LIGHT3);
  fclose(fp);

  // Loop Forever
  while(1) {
    // Read Switch States
    switch1State = switchState(SWITCH1);
    switch2State = switchState(SWITCH2);
    switch3State = switchState(SWITCH3);

    // Light Command Based on Switch States
    if (strcmp(switch1State, ON) == 0 && strcmp(switch2State, ON) == 0 && strcmp(switch3State, ON) == 0) {
      writeCommand(LIGHT1, BRIGHTEN);
      writeCommand(LIGHT2, BRIGHTEN);
      writeCommand(LIGHT3, BRIGHTEN);
    }
    else if (strcmp(switch1State, ON) == 0 && strcmp(switch2State, OFF) == 0 && strcmp(switch3State, OFF) == 0) {
      writeCommand(LIGHT1, BRIGHTEN);
      writeCommand(LIGHT2, OFF);
      writeCommand(LIGHT3, OFF);
    }
    else if (strcmp(switch1State, OFF) == 0 && strcmp(switch2State, ON) == 0 && strcmp(switch3State, OFF) == 0) {
      writeCommand(LIGHT1, OFF);
      writeCommand(LIGHT2, BRIGHTEN);
      writeCommand(LIGHT3, OFF);
    }
    else if (strcmp(switch1State, OFF) == 0 && strcmp(switch2State, OFF) == 0 && strcmp(switch3State, ON) == 0) {
      writeCommand(LIGHT1, OFF);
      writeCommand(LIGHT2, OFF);
      writeCommand(LIGHT3, BRIGHTEN);
    }
    else if (strcmp(switch1State, OFF) == 0 && strcmp(switch2State, OFF) == 0 && strcmp(switch3State, OFF) == 0) {
      writeCommand(LIGHT1, DIM);
      writeCommand(LIGHT2, DIM);
      writeCommand(LIGHT3, DIM);
    }

    // Delay for 1 Second
    sleep(1);
  }

  // Unexport GPIO Pins
  fp = fopen(""/sys/class/gpio/unexport"", ""w"");
  fprintf(fp, ""%d"", SWITCH1);
  fprintf(fp, ""%d"", SWITCH2);
  fprintf(fp, ""%d"", SWITCH3);
  fprintf(fp, ""%d"", LIGHT1);
  fprintf(fp, ""%d"", LIGHT2);
  fprintf(fp, ""%d"", LIGHT3);
  fclose(fp);

  return 0;
}",143,7.333
VULNERABLE,falcon180b-32697.c,yes,26,5,thread_func,"
  file falcon180b-32697.c line 26 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"
    // Wait for all threads to enter critical section
    pthread_cond_wait(&cond, &mutex);

    // Execute thread-specific task
    int thread_id = *(int *)arg;
    printf(""Thread %d has entered critical section\n"", thread_id);

    // Signal that this thread has finished
    finished++;
","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 5

// Mutex for critical section
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for synchronization
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Flag to indicate if all threads have finished
int finished = 0;

// Function to be executed by each thread
void *thread_func(void *arg) {
    // Lock the mutex before entering critical section
    pthread_mutex_lock(&mutex);

    // Wait for all threads to enter critical section
    pthread_cond_wait(&cond, &mutex);

    // Execute thread-specific task
    int thread_id = *(int *)arg;
    printf(""Thread %d has entered critical section\n"", thread_id);

    // Signal that this thread has finished
    finished++;

    // Unlock the mutex after leaving critical section
    pthread_mutex_unlock(&mutex);

    // Exit the thread
    return NULL;
}

int main() {
    // Create an array of threads
    pthread_t threads[NUM_THREADS];

    // Create each thread and pass its ID as argument
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void *)&i);
    }

    // Wait for all threads to finish
    while (finished < NUM_THREADS) {
        sleep(1);
    }

    // Print a message to indicate that all threads have finished
    printf(""All threads have finished\n"");

    // Exit the program
    return 0;
}",58,2.0
VULNERABLE,gpt35-9120.c,yes,88,5,connection_handler,"
  file gpt35-9120.c line 88 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *connection_handler(void *socket_ptr)
{
    int socket = *(int *)socket_ptr;
    int valread;
    char buffer[1024] = {0};
    char response[1024] = {0};

    // Receive message from client","//FormAI DATASET v1.0 Category: Client Server Application ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *connection_handler(void *);

int main()
{
    int server_fd;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    // Create socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    // Set socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
    {
        perror(""setsockopt failed"");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind socket to address and port
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, 3) < 0)
    {
        perror(""listen failed"");
        exit(EXIT_FAILURE);
    }

    printf(""Listening on port %d\n"", PORT);

    while (1)
    {
        int new_socket;
        struct sockaddr_in client_address;
        char *client_ip;

        if ((new_socket = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t *)&addrlen)) < 0)
        {
            perror(""accept failed"");
            exit(EXIT_FAILURE);
        }

        // Convert client IP to string format
        client_ip = inet_ntoa(client_address.sin_addr);

        printf(""New connection from %s:%d\n"", client_ip, ntohs(client_address.sin_port));

        pthread_t tid;
        if (pthread_create(&tid, NULL, connection_handler, (void *)&new_socket) < 0)
        {
            perror(""pthread_create failed"");
            exit(EXIT_FAILURE);
        }
    }

    return 0;
}

void *connection_handler(void *socket_ptr)
{
    int socket = *(int *)socket_ptr;
    int valread;
    char buffer[1024] = {0};
    char response[1024] = {0};

    // Receive message from client
    valread = read(socket, buffer, 1024);
    printf(""Received message from client: %s\n"", buffer);

    // Generate response message
    sprintf(response, ""Greetings, Cyberpunk! Your message was %d bytes long."", valread);
    printf(""Sending response message: %s\n"", response);

    // Send response message to client
    pthread_mutex_lock(&mutex);
    write(socket, response, strlen(response));
    pthread_mutex_unlock(&mutex);

    // Close socket and exit connection handler thread
    close(socket);
    pthread_exit(NULL);
}",109,4.5
VULNERABLE,falcon180b-58486.c,yes,17,5,handle_client,"
  file falcon180b-58486.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            close(client_socket_copy);
            num_clients--;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);
        for(int i = 0; i < num_clients; i++) {
            if(clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port 8080\n"");

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Please try again later.\n"");
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,4.0
VULNERABLE,codellama_13b-8839.c,yes,58,3,main,"
  file codellama_13b-8839.c line 58 column 3 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `password'",dereference failure: accessed expired variable pointer,"
  // Print the password
  printf(""Your unique password is: %s\n"", password);

  // Free the password
  free(password);

  return 0;
}","//Code Llama-13B DATASET v1.0 Category: Secure Password Generator ; Style: protected
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define MAX_PASSWORD_LENGTH 16

// Function to generate a random character
char generate_random_char(void) {
  return (char)(rand() % 26) + 'A';
}

// Function to generate a random number
int generate_random_num(void) {
  return rand() % 10;
}

// Function to generate a random special character
char generate_random_special_char(void) {
  char special_chars[] = ""!@#$%^&*()_+-=[]{}|;':\""<>,./?`~"";
  return special_chars[rand() % (sizeof(special_chars) - 1)];
}

// Function to generate a unique password
char *generate_unique_password(void) {
  char password[MAX_PASSWORD_LENGTH];
  int i;

  // Generate a random character
  password[0] = generate_random_char();

  // Generate a random number
  password[1] = generate_random_num();

  // Generate a random special character
  password[2] = generate_random_special_char();

  // Generate the rest of the password
  for (i = 3; i < MAX_PASSWORD_LENGTH; i++) {
    password[i] = generate_random_char();
  }

  return password;
}

int main(void) {
  // Set the random seed
  srand(time(NULL));

  // Generate a unique password
  char *password = generate_unique_password();

  // Print the password
  printf(""Your unique password is: %s\n"", password);

  // Free the password
  free(password);

  return 0;
}",61,1.2
VULNERABLE,falcon180b-58161.c,yes,24,5,handle_client,"
  file falcon180b-58161.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080
#define SERVER_IP ""127.0.0.1""

int server_socket = 0;
int client_sockets[MAX_CLIENTS] = { 0 };
int num_clients = 0;

pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        printf(""Client %d connected\n"", client_socket);
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        thread_ids[num_clients - 1] = thread_id;
    }
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == 0) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, 10) < 0) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections();

    return 0;
}",99,3.667
VULNERABLE,falcon180b-71855.c,yes,19,5,handle_client,"
  file falcon180b-71855.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            break;
        }
        printf(""Client %d says: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if(listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
        if(client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",83,5.0
VULNERABLE,falcon180b-62137.c,yes,20,5,handle_client,"
  file falcon180b-62137.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < client_count; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, BUFFER_SIZE, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr, client_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == 0) {
        printf(""Could not create socket\n"");
        return 1;
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Could not bind to port %d\n"", PORT);
        return 2;
    }

    if (listen(server_socket, BACKLOG) < 0) {
        printf(""Could not listen\n"");
        return 3;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket < 0) {
            printf(""Could not accept connection\n"");
            continue;
        }

        client_sockets[client_count] = client_socket;
        client_count++;

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",90,5.5
VULNERABLE,gemini_pro-19307.c,yes,52,5,main,"
  file gemini_pro-19307.c line 52 column 5 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `password'",dereference failure: accessed expired variable pointer,"
    // Print the password
    printf(""Your password is: %s\n"", password);

    // Free the memory allocated for the password
    free(password);

    return 0;
}","//GEMINI-pro DATASET v1.0 Category: Secure Password Generator ; Style: happy
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// Function to generate a random password
char *generate_password(int length) {
    // Create an array of characters
    char password[length + 1];
    password[length] = '\0'; // Null-terminate the string

    // Seed the random number generator
    srand(time(NULL));

    // Generate a random password
    for (int i = 0; i < length; i++) {
        // Generate a random character
        int random_char = rand() % 94 + 33; // Generate a random number between 33 and 126 (inclusive)

        // Check if the character is a special character
        if (random_char == 34 || random_char == 39 || random_char == 44 || random_char == 47 || random_char == 58 || random_char == 59 || random_char == 60 || random_char == 61 || random_char == 62 || random_char == 63 || random_char == 92 || random_char == 96 || random_char == 124) {
            // Generate a new random character
            random_char = rand() % 94 + 33;
        }

        // Add the character to the password
        password[i] = random_char;
    }

    // Return the password
    return password;
}

// Main function
int main() {
    // Declare variables
    int length;
    char *password;

    // Get the length of the password from the user
    printf(""Enter the length of the password you want to generate: "");
    scanf(""%d"", &length);

    // Generate a password
    password = generate_password(length);

    // Print the password
    printf(""Your password is: %s\n"", password);

    // Free the memory allocated for the password
    free(password);

    return 0;
}",55,8.0
VULNERABLE,falcon180b-18657.c,yes,19,5,handle_client,"
  file falcon180b-18657.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-20909.c,yes,20,5,handle_client,"
  file falcon180b-20909.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024
#define DELAY 1000

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        usleep(DELAY);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.0
VULNERABLE,falcon180b-21075.c,yes,25,5,handle_client,"
  file falcon180b-21075.c line 25 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *)socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *)socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    while (1) {
        printf(""Waiting for clients...\n"");

        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);

        client_sockets[num_clients++] = client_socket;
    }

    return 0;
}",84,4.5
VULNERABLE,falcon180b-10058.c,yes,45,13,hauntedHouse,"
  file falcon180b-10058.c line 45 column 13 function hauntedHouse
","
  c:@F@hauntedHouse at file falcon180b-10058.c line 11 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"            break;

        case 2:
            printf(""You find a mysterious puzzle.\n"");
            printf(""Do you want to solve it? (y/n)\n"");
            scanf("" %c"", &input);
            if(input == 'y')
            {
                printf(""You solve the puzzle and find a hidden treasure!\n"");
            }
            else","//Falcon-180B DATASET v1.0 Category: Haunted House Simulator ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void hauntedHouse();

int main()
{
    srand(time(NULL));
    hauntedHouse();
    return 0;
}

void hauntedHouse()
{
    int choice;
    printf(""Welcome to the Haunted House!\n"");
    printf(""What would you like to do?\n"");
    printf(""1. Explore the house\n"");
    printf(""2. Solve a puzzle\n"");
    printf(""3. Leave\n"");
    scanf(""%d"", &choice);

    switch(choice)
    {
        case 1:
            printf(""You enter the house and hear strange noises.\n"");
            printf(""Do you want to investigate? (y/n)\n"");
            char input;
            scanf("" %c"", &input);
            if(input == 'y')
            {
                printf(""You find a secret passage!\n"");
            }
            else
            {
                printf(""You leave the house.\n"");
            }
            break;

        case 2:
            printf(""You find a mysterious puzzle.\n"");
            printf(""Do you want to solve it? (y/n)\n"");
            scanf("" %c"", &input);
            if(input == 'y')
            {
                printf(""You solve the puzzle and find a hidden treasure!\n"");
            }
            else
            {
                printf(""You leave the house.\n"");
            }
            break;

        case 3:
            printf(""You leave the house.\n"");
            break;

        default:
            printf(""Invalid choice.\n"");
            break;
    }
}",64,3.5
VULNERABLE,falcon180b-10080.c,yes,19,5,handle_client,"
  file falcon180b-10080.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (num_clients >= MAX_CLIENTS) {
        printf(""Server is full. Please try again later.\n"");
        sleep(1);
    }

    int client_socket = accept(server_socket, NULL, NULL);
    client_sockets[num_clients] = client_socket;
    num_clients++;

    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

    return 0;
}",60,3.5
VULNERABLE,falcon180b-67521.c,yes,31,5,baggage_arrival,"
  file falcon180b-67521.c line 31 column 5 function baggage_arrival
","
  c:@F@baggage_arrival at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"        sleep(1);
    }
}

void *baggage_arrival(void *threadid) {
    int tid = *((int *) threadid);
    printf(""Baggage Arrival %d started\n"", tid);

    for (int i = 0; i < 20; i++) {
        pthread_mutex_lock(&mutex);
        bags_arrived++;","//Falcon-180B DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_BAGS 100
#define NUM_THREADS 5

int bags_arrived = 0;
int bags_handled = 0;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *baggage_handler(void *threadid) {
    int tid = *((int *) threadid);
    printf(""Baggage Handler %d started\n"", tid);

    while (1) {
        pthread_mutex_lock(&mutex);
        if (bags_arrived == NUM_BAGS) {
            printf(""Baggage Handler %d finished\n"", tid);
            pthread_exit(NULL);
        }
        pthread_mutex_unlock(&mutex);

        sleep(1);
    }
}

void *baggage_arrival(void *threadid) {
    int tid = *((int *) threadid);
    printf(""Baggage Arrival %d started\n"", tid);

    for (int i = 0; i < 20; i++) {
        pthread_mutex_lock(&mutex);
        bags_arrived++;
        printf(""Baggage Arrival %d arrived with bag %d\n"", tid, i);
        pthread_mutex_unlock(&mutex);

        sleep(1);
    }
}

int main() {
    pthread_t threads[NUM_THREADS];

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, baggage_arrival, (void *) &i);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",56,2.667
VULNERABLE,falcon180b-40125.c,yes,17,5,handle_client,"
  file falcon180b-40125.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 5
#define PORT 5000

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        recv(client_socket, buffer, sizeof(buffer), 0);

        if (strcmp(buffer, ""on"") == 0) {
            for (int i = 0; i < num_clients; i++) {
                if (clients[i]!= client_socket) {
                    send(clients[i], ""on"", sizeof(""on""), 0);
                }
            }
        } else if (strcmp(buffer, ""off"") == 0) {
            for (int i = 0; i < num_clients; i++) {
                if (clients[i]!= client_socket) {
                    send(clients[i], ""off"", sizeof(""off""), 0);
                }
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full"", sizeof(""Server full""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",74,5.5
VULNERABLE,falcon180b-59546.c,yes,16,5,handle_client,"
  file falcon180b-59546.c line 16 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Graph representation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,4.0
VULNERABLE,falcon180b-60364.c,yes,17,5,handle_client,"
  file falcon180b-60364.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080...\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",65,3.0
VULNERABLE,falcon180b-770.c,yes,18,5,handle_client,"
  file falcon180b-770.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",83,5.0
VULNERABLE,falcon180b-22640.c,yes,19,5,handle_client,"
  file falcon180b-22640.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(3000);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 3000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 11, 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            num_clients++;
        }
    }

    return 0;
}",67,3.0
VULNERABLE,falcon180b-58679.c,yes,21,5,handle_client,"
  file falcon180b-58679.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"struct sockaddr_in client_addr[MAX_CLIENTS];
int client_sock[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *)arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_sock, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int sock;
struct sockaddr_in server_addr;
struct sockaddr_in client_addr[MAX_CLIENTS];
int client_sock[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *)arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_sock, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d said: %s\n"", client_sock, buffer);
        send(client_sock, buffer, strlen(buffer), 0);
    }
    close(client_sock);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(sock, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_sock = accept(sock, (struct sockaddr *)&client_addr[num_clients], sizeof(client_addr[num_clients]));
        if (client_sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client %d connected\n"", client_sock);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_sock);
        num_clients++;
    }

    return 0;
}",62,3.0
VULNERABLE,falcon180b-45817.c,yes,19,5,handle_client,"
  file falcon180b-45817.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: energetic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = 0;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-63851.c,yes,18,5,handle_client,"
  file falcon180b-63851.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-17765.c,yes,20,5,handle_client,"
  file falcon180b-17765.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received == 0) {
            close(client_socket);
            pthread_exit(0);
        }

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Chat server started on port %d\n"", SERVER_PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,4.0
VULNERABLE,falcon180b-26671.c,yes,20,5,handle_client,"
  file falcon180b-26671.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MESSAGE_LENGTH];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_LENGTH);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_LENGTH, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MESSAGE_LENGTH 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MESSAGE_LENGTH];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_LENGTH);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_LENGTH, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        char *message = strtok(buffer, "" "");
        send(client_socket, message, strlen(message), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        socklen_t client_size = sizeof(client_sockets[num_clients]);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_sockets[num_clients], &client_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
        } else {
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            num_clients++;
        }
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-40658.c,yes,19,5,handle_client,"
  file falcon180b-40658.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    bzero(request, MAX_REQUEST_SIZE);

    while (recv(client_socket, request, MAX_REQUEST_SIZE, 0) > 0) {
        printf(""Request from client %d: %s\n"", client_socket, request);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024
#define BACKLOG 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    bzero(request, MAX_REQUEST_SIZE);

    while (recv(client_socket, request, MAX_REQUEST_SIZE, 0) > 0) {
        printf(""Request from client %d: %s\n"", client_socket, request);
        // Parse the request and send a response
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;
    int opt = 1;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket;
        socklen_t client_size;

        client_socket = accept(server_socket, NULL, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,4.5
VULNERABLE,falcon180b-52240.c,yes,19,5,handle_client,"
  file falcon180b-52240.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sockfd'",dereference failure: accessed expired variable pointer,"int g_sockfd;
struct sockaddr_in g_servaddr;
pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_sockfd = *(int *)arg;
    char buf[MAX_REQUEST_SIZE];

    while (1) {
        memset(buf, 0, sizeof(buf));
        if (recv(client_sockfd, buf, MAX_REQUEST_SIZE, 0) <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_REQUEST_SIZE 1024

int g_sockfd;
struct sockaddr_in g_servaddr;
pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_sockfd = *(int *)arg;
    char buf[MAX_REQUEST_SIZE];

    while (1) {
        memset(buf, 0, sizeof(buf));
        if (recv(client_sockfd, buf, MAX_REQUEST_SIZE, 0) <= 0) {
            break;
        }

        pthread_mutex_lock(&g_mutex);
        printf(""Client %d: %s\n"", client_sockfd, buf);
        pthread_mutex_unlock(&g_mutex);
    }

    close(client_sockfd);
    return NULL;
}

int main() {
    pthread_t tid;
    int opt = 1;
    int addrlen = sizeof(g_servaddr);

    g_sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (g_sockfd == -1) {
        printf(""socket failed\n"");
        exit(1);
    }

    setsockopt(g_sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));

    g_servaddr.sin_family = AF_INET;
    g_servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    g_servaddr.sin_port = htons(PORT);

    if (bind(g_sockfd, (struct sockaddr *)&g_servaddr, addrlen) == -1) {
        printf(""bind failed\n"");
        exit(1);
    }

    if (listen(g_sockfd, BACKLOG) == -1) {
        printf(""listen failed\n"");
        exit(1);
    }

    while (1) {
        int client_sockfd = accept(g_sockfd, (struct sockaddr *)&g_servaddr, &addrlen);
        if (client_sockfd == -1) {
            printf(""accept failed\n"");
            exit(1);
        }

        printf(""Client connected: %d\n"", client_sockfd);

        pthread_create(&tid, NULL, handle_client, (void *)&client_sockfd);
    }

    return 0;
}",77,4.5
VULNERABLE,gpt35-44427.c,yes,86,9,main,"
  file gpt35-44427.c line 86 column 9 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `account_number'",dereference failure: accessed expired variable pointer,"        insert_record(account_number, account_holder_name, balance);
        printf(""\nNew account added!\n\n"");
        break;
      case 2:
        printf(""Please enter the account number to delete:\n"");
        scanf(""%d"", &account_number);
        delete_record(account_number);
        printf(""\nAccount deleted!\n\n"");
        break;
      case 3:
        printf(""\n"");","//FormAI DATASET v1.0 Category: Banking Record System ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct bank_record {
  int account_number;
  char account_holder_name[50];
  float balance;
  struct bank_record *next;
} BankRecord;

BankRecord *head = NULL;

void insert_record(int account_number, char *account_holder_name, float balance) {
  BankRecord *new_record = malloc(sizeof(BankRecord));
  new_record->account_number = account_number;
  strcpy(new_record->account_holder_name, account_holder_name);
  new_record->balance = balance;
  if (head == NULL) {
    head = new_record;
    new_record->next = NULL;
  } else {
    new_record->next = head;
    head = new_record;
  }
}

void delete_record(int account_number) {
  BankRecord *current_record = head;
  BankRecord *previous_record = NULL;
  while (current_record != NULL) {
    if (current_record->account_number == account_number) {
      if (previous_record == NULL) {
        head = current_record->next;
      } else {
        previous_record->next = current_record->next;
      }
      free(current_record);
      return;
    }
    previous_record = current_record;
    current_record = current_record->next;
  }
}

void print_records() {
  BankRecord *current_record = head;
  printf(""Account Number  Account Holder Name      Balance\n"");
  printf(""------------------------------------------------\n"");
  while (current_record != NULL) {
    printf(""%-15d%-25s$%.2f\n"", current_record->account_number, current_record->account_holder_name, current_record->balance);
    current_record = current_record->next;
  }
}

int main() {
  srand(time(NULL));
  printf(""Welcome to the Surreal Bank Record System!\n"");
  printf(""Where every account is an imaginary friend.\n\n"");
  while (1) {
    printf(""What would you like to do?\n"");
    printf(""1. Add a new account\n"");
    printf(""2. Delete an existing account\n"");
    printf(""3. View all accounts\n"");
    printf(""4. QUIT\n"");
    int choice;
    scanf(""%d"", &choice);
    switch (choice) {
      case 1:
        printf(""Please enter the account number:\n"");
        int account_number;
        scanf(""%d"", &account_number);
        printf(""Please enter the account holder name:\n"");
        char account_holder_name[50];
        scanf(""%s"", account_holder_name);
        printf(""Please enter the starting balance:\n"");
        float balance;
        scanf(""%f"", &balance);
        insert_record(account_number, account_holder_name, balance);
        printf(""\nNew account added!\n\n"");
        break;
      case 2:
        printf(""Please enter the account number to delete:\n"");
        scanf(""%d"", &account_number);
        delete_record(account_number);
        printf(""\nAccount deleted!\n\n"");
        break;
      case 3:
        printf(""\n"");
        print_records();
        printf(""\n"");
        break;
      case 4:
        printf(""Thank you for using the Surreal Bank Record System!\n"");
        return 0;
      default:
        printf(""Invalid choice\n"");
        break;
    }
  }
}",103,3.5
VULNERABLE,codellama_13b-4826.c,yes,61,9,main,"
  file codellama_13b-4826.c line 61 column 9 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `device_name'",dereference failure: accessed expired variable pointer,"        printf(""\n"");
    }

    // Clean up the devices
    for (int i = 0; i < MAX_DEVICES; i++) {
        free(devices[i].name);
    }

    return 0;
}","//Code Llama-13B DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: Dennis Ritchie
/*
 * Wi-Fi Signal Strength Analyzer
 *
 * Written by: [Your Name]
 * Date: [Current Date]
 *
 * This program analyzes the Wi-Fi signal strength in a given location.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_DEVICES 10

typedef struct {
    char *name;
    int strength;
} device_t;

int main(void) {
    device_t devices[MAX_DEVICES];
    int num_devices = 0;

    // Initialize the devices
    for (int i = 0; i < MAX_DEVICES; i++) {
        devices[i].name = (char *)malloc(sizeof(char) * 32);
        devices[i].strength = 0;
    }

    // Add devices to the list
    while (1) {
        char device_name[32];
        int device_strength;

        printf(""Enter device name (or 'q' to quit): "");
        scanf(""%s"", device_name);

        if (strcmp(device_name, ""q"") == 0) {
            break;
        }

        printf(""Enter device strength: "");
        scanf(""%d"", &device_strength);

        devices[num_devices].name = device_name;
        devices[num_devices].strength = device_strength;
        num_devices++;
    }

    // Analyze the devices
    for (int i = 0; i < num_devices; i++) {
        printf(""Device: %s\n"", devices[i].name);
        printf(""Strength: %d\n"", devices[i].strength);
        printf(""\n"");
    }

    // Clean up the devices
    for (int i = 0; i < MAX_DEVICES; i++) {
        free(devices[i].name);
    }

    return 0;
}",65,6.0
VULNERABLE,falcon180b-26790.c,yes,19,5,handle_client,"
  file falcon180b-26790.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1000

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",78,4.5
VULNERABLE,llama2-13B_1233.c,yes,38,5,is_password_valid,"
  file llama2-13B_1233.c line 38 column 5 function is_password_valid
","
  c:@F@is_password_valid at file llama2-13B_1233.c line 65 column 9 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `password_characters'",dereference failure: accessed expired variable pointer,"}

// Function to check if a password is valid
int is_password_valid(password_info *password) {
    // Check if the password is not empty and has the minimum length
    if (password->password_length >= PASSWORD_MIN_LENGTH && password->password[0] != '\0') {
        // Check if the password is not too old (i.e., it has not been used recently)
        if (time(NULL) - password->last_used < 30 * 24 * 60 * 60) {
            return 1; // Password is valid
        } else {
            return 0; // Password is not valid (too old)","//LLAMA2-13B DATASET v1.0 Category: Password management ; Style: safe
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define PASSWORD_MIN_LENGTH 12
#define PASSWORD_MAX_LENGTH 100

// Structure to store password information
typedef struct {
    char *password; // Password as a character array
    int password_length; // Length of the password
    int last_used; // Timestamp of last use (in seconds)
} password_info;

// Function to generate a secure password
void generate_password(password_info *password) {
    int i, j, length;
    char password_characters[PASSWORD_MAX_LENGTH];

    // Generate a random password using a mix of characters
    for (i = 0; i < PASSWORD_MAX_LENGTH; i++) {
        password_characters[i] = (i % 2) ? 'A' + (rand() % 26) : 'a' + (rand() % 26);
    }

    // Store the generated password in the password structure
    password->password = password_characters;
    password->password_length = strlen(password->password);

    // Set the last use timestamp to the current time
    password->last_used = time(NULL);
}

// Function to check if a password is valid
int is_password_valid(password_info *password) {
    // Check if the password is not empty and has the minimum length
    if (password->password_length >= PASSWORD_MIN_LENGTH && password->password[0] != '\0') {
        // Check if the password is not too old (i.e., it has not been used recently)
        if (time(NULL) - password->last_used < 30 * 24 * 60 * 60) {
            return 1; // Password is valid
        } else {
            return 0; // Password is not valid (too old)
        }
    } else {
        return 0; // Password is not valid (too short or empty)
    }
}

// Function to print the password
void print_password(password_info *password) {
    printf(""Password: %s\n"", password->password);
}

int main() {
    password_info password;

    // Generate a secure password
    generate_password(&password);

    // Print the password
    print_password(&password);

    // Check if the password is valid
    if (is_password_valid(&password)) {
        printf(""Password is valid\n"");
    } else {
        printf(""Password is not valid\n"");
    }

    return 0;
}",72,2.5
VULNERABLE,gemini_pro-724.c,yes,58,9,main,"
  file gemini_pro-724.c line 58 column 9 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `years'",dereference failure: accessed expired variable pointer,"        travelToFuture(&timeMachine, years);
        break;
      case 2:
        // Travel to the past
        printf(""Enter the number of years to travel to the past: "");
        scanf(""%d"", &years);
        travelToPast(&timeMachine, years);
        break;
      case 3:
        // Get the current time
        getCurrentTime(&timeMachine);","//GEMINI-pro DATASET v1.0 Category: Time Travel Simulator ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define the time machine
typedef struct {
  int year;
  int month;
  int day;
} TimeMachine;

// Initialize the time machine
TimeMachine timeMachine = {2023, 1, 1};

// Travel to the future
void travelToFuture(TimeMachine *tm, int years) {
  tm->year += years;
}

// Travel to the past
void travelToPast(TimeMachine *tm, int years) {
  tm->year -= years;
}

// Get the current time
void getCurrentTime(TimeMachine *tm) {
  printf(""Current time: %d-%d-%d\n"", tm->year, tm->month, tm->day);
}

// Main function
int main() {
  // Print the welcome message
  printf(""Welcome to the Time Travel Simulator!\n"");

  // Get the user's input
  int choice;
  while (1) {
    printf(""Enter your choice:\n"");
    printf(""1. Travel to the future\n"");
    printf(""2. Travel to the past\n"");
    printf(""3. Get the current time\n"");
    printf(""4. Exit\n"");
    scanf(""%d"", &choice);

    // Process the user's choice
    switch (choice) {
      case 1:
        // Travel to the future
        printf(""Enter the number of years to travel to the future: "");
        int years;
        scanf(""%d"", &years);
        travelToFuture(&timeMachine, years);
        break;
      case 2:
        // Travel to the past
        printf(""Enter the number of years to travel to the past: "");
        scanf(""%d"", &years);
        travelToPast(&timeMachine, years);
        break;
      case 3:
        // Get the current time
        getCurrentTime(&timeMachine);
        break;
      case 4:
        // Exit the program
        printf(""Goodbye!\n"");
        return 0;
      default:
        // Invalid choice
        printf(""Invalid choice. Please enter a number between 1 and 4.\n"");
        break;
    }
  }

  return 0;
}",77,2.25
VULNERABLE,gemini_pro-24350.c,yes,20,5,client_thread,"
  file gemini_pro-24350.c line 20 column 5 function client_thread
","
  c:@F@client_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientfd'",dereference failure: accessed expired variable pointer,"int sockfd;
struct sockaddr_in serv_addr;
char buf[1024];

void *client_thread(void *arg) {
    int clientfd = *(int *)arg;
    while (1) {
        memset(buf, 0, sizeof(buf));
        if (recv(clientfd, buf, sizeof(buf), 0) == -1) {
            perror(""recv"");
            exit(EXIT_FAILURE);","//GEMINI-pro DATASET v1.0 Category: Building a IMAP Client ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 143
#define MAX_CLIENTS 10

int sockfd;
struct sockaddr_in serv_addr;
char buf[1024];

void *client_thread(void *arg) {
    int clientfd = *(int *)arg;
    while (1) {
        memset(buf, 0, sizeof(buf));
        if (recv(clientfd, buf, sizeof(buf), 0) == -1) {
            perror(""recv"");
            exit(EXIT_FAILURE);
        }
        printf(""%s\n"", buf);
        if (strcmp(buf, ""QUIT"") == 0) {
            close(clientfd);
            break;
        }
        memset(buf, 0, sizeof(buf));
        strcpy(buf, ""Hello from server"");
        if (send(clientfd, buf, sizeof(buf), 0) == -1) {
            perror(""send"");
            exit(EXIT_FAILURE);
        }
    }
    return NULL;
}

int main() {
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);
    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }
    if (listen(sockfd, MAX_CLIENTS) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }
    pthread_t threads[MAX_CLIENTS];
    int clientfds[MAX_CLIENTS];
    int i = 0;
    while (1) {
        int clientfd = accept(sockfd, NULL, NULL);
        if (clientfd == -1) {
            perror(""accept"");
            continue;
        }
        clientfds[i++] = clientfd;
        if (pthread_create(&threads[i], NULL, client_thread, (void *)&clientfd) != 0) {
            perror(""pthread_create"");
            exit(EXIT_FAILURE);
        }
    }
    for (i = 0; i < MAX_CLIENTS; i++) {
        pthread_join(threads[i], NULL);
    }
    close(sockfd);
    return 0;
}",80,6.5
VULNERABLE,codellama_13b-10984.c,yes,63,9,printSubarrays,"
  file codellama_13b-10984.c line 63 column 9 function printSubarrays
","
  c:@F@printSubarrays at file codellama_13b-10984.c line 73 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `subarrays'",dereference failure: accessed expired variable pointer,"}

// Function to print the subarrays array
void printSubarrays(Subarray* subarrays, int n) {
    for (int i = 0; i < n; i++) {
        printf(""Subarray %d: %d %d %d\n"", i, subarrays[i].start, subarrays[i].end, subarrays[i].sum);
    }
}

int main() {
    // Initialize the input array","//Code Llama-13B DATASET v1.0 Category: Greedy Algorithms ; Style: optimized
/*
 * A greedy algorithm to find the maximum sum of non-overlapping subarrays with given constraints
 * Time complexity: O(n)
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <limits.h>

#define MAX_SUBARRAYS 100
#define MAX_ELEMENTS 1000

// Structure to represent a subarray
typedef struct {
    int start;
    int end;
    int sum;
} Subarray;

// Function to find the maximum sum of non-overlapping subarrays
Subarray* maxSubarraySum(int* arr, int n, int m) {
    // Initialize the maximum sum to 0
    int max_sum = 0;
    // Initialize the number of subarrays to 0
    int num_subarrays = 0;
    // Initialize the subarrays array
    Subarray subarrays[MAX_SUBARRAYS];
    // Initialize the current subarray
    Subarray curr_subarray;
    curr_subarray.start = 0;
    curr_subarray.end = 0;
    curr_subarray.sum = 0;
    // Iterate through the input array
    for (int i = 0; i < n; i++) {
        // If the current subarray sum is less than the maximum sum, add the current element to the subarray
        if (curr_subarray.sum < max_sum) {
            curr_subarray.end = i;
            curr_subarray.sum += arr[i];
        }
        // If the current subarray sum is greater than the maximum sum, add the current subarray to the subarrays array and start a new subarray
        else {
            subarrays[num_subarrays++] = curr_subarray;
            curr_subarray.start = i;
            curr_subarray.end = i;
            curr_subarray.sum = arr[i];
        }
        // If the current subarray sum is greater than the maximum sum, set the maximum sum to the current subarray sum
        if (curr_subarray.sum > max_sum) {
            max_sum = curr_subarray.sum;
        }
    }
    // Add the final subarray to the subarrays array
    subarrays[num_subarrays++] = curr_subarray;
    // Return the subarrays array
    return subarrays;
}

// Function to print the subarrays array
void printSubarrays(Subarray* subarrays, int n) {
    for (int i = 0; i < n; i++) {
        printf(""Subarray %d: %d %d %d\n"", i, subarrays[i].start, subarrays[i].end, subarrays[i].sum);
    }
}

int main() {
    // Initialize the input array
    int arr[MAX_ELEMENTS] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    // Find the maximum sum of non-overlapping subarrays
    Subarray* subarrays = maxSubarraySum(arr, 10, 3);
    // Print the subarrays array
    printSubarrays(subarrays, 3);
    return 0;
}",75,2.333
VULNERABLE,falcon180b-2609.c,yes,21,5,listen_thread,"
  file falcon180b-2609.c line 21 column 5 function listen_thread
","
  c:@F@listen_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `listen_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *listen_thread(void *arg) {
    int listen_socket = *(int *)arg;
    int new_socket;
    struct sockaddr_in client_addr;
    socklen_t addr_size = sizeof(client_addr);

    while (1) {","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MESSAGE_LENGTH 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *listen_thread(void *arg) {
    int listen_socket = *(int *)arg;
    int new_socket;
    struct sockaddr_in client_addr;
    socklen_t addr_size = sizeof(client_addr);

    while (1) {
        new_socket = accept(listen_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (new_socket == -1) {
            printf(""Error accepting connection: %s\n"", strerror(errno));
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(new_socket);
            printf(""Too many clients\n"");
            continue;
        }

        client_sockets[num_clients++] = new_socket;
        printf(""Client connected on socket %d\n"", new_socket);
    }

    return NULL;
}

void broadcast_message(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (i == sender_socket)
            continue;

        send(client_sockets[i], message, strlen(message), 0);
    }
}

int main() {
    int listen_socket;
    int opt = 1;
    struct sockaddr_in server_addr;

    if ((listen_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        printf(""Error creating socket: %s\n"", strerror(errno));
        exit(1);
    }

    setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(3000);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(listen_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket: %s\n"", strerror(errno));
        exit(1);
    }

    if (listen(listen_socket, 10) == -1) {
        printf(""Error listening on socket: %s\n"", strerror(errno));
        exit(1);
    }

    printf(""Server listening on port 3000\n"");

    pthread_t thread_id;
    pthread_create(&thread_id, NULL, listen_thread, (void *)&listen_socket);

    while (1) {
        char buffer[MAX_MESSAGE_LENGTH];
        int bytes_received;

        if ((bytes_received = recv(STDIN_FILENO, buffer, MAX_MESSAGE_LENGTH, 0)) == -1) {
            printf(""Error receiving message: %s\n"", strerror(errno));
            continue;
        }

        if (bytes_received == 0) {
            printf(""Connection closed\n"");
            break;
        }

        buffer[bytes_received - 1] = '\0';
        broadcast_message(STDIN_FILENO, buffer);
    }

    close(listen_socket);
    return 0;
}",107,4.667
VULNERABLE,falcon180b-55066.c,yes,22,5,handle_client,"
  file falcon180b-55066.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int sock = *(int *) socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 100
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int sock = *(int *) socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", sock, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= sock) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(sock);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",93,6.0
VULNERABLE,falcon180b-16264.c,yes,17,5,handle_client,"
  file falcon180b-16264.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: standalone
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server full\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-10666.c,yes,17,5,handle_client,"
  file falcon180b-10666.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int server_socket, client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket, client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return -1;
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        return -1;
    }

    printf(""Server started on port 8080\n"");
    accept_connections();

    return 0;
}",87,3.333
VULNERABLE,falcon180b-13115.c,yes,21,5,handle_client,"
  file falcon180b-13115.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define BUF_SIZE 1024
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, BACKLOG);

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",70,3.5
VULNERABLE,falcon180b-40826.c,yes,19,5,handle_client,"
  file falcon180b-40826.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define SERVER_PORT 8080
#define SERVER_IP ""127.0.0.1""

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", SERVER_PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();

    return 0;
}",89,3.667
VULNERABLE,falcon180b-5154.c,yes,21,5,handle_client,"
  file falcon180b-5154.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        send(client_socket, buffer, strlen(buffer), 0);
    }
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return -1;
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return -1;
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        return -1;
    }

    printf(""Chat server started on port %d\n"", PORT);

    accept_connections();

    return 0;
}",92,3.667
VULNERABLE,falcon180b-31463.c,yes,17,5,thread_func,"
  file falcon180b-31463.c line 17 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Global data shared by threads
int shared_data = 0;

// Function executed by each thread
void *thread_func(void *arg) {
    int id = *(int*) arg;
    printf(""Thread %d started\n"", id);

    // Lock the mutex before accessing shared data
    pthread_mutex_lock(&mutex);
","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex for synchronization
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for signaling
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Global data shared by threads
int shared_data = 0;

// Function executed by each thread
void *thread_func(void *arg) {
    int id = *(int*) arg;
    printf(""Thread %d started\n"", id);

    // Lock the mutex before accessing shared data
    pthread_mutex_lock(&mutex);

    // Wait for turn using condition variable
    printf(""Thread %d is waiting...\n"", id);
    pthread_cond_wait(&cond, &mutex);

    // Update shared data
    shared_data++;
    printf(""Thread %d updated shared data to %d\n"", id, shared_data);

    // Signal next thread
    pthread_cond_signal(&cond);

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main() {
    int num_threads = 5;
    pthread_t threads[num_threads];

    // Create threads
    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void*) &i);
    }

    // Join threads
    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",55,2.0
VULNERABLE,falcon180b-19415.c,yes,20,5,thread_handler,"
  file falcon180b-19415.c line 20 column 5 function thread_handler
","
  c:@F@thread_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_handler(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_handler(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(server_socket, 5);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later. "", 46, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_handler, (void *)&client_socket);
    }

    return 0;
}",73,3.5
VULNERABLE,gpt35-11855.c,yes,65,3,connection_handler,"
  file gpt35-11855.c line 65 column 3 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"  close(server_fd);
  return 0;
}

void *connection_handler(void *socket_ptr) {
  int socket = *(int *)socket_ptr;
  char buffer[1024];
  int msg_len;

  // Send welcome message to connected client
  char *welcome_msg = ""Welcome to the chat server! Type 'exit' to disconnect."";","//FormAI DATASET v1.0 Category: Chat server ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

void *connection_handler(void *);

int main(int argc, char **argv) {

  int server_fd, new_socket, c;
  struct sockaddr_in server, client;

  // Create socket
  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror(""Socket Creation Failed"");
    exit(EXIT_FAILURE);
  }

  // Assign IP, PORT
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = htons(PORT);

  // Bind the socket with the server address
  if (bind(server_fd, (struct sockaddr *)&server, sizeof(server)) < 0) {
    perror(""Bind Failed"");
    exit(EXIT_FAILURE);
  }

  // Listen for incoming connections
  if (listen(server_fd, 3) < 0) {
    perror(""Listen Failed"");
    exit(EXIT_FAILURE);
  }

  printf(""Server listening on port %d\n"", PORT);

  c = sizeof(struct sockaddr_in);
  while ((new_socket = accept(server_fd, (struct sockaddr *)&client, (socklen_t *)&c))) {
    printf(""Connection accepted from %s:%d\n"", inet_ntoa(client.sin_addr), ntohs(client.sin_port));

    pthread_t thread_id;
    if (pthread_create(&thread_id, NULL, connection_handler, (void *)&new_socket) < 0) {
      perror(""Thread Creation Failed"");
      return 1;
    }
  }

  if (new_socket < 0) {
    perror(""Accept Failed"");
    exit(EXIT_FAILURE);
  }

  close(server_fd);
  return 0;
}

void *connection_handler(void *socket_ptr) {
  int socket = *(int *)socket_ptr;
  char buffer[1024];
  int msg_len;

  // Send welcome message to connected client
  char *welcome_msg = ""Welcome to the chat server! Type 'exit' to disconnect."";
  write(socket, welcome_msg, strlen(welcome_msg));

  while ((msg_len = read(socket, buffer, 1024)) > 0) {
    buffer[msg_len - 1] = '\0';   // Remove '\n' at the end of the message
    if (strcmp(buffer, ""exit"") == 0)
      break;   // Disconnect client if 'exit' is typed

    // Broadcast message to all connected clients
    printf(""[%d] %s\n"", socket, buffer);
    for (int i = 4; i < 1024; i++) {
      if (i == socket)
        continue;
      if (write(i, buffer, strlen(buffer)) < 0) {
        perror(""Write Failed"");
        break;
      }
    }
  }

  // Disconnect client
  printf(""Connection closed from %d\n"", socket);
  close(socket);
  return NULL;
}",94,6.5
VULNERABLE,gpt35-20823.c,yes,60,5,handle_client,"
  file gpt35-20823.c line 60 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"    close(server_fd);
    return 0;
}

void* handle_client(void* arg) {
    int client_fd = *(int*)arg;

    char buffer[BUFSIZE] = {0};
    int valread = read(client_fd, buffer, BUFSIZE);

    if (valread == -1) {","//FormAI DATASET v1.0 Category: Stock market tracker ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 12345
#define BUFSIZE 1024
#define TICKERSIZE 10

void* handle_client(void* arg);

int main(int argc, char* argv[]) {

    // Create socket
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        printf(""Failed to create socket.\n"");
        exit(EXIT_FAILURE);
    }

    // Configure address
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind to socket
    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) == -1) {
        printf(""Failed to bind to socket.\n"");
        exit(EXIT_FAILURE);
    }

    // Listen for clients
    if (listen(server_fd, 3) == -1) {
        printf(""Failed to listen for clients.\n"");
        exit(EXIT_FAILURE);
    }

    printf(""Stock market tracker server listening on port %d...\n"", PORT);

    // Handle clients in separate threads
    while (1) {
        int client_fd = accept(server_fd, (struct sockaddr*)NULL, NULL);
        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, handle_client, (void*)&client_fd) != 0) {
            printf(""Failed to create thread for client.\n"");
            exit(EXIT_FAILURE);
        }
    }

    close(server_fd);
    return 0;
}

void* handle_client(void* arg) {
    int client_fd = *(int*)arg;

    char buffer[BUFSIZE] = {0};
    int valread = read(client_fd, buffer, BUFSIZE);

    if (valread == -1) {
        printf(""Failed to read from client.\n"");
        exit(EXIT_FAILURE);
    }

    char ticker[TICKERSIZE] = {0};
    strncpy(ticker, buffer, TICKERSIZE);
    printf(""Received request for stock: %s\n"", ticker);

    // TODO - Query stock market API for stock data and send back to client

    close(client_fd);
    pthread_exit(NULL);
}",78,4.0
VULNERABLE,falcon180b-48591.c,yes,17,5,change_light,"
  file falcon180b-48591.c line 17 column 5 function change_light
","
  c:@F@change_light at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"#define LIGHT_DURATION 10 // seconds

int light_state[NUM_LIGHTS] = {RED_LIGHT, RED_LIGHT, RED_LIGHT, RED_LIGHT};

void *change_light(void *arg) {
    int light_num = *(int *) arg;
    int current_state = light_state[light_num];

    while (1) {
        switch (current_state) {
            case RED_LIGHT:","//Falcon-180B DATASET v1.0 Category: Traffic Light Controller ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

#define RED_LIGHT 1
#define YELLOW_LIGHT 2
#define GREEN_LIGHT 3
#define PEDESTRIAN_LIGHT 4
#define NUM_LIGHTS 4
#define LIGHT_DURATION 10 // seconds

int light_state[NUM_LIGHTS] = {RED_LIGHT, RED_LIGHT, RED_LIGHT, RED_LIGHT};

void *change_light(void *arg) {
    int light_num = *(int *) arg;
    int current_state = light_state[light_num];

    while (1) {
        switch (current_state) {
            case RED_LIGHT:
                printf(""Light %d is red\n"", light_num);
                current_state = YELLOW_LIGHT;
                break;
            case YELLOW_LIGHT:
                printf(""Light %d is yellow\n"", light_num);
                current_state = GREEN_LIGHT;
                break;
            case GREEN_LIGHT:
                printf(""Light %d is green\n"", light_num);
                current_state = RED_LIGHT;
                break;
            case PEDESTRIAN_LIGHT:
                printf(""Light %d is pedestrian\n"", light_num);
                current_state = RED_LIGHT;
                break;
            default:
                printf(""Invalid light state for light %d\n"", light_num);
                return NULL;
        }

        sleep(LIGHT_DURATION);
    }

    return NULL;
}

int main() {
    pthread_t thread_id[NUM_LIGHTS];

    for (int i = 0; i < NUM_LIGHTS; i++) {
        int *light_num = &i;
        pthread_create(&thread_id[i], NULL, change_light, light_num);
    }

    for (int i = 0; i < NUM_LIGHTS; i++) {
        pthread_join(thread_id[i], NULL);
    }

    return 0;
}",62,4.5
VULNERABLE,falcon180b-6198.c,yes,18,5,handle_client,"
  file falcon180b-6198.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",89,6.0
VULNERABLE,falcon180b-24887.c,yes,18,5,handle_client,"
  file falcon180b-24887.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(9000);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(server_socket, 5);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-54782.c,yes,21,5,handle_client,"
  file falcon180b-54782.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Stock market tracker ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define SERVER_PORT 8080
#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message from client: %s\n"", buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",70,3.0
VULNERABLE,falcon180b-40346.c,yes,23,5,runner,"
  file falcon180b-40346.c line 23 column 5 function runner
","
  c:@F@runner at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Thread IDs
pthread_t threads[NUM_THREADS];

// Thread function
void *runner(void *arg) {
    int id = *(int *) arg;
    int priority = (id * 10) + 1;

    printf(""Thread %d started with priority %d\n"", id, priority);

    // Yield the CPU for a certain amount of time slices","//Falcon-180B DATASET v1.0 Category: CPU Scheduling Algorithms ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>
#include <sched.h>

#define NUM_THREADS 5
#define STACK_SIZE 4096

// Mutex for critical section
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Semaphore for synchronization
sem_t sem;

// Thread IDs
pthread_t threads[NUM_THREADS];

// Thread function
void *runner(void *arg) {
    int id = *(int *) arg;
    int priority = (id * 10) + 1;

    printf(""Thread %d started with priority %d\n"", id, priority);

    // Yield the CPU for a certain amount of time slices
    for (int i = 0; i < 10; i++) {
        sched_yield();
    }

    printf(""Thread %d finished\n"", id);
    return NULL;
}

int main() {
    // Initialize semaphore
    sem_init(&sem, 0, 0);

    // Create threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, runner, (void *) &i);
    }

    // Wait for all threads to finish
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",52,2.5
VULNERABLE,gpt35-61009.c,yes,210,17,main,"
  file gpt35-61009.c line 210 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `productId'",dereference failure: accessed expired variable pointer,"                scanf(""%d"", &productId);
                closeBidding(productId);
                break;
            case 3:
                printf(""Enter the ID of the product to place a bid on: "");
                scanf(""%d"", &productId);
                printf(""Enter the amount of the bid: "");
                float amount;
                scanf(""%f"", &amount);
                placeBid(userId, productId, amount);
                break;","//FormAI DATASET v1.0 Category: Digital Auction System ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Defining the maximum number of products and bids */
#define MAX_PRODUCTS 100
#define MAX_BIDS 1000

/* Struct for a product that will be auctioned */
typedef struct {
    int id;
    char name[100];
    char description[500];
    float startingPrice;
    float minimumBidIncrease;
    float currentPrice;
    int totalBids;
    int biddingOpen;
    int winnerId;
} Product;

/* Struct for a bid that will be placed on a product */
typedef struct {
    int id;
    int productId;
    int bidderId;
    float amount;
} Bid;

/* Keeping track of all the products and bids */
Product products[MAX_PRODUCTS];
Bid bids[MAX_BIDS];

/* The number of products and bids currently in the system */
int numProducts = 0;
int numBids = 0;

/* Function to add a new product to the system */
void addProduct() {
    /* Checking if we haven't reached the maximum number of products */
    if (numProducts == MAX_PRODUCTS) {
        printf(""Maximum number of products reached.\n"");
        return;
    }

    /* Creating a new product object */
    Product p;
    p.id = numProducts + 1;

    /* Collecting input from the user for the product fields */
    printf(""Enter the name of the product: "");
    scanf(""%s"", p.name);
    printf(""Enter a description for the product: "");
    scanf(""%s"", p.description);
    printf(""Enter the starting price: "");
    scanf(""%f"", &p.startingPrice);
    printf(""Enter the minimum bid increase: "");
    scanf(""%f"", &p.minimumBidIncrease);

    /* Setting the product's current price to the starting price */
    p.currentPrice = p.startingPrice;

    /* Setting the total number of bids to 0, the bidding to open, and the winner ID to 0 */
    p.totalBids = 0;
    p.biddingOpen = 1;
    p.winnerId = 0;

    /* Adding the product to the system */
    products[numProducts++] = p;

    printf(""Product added successfully.\n"");
}

/* Function to close the bidding on a product */
void closeBidding(int productId) {
    /* Finding the product with the given ID */
    int found = 0;
    Product *p;
    for (int i = 0; i < numProducts; i++) {
        if (products[i].id == productId) {
            found = 1;
            p = &products[i];
            break;
        }
    }

    if (!found) {
        printf(""Product not found.\n"");
        return;
    }

    /* Setting the bidding to closed */
    p->biddingOpen = 0;

    /* Finding the highest bidder */
    Bid *winningBid;
    float highestBid = 0;
    for (int i = 0; i < numBids; i++) {
        if (bids[i].productId == productId && bids[i].amount > highestBid) {
            highestBid = bids[i].amount;
            winningBid = &bids[i];
        }
    }

    /* Setting the winner ID */
    p->winnerId = winningBid->bidderId;

    printf(""Bidding closed successfully.\n"");
}

/* Function to place a bid on a product */
void placeBid(int bidderId, int productId, float amount) {
    /* Finding the product with the given ID */
    int found = 0;
    Product *p;
    for (int i = 0; i < numProducts; i++) {
        if (products[i].id == productId) {
            found = 1;
            p = &products[i];
            break;
        }
    }

    if (!found) {
        printf(""Product not found.\n"");
        return;
    }

    /* Checking if bidding is closed on the product */
    if (!p->biddingOpen) {
        printf(""Bidding is closed on this product.\n"");
        return;
    }

    /* Checking if the amount is higher than the current price + minimum bid increase */
    if (amount < p->currentPrice + p->minimumBidIncrease) {
        printf(""Bid amount must be greater than the current price plus minimum bid increase.\n"");
        return;
    }

    /* Creating a new bid object */
    Bid b;
    b.id = numBids + 1;
    b.productId = productId;
    b.bidderId = bidderId;
    b.amount = amount;

    /* Updating the product's current price and total bids */
    p->currentPrice = amount;
    p->totalBids++;

    /* Adding the bid to the system */
    bids[numBids++] = b;

    printf(""Bid placed successfully.\n"");
}

/* Function to display all the products currently in the system */
void displayProducts() {
    printf(""Products currently in the system:\n"");
    for (int i = 0; i < numProducts; i++) {
        printf(""ID: %d\n"", products[i].id);
        printf(""Name: %s\n"", products[i].name);
        printf(""Description: %s\n"", products[i].description);
        printf(""Starting Price: $%.2f\n"", products[i].startingPrice);
        printf(""Current Price: $%.2f\n"", products[i].currentPrice);
        printf(""Minimum Bid Increase: $%.2f\n"", products[i].minimumBidIncrease);
        printf(""Total Bids: %d\n"", products[i].totalBids);
        printf(""Bidding Open: %s\n"", products[i].biddingOpen ? ""Yes"" : ""No"");

        if (!products[i].biddingOpen) {
            printf(""Winner ID: %d\n"", products[i].winnerId);
        }

        printf(""\n"");
    }
}

int main() {
    /* A simple menu-based program to demonstrate the functions */

    int userId = 1; /* Dummy user ID for the purpose of this example */

    while (1) {
        printf(""Menu:\n"");
        printf(""1. Add product\n"");
        printf(""2. Close bidding on a product\n"");
        printf(""3. Place a bid\n"");
        printf(""4. Display all products\n"");
        printf(""5. Exit\n"");

        int choice;
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                addProduct();
                break;
            case 2:
                printf(""Enter the ID of the product to close bidding on: "");
                int productId;
                scanf(""%d"", &productId);
                closeBidding(productId);
                break;
            case 3:
                printf(""Enter the ID of the product to place a bid on: "");
                scanf(""%d"", &productId);
                printf(""Enter the amount of the bid: "");
                float amount;
                scanf(""%f"", &amount);
                placeBid(userId, productId, amount);
                break;
            case 4:
                displayProducts();
                break;
            case 5:
                return 0;
            default:
                printf(""Invalid choice.\n"");
        }

        /* Adding a delay of 1 second for demonstration purposes */
        sleep(1);
    }

    return 0;
}",230,5.2
VULNERABLE,falcon180b-1538.c,yes,23,5,handle_client,"
  file falcon180b-1538.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"int addrlen;
int client_socks[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_sock = *(int*) arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int sock;
struct sockaddr_in server_addr;
int addrlen;
int client_socks[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_sock = *(int*) arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            close(client_sock);
            pthread_exit(0);
        }
        printf(""Client %d sent: %s\n"", client_sock, buffer);
    }
}

int main() {
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if(listen(sock, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    addrlen = sizeof(struct sockaddr_in);
    puts(""Server is listening on port 8080..."");

    while(1) {
        int client_sock = accept(sock, (struct sockaddr*)&server_addr, (socklen_t*)&addrlen);
        if(client_sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            close(client_sock);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_socks[num_clients] = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void*)&client_sock);
    }

    return 0;
}",81,5.0
VULNERABLE,gemini_pro-9974.c,yes,15,5,drone_control,"
  file gemini_pro-9974.c line 15 column 5 function drone_control
","
  c:@F@drone_control at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int drone_altitudes[NUM_DRONES];
pthread_mutex_t altitude_lock;

// Drone control thread
void *drone_control(void *arg) {
    int drone_id = *(int *)arg;
    while (1) {
        // Randomly adjust drone altitude
        pthread_mutex_lock(&altitude_lock);
        drone_altitudes[drone_id] += rand() % 10 - 5;
        printf(""Drone %d: Altitude: %d\n"", drone_id, drone_altitudes[drone_id]);","//GEMINI-pro DATASET v1.0 Category: Drone Remote Control ; Style: multi-threaded
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <time.h>
#include <unistd.h>
#define NUM_DRONES 4

// Shared data variables
int drone_altitudes[NUM_DRONES];
pthread_mutex_t altitude_lock;

// Drone control thread
void *drone_control(void *arg) {
    int drone_id = *(int *)arg;
    while (1) {
        // Randomly adjust drone altitude
        pthread_mutex_lock(&altitude_lock);
        drone_altitudes[drone_id] += rand() % 10 - 5;
        printf(""Drone %d: Altitude: %d\n"", drone_id, drone_altitudes[drone_id]);
        pthread_mutex_unlock(&altitude_lock);
        
        // Sleep for a while
        sleep(1);
    }
    return NULL;
}

int main() {
    // Initialize shared data variables
    for (int i = 0; i < NUM_DRONES; i++) {
        drone_altitudes[i] = 0;
    }
    pthread_mutex_init(&altitude_lock, NULL);

    // Create drone control threads
    pthread_t drone_threads[NUM_DRONES];
    for (int i = 0; i < NUM_DRONES; i++) {
        pthread_create(&drone_threads[i], NULL, drone_control, (void *)&i);
    }

    // Wait for drone control threads to finish
    for (int i = 0; i < NUM_DRONES; i++) {
        pthread_join(drone_threads[i], NULL);
    }

    // Destroy shared data variables
    pthread_mutex_destroy(&altitude_lock);

    return 0;
}",51,3.0
VULNERABLE,gemini_pro-20956.c,yes,22,5,handle_client,"
  file gemini_pro-20956.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

pthread_mutex_t client_sockets_mutex;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    int bytes_received;

    while ((bytes_received = recv(client_socket, buffer, sizeof(buffer), 0)) > 0) {
        // Process the received message from the client","//GEMINI-pro DATASET v1.0 Category: Smart home automation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <pthread.h>

#define PORT 9000
#define MAX_CLIENTS 10
#define BUFFER_SIZE 256

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

pthread_mutex_t client_sockets_mutex;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    int bytes_received;

    while ((bytes_received = recv(client_socket, buffer, sizeof(buffer), 0)) > 0) {
        // Process the received message from the client
        printf(""Message received from client: %s\n"", buffer);

        // Send a response to the client
        send(client_socket, ""Message received"", strlen(""Message received""), 0);
    }

    // Close the client socket
    pthread_mutex_lock(&client_sockets_mutex);
    for (int i = 0; i < MAX_CLIENTS; i++) {
        if (client_sockets[i] == client_socket) {
            client_sockets[i] = -1;
            num_clients--;
            break;
        }
    }
    pthread_mutex_unlock(&client_sockets_mutex);

    close(client_socket);

    return NULL;
}

int main() {
    // Initialize the server socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Set up the server address
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(PORT);
    server_address.sin_addr.s_addr = INADDR_ANY;

    // Bind the server socket to the server address
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    // Initialize the mutex for protecting the client sockets array
    pthread_mutex_init(&client_sockets_mutex, NULL);

    // Main loop for handling client connections
    while (1) {
        // Accept an incoming connection
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        // Add the client socket to the array of client sockets
        pthread_mutex_lock(&client_sockets_mutex);
        if (num_clients >= MAX_CLIENTS) {
            // Too many clients connected, reject the connection
            close(client_socket);
            pthread_mutex_unlock(&client_sockets_mutex);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_mutex_unlock(&client_sockets_mutex);

        // Create a new thread to handle the client
        pthread_t client_thread;
        if (pthread_create(&client_thread, NULL, handle_client, &client_socket) != 0) {
            perror(""pthread_create"");
            close(client_socket);
        }
    }

    // Clean up
    for (int i = 0; i < MAX_CLIENTS; i++) {
        if (client_sockets[i] != -1) {
            close(client_sockets[i]);
        }
    }

    pthread_mutex_destroy(&client_sockets_mutex);
    close(server_socket);

    return EXIT_SUCCESS;
}",119,7.0
VULNERABLE,gpt35-51917.c,yes,22,5,thread_func,"
  file gpt35-51917.c line 22 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `thread_args'",dereference failure: accessed expired variable pointer,"pthread_cond_t cond_var;

// This is the function that each thread will execute.
// It will lock the mutex, print the message to the console, unlock the mutex, and signal the condition variable.
void* thread_func(void* arg) {
    int thread_num = *(int*)arg;
    pthread_mutex_lock(&lock);
    printf(""Thread %d: Hello, world!\n"", thread_num);
    pthread_mutex_unlock(&lock);
    pthread_cond_signal(&cond_var);
    return NULL;","//FormAI DATASET v1.0 Category: Threading Library Implementation ; Style: lively
// Hello there! I'm a Chatbot and I'm excited to show you a unique C Threading Library Implementation!
// In this program, we will create multiple threads and demonstrate their communication using locks and condition variables.
// Let's get started!

#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>

// We will create 5 threads that will print a message to the console, but they will do it in a random order.
const int NUM_THREADS = 5;

// We need a mutex lock to ensure only one thread prints to the console at a time.
pthread_mutex_t lock;

// We also need a condition variable to ensure the threads wait for each other to finish printing.
pthread_cond_t cond_var;

// This is the function that each thread will execute.
// It will lock the mutex, print the message to the console, unlock the mutex, and signal the condition variable.
void* thread_func(void* arg) {
    int thread_num = *(int*)arg;
    pthread_mutex_lock(&lock);
    printf(""Thread %d: Hello, world!\n"", thread_num);
    pthread_mutex_unlock(&lock);
    pthread_cond_signal(&cond_var);
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];

    // Initialize the mutex lock and condition variable.
    pthread_mutex_init(&lock, NULL);
    pthread_cond_init(&cond_var, NULL);

    // Create and start the threads.
    int thread_args[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_args[i] = i;
        pthread_create(&threads[i], NULL, thread_func, &thread_args[i]);
    }

    // Wait for the threads to finish printing before exiting the program.
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_mutex_lock(&lock);
        pthread_cond_wait(&cond_var, &lock);
        pthread_mutex_unlock(&lock);
    }

    // Destroy the mutex lock and condition variable.
    pthread_mutex_destroy(&lock);
    pthread_cond_destroy(&cond_var);

    return 0;
}",56,2.0
VULNERABLE,falcon180b-31977.c,yes,25,5,handle_client,"
  file falcon180b-31977.c line 25 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"        }
    }
}

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void broadcast(int sender_socket, char* message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        broadcast(client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full"", strlen(""Server is full""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void*) &client_socket);
        }
    }

    return 0;
}",73,3.0
VULNERABLE,gpt35-32493.c,yes,77,13,main,"
  file gpt35-32493.c line 77 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `size'",dereference failure: accessed expired variable pointer,"            scanf(""%d"", &size);
            triangle(size);
            break;
        case 3:
            printf(""Enter size of diamond:\n"");
            scanf(""%d"", &size);
            diamond(size);
            break;
        default:
            printf(""Invalid choice."");
    }","//FormAI DATASET v1.0 Category: Text to ASCII art generator ; Style: shape shifting
#include <stdio.h>

void dots(int num) {
    for (int i = 0; i < num; i++) {
        printf(""."");
    }
}

void line(int num) {
    printf(""+"");
    dots(num);
    printf(""+\n"");
}

void rect(int width, int height) {
    line(width);
    for (int i = 0; i < height; i++) {
        printf(""|"");
        dots(width);
        printf(""|\n"");
    }
    line(width);
}

void triangle(int size) {
    for (int i = 1; i <= size; i++) {
        dots(size-i);
        printf(""/"");
        dots(i*2-2);
        printf(""\\\n"");
    }
    line(size*2);
}

void diamond(int size) {
    for (int i = 1; i <= size-1; i++) {
        dots(size-i);
        printf(""/"");
        dots(i*2-2);
        printf(""\\\n"");
    }
    line(size*2);
    for (int j = size-1; j > 0; j--) {
        dots(size-j);
        printf(""\\"");
        dots(j*2-2);
        printf(""/\n"");
    }
    line(size*2);
}

int main() {
    int choice;

    printf(""Choose a shape:\n"");
    printf(""1. Rectangle\n"");
    printf(""2. Triangle\n"");
    printf(""3. Diamond\n"");
    scanf(""%d"", &choice);

    switch(choice) {
        case 1:
            printf(""Enter width and height of rectangle:\n"");
            int width, height;
            scanf(""%d %d"", &width, &height);
            rect(width, height);
            break;
        case 2:
            printf(""Enter size of triangle:\n"");
            int size;
            scanf(""%d"", &size);
            triangle(size);
            break;
        case 3:
            printf(""Enter size of diamond:\n"");
            scanf(""%d"", &size);
            diamond(size);
            break;
        default:
            printf(""Invalid choice."");
    }

    return 0;
}",85,2.333
VULNERABLE,gpt35-71250.c,yes,91,5,handle_connection,"
  file gpt35-71250.c line 91 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"        }
    }
}

void *handle_connection(void *arg) {
    int client_fd = *((int *)arg);
    char buffer[MAX_BUFFER_SIZE] = {0};
    char reply[MAX_BUFFER_SIZE] = {0};

    // Get client IP address
    struct sockaddr_in client_addr = {0};","//FormAI DATASET v1.0 Category: Wireless Network Scanner ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <ctype.h>
#include <pthread.h>

#define PORT 8000
#define MAX_BUFFER_SIZE 1024

// Function declarations
void start_scan();
void *handle_connection(void *);
int is_valid_ip(char *);

// Global variables
int sock_fd;

int main(int argc, char *argv[]) {
    printf(""Welcome to the Surrealistic Wireless Network Scanner!\n"");

    // Create socket
    if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror(""Error creating socket"");
        exit(EXIT_FAILURE);
    }

    // Set socket options
    int opt = 1;
    if (setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""Error setting socket options"");
        exit(EXIT_FAILURE);
    }

    // Bind socket
    struct sockaddr_in server_addr = {0};
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    if (bind(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror(""Error binding socket"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %d...\n"", PORT);

    // Start scanning for connections
    start_scan();

    // Close socket
    close(sock_fd);

    return 0;
}

void start_scan() {
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    char buffer[MAX_BUFFER_SIZE] = {0};
    pthread_t thread_id;

    while(1) {
        // Accept incoming connection
        int client_fd = accept(sock_fd, (struct sockaddr *)&client_addr, &addr_len);
        if (client_fd < 0) {
            perror(""Error accepting connection"");
            continue;
        }

        // Handle connection on a separate thread
        if (pthread_create(&thread_id, NULL, handle_connection, (void *)&client_fd)) {
            perror(""Error creating thread"");
            close(client_fd);
            continue;
        }

        // Detach thread so it can run independently
        if (pthread_detach(thread_id)) {
            perror(""Error detaching thread"");
            close(client_fd);
            continue;
        }
    }
}

void *handle_connection(void *arg) {
    int client_fd = *((int *)arg);
    char buffer[MAX_BUFFER_SIZE] = {0};
    char reply[MAX_BUFFER_SIZE] = {0};

    // Get client IP address
    struct sockaddr_in client_addr = {0};
    socklen_t addr_len = sizeof(client_addr);
    if (getpeername(client_fd, (struct sockaddr *)&client_addr, &addr_len)) {
        perror(""Error getting client IP address"");
        close(client_fd);
        pthread_exit(NULL);
    }

    char *ip_addr = inet_ntoa(client_addr.sin_addr);

    printf(""Scanning network from %s...\n"", ip_addr);

    // Parse client IP address
    char prefix[16] = {0};
    strcpy(prefix, strtok(ip_addr, "".""));
    for (int i = 0; i < 3; i++) {
        strcat(prefix, ""."");
        strcat(prefix, strtok(NULL, "".""));
    }
    strcat(prefix, ""."");

    // Scan network for active IP addresses
    for (int i = 1; i <= 255; i++) {
        char test_ip[16] = {0};
        sprintf(test_ip, ""%s%d"", prefix, i);
        if (!is_valid_ip(test_ip)) {
            continue;
        }

        // Create test socket for checking if IP address is active
        int test_sock = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in test_addr = {0};
        test_addr.sin_family = AF_INET;
        test_addr.sin_port = htons(PORT);
        test_addr.sin_addr.s_addr = inet_addr(test_ip);
        int result = connect(test_sock, (struct sockaddr *)&test_addr, sizeof(test_addr));

        // Check if IP address is active
        if (result >= 0) {
            sprintf(reply, ""Active IP address found: %s"", test_ip);
            send(client_fd, reply, strlen(reply), 0);
            printf(""%s\n"", reply);
            close(test_sock);
        }
    }

    // Send end of transmission signal
    strcpy(reply, ""EOT"");
    send(client_fd, reply, strlen(reply), 0);

    // Close client socket and exit thread
    close(client_fd);
    pthread_exit(NULL);
}

int is_valid_ip(char *ip) {
    char *token = strtok(ip, ""."");
    int octet_count = 0;

    while (token != NULL) {
        if (!isdigit(*token)) {
            return 0;
        }

        int octet = atoi(token);
        if (octet < 0 || octet > 255) {
            return 0;
        }

        token = strtok(NULL, ""."");
        octet_count++;
    }

    if (octet_count != 4) {
        return 0;
    }

    return 1;
}",174,5.25
VULNERABLE,falcon180b-22096.c,yes,17,5,handle_client,"
  file falcon180b-22096.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d: %s\n"", client_socket, buffer);
        int i;
        for (i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients == MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try later.\n"", 32, 0);
            close(client_socket);
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",60,4.0
VULNERABLE,falcon180b-10629.c,yes,20,5,handle_client,"
  file falcon180b-10629.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    num_clients--;
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }
        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",80,5.0
VULNERABLE,falcon180b-41617.c,yes,24,5,handle_client,"
  file falcon180b-41617.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_num = 0;
int thread_id[THREAD_NUM];
pthread_t thread[THREAD_NUM];

void* handle_client(void* arg) {
    int client_socket = *((int*) arg);
    char buffer[BUF_SIZE];
    while(1) {
        bzero(buffer, BUF_SIZE);
        int ret = recv(client_socket, buffer, BUF_SIZE, 0);
        if(ret <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUF_SIZE 1024
#define MAX_CLIENTS 10
#define PORT 8080
#define THREAD_NUM 10

int client_sock[MAX_CLIENTS];
int client_num = 0;
int thread_id[THREAD_NUM];
pthread_t thread[THREAD_NUM];

void* handle_client(void* arg) {
    int client_socket = *((int*) arg);
    char buffer[BUF_SIZE];
    while(1) {
        bzero(buffer, BUF_SIZE);
        int ret = recv(client_socket, buffer, BUF_SIZE, 0);
        if(ret <= 0) {
            break;
        }
        printf(""Client %d says: %s\n"", client_socket, buffer);
        for(int i=0; i<client_num; i++) {
            if(client_sock[i]!= client_socket) {
                send(client_sock[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        printf(""Client %d connected\n"", client_socket);
        if(client_num >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
        } else {
            client_sock[client_num] = client_socket;
            pthread_create(&thread[client_num], NULL, handle_client, (void*)&client_socket);
            client_num++;
        }
    }

    return 0;
}",69,4.0
VULNERABLE,codellama_13b-7787.c,yes,25,16,process_imap_response,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file codellama_13b-7787.c line 25 column 16 function process_imap_response
  c:@F@process_imap_response at file codellama_13b-7787.c line 58 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `response'",dereference failure: accessed expired variable pointer,"
// Function to process an IMAP response
void process_imap_response(char *response) {
    if (strcmp(response, ""OK"") == 0) {
        printf(""Command succeeded\n"");
    } else if (strcmp(response, ""NO"") == 0) {
        printf(""Command failed\n"");
    } else {
        printf(""Invalid response\n"");
    }
}","//Code Llama-13B DATASET v1.0 Category: Building a IMAP Client ; Style: enthusiastic
// A unique C building IMAP client example program in an enthusiastic style
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

// Function to send an IMAP command
void send_imap_command(char *cmd) {
    printf(""Sending command: %s\n"", cmd);
}

// Function to receive an IMAP response
char *receive_imap_response() {
    char response[1024];
    printf(""Waiting for response...\n"");
    scanf(""%s"", response);
    return response;
}

// Function to process an IMAP response
void process_imap_response(char *response) {
    if (strcmp(response, ""OK"") == 0) {
        printf(""Command succeeded\n"");
    } else if (strcmp(response, ""NO"") == 0) {
        printf(""Command failed\n"");
    } else {
        printf(""Invalid response\n"");
    }
}

int main() {
    // Connect to the IMAP server
    printf(""Connecting to the IMAP server...\n"");
    // Send the LOGIN command
    send_imap_command(""LOGIN"");
    // Receive the response
    char *response = receive_imap_response();
    // Process the response
    process_imap_response(response);
    // Send the SELECT command
    send_imap_command(""SELECT"");
    // Receive the response
    response = receive_imap_response();
    // Process the response
    process_imap_response(response);
    // Send the FETCH command
    send_imap_command(""FETCH"");
    // Receive the response
    response = receive_imap_response();
    // Process the response
    process_imap_response(response);
    // Send the CLOSE command
    send_imap_command(""CLOSE"");
    // Receive the response
    response = receive_imap_response();
    // Process the response
    process_imap_response(response);
    // Disconnect from the IMAP server
    printf(""Disconnecting from the IMAP server...\n"");
    return 0;
}",62,1.5
VULNERABLE,falcon180b-9826.c,yes,43,5,log_to_file,"
  file falcon180b-9826.c line 43 column 5 function log_to_file
","
  c:@F@log_to_file at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `data'",dereference failure: accessed expired variable pointer,"    pthread_mutex_unlock(&event_mutex);
}

void *log_to_file(void *arg) {
    thread_data_t *data = (thread_data_t *) arg;
    FILE *log_file = data->log_file;

    while (1) {
        pthread_mutex_lock(&event_mutex);
        if (event_head == event_tail) {
            pthread_mutex_unlock(&event_mutex);","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

#define MAX_EVENTS 1000
#define MAX_THREADS 10

typedef struct event_s {
    time_t timestamp;
    char message[256];
} event_t;

typedef struct thread_data_s {
    int thread_id;
    FILE *log_file;
} thread_data_t;

event_t event_buffer[MAX_EVENTS];
int event_head = 0;
int event_tail = 0;
pthread_mutex_t event_mutex = PTHREAD_MUTEX_INITIALIZER;

void log_event(const char *message) {
    event_t event;
    time(&event.timestamp);
    strncpy(event.message, message, 255);
    event.message[255] = '\0';

    pthread_mutex_lock(&event_mutex);
    if ((event_tail + 1) % MAX_EVENTS == event_head) {
        printf(""Event buffer full, dropping event\n"");
    } else {
        event_tail = (event_tail + 1) % MAX_EVENTS;
        event_buffer[event_tail] = event;
    }
    pthread_mutex_unlock(&event_mutex);
}

void *log_to_file(void *arg) {
    thread_data_t *data = (thread_data_t *) arg;
    FILE *log_file = data->log_file;

    while (1) {
        pthread_mutex_lock(&event_mutex);
        if (event_head == event_tail) {
            pthread_mutex_unlock(&event_mutex);
            sleep(1);
            continue;
        }

        fprintf(log_file, ""Thread %d logging event: %s\n"", data->thread_id, event_buffer[event_head].message);
        fflush(log_file);

        event_head = (event_head + 1) % MAX_EVENTS;
        pthread_mutex_unlock(&event_mutex);

        sleep(1);
    }

    return NULL;
}

int main() {
    int i;
    pthread_t threads[MAX_THREADS];

    for (i = 0; i < MAX_THREADS; i++) {
        thread_data_t data;
        data.thread_id = i;
        data.log_file = fopen(""logfile.txt"", ""a"");

        pthread_create(&threads[i], NULL, log_to_file, &data);
    }

    while (1) {
        sleep(1);
        log_event(""Hello world!"");
    }

    return 0;
}",83,2.667
VULNERABLE,falcon180b-46356.c,yes,21,5,handle_client,"
  file falcon180b-46356.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[MAX_BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, MAX_BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_BUFFER_SIZE 1024
#define PORT 8080
#define SERVER_IP ""127.0.0.1""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[MAX_BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, MAX_BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket!= -1) {
            printf(""Client %d connected\n"", client_socket);
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            client_sockets[num_clients++] = client_socket;
        }
    }

    return 0;
}",77,5.5
VULNERABLE,falcon180b-22976.c,yes,44,5,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-22976.c line 44 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"    printf(""From which kingdom dost thou hail?\n"");
    strcpy(kingdom, get_input(""Kingdom: ""));
    sanitize_input(kingdom);

    printf(""What title dost thou bear?\n"");
    strcpy(title, get_input(""Title: ""));
    sanitize_input(title);

    // Print user input
    printf(""\nHail, Sir %s of %s!\n"", name, kingdom);
    printf(""We art pleased to bestow upon thee the title of %s.\n"", title);","//Falcon-180B DATASET v1.0 Category: User Input Sanitizer ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_INPUT_LENGTH 100

// Function to sanitize user input
void sanitize_input(char* input) {
    int i = 0;
    while (i < strlen(input)) {
        if (!isalpha(input[i])) {
            input[i] = '\0';
        }
        i++;
    }
}

// Function to get user input
char* get_input(char* prompt) {
    char input[MAX_INPUT_LENGTH];
    printf(""%s: "", prompt);
    fgets(input, MAX_INPUT_LENGTH, stdin);
    input[strcspn(input, ""\n"")] = '\0';
    return input;
}

// Main function
int main() {
    char name[MAX_INPUT_LENGTH];
    char kingdom[MAX_INPUT_LENGTH];
    char title[MAX_INPUT_LENGTH];

    // Get user input
    printf(""Enter thy name, noble knight:\n"");
    strcpy(name, get_input(""Name: ""));
    sanitize_input(name);

    printf(""From which kingdom dost thou hail?\n"");
    strcpy(kingdom, get_input(""Kingdom: ""));
    sanitize_input(kingdom);

    printf(""What title dost thou bear?\n"");
    strcpy(title, get_input(""Title: ""));
    sanitize_input(title);

    // Print user input
    printf(""\nHail, Sir %s of %s!\n"", name, kingdom);
    printf(""We art pleased to bestow upon thee the title of %s.\n"", title);

    return 0;
}",52,1.667
VULNERABLE,falcon180b-15880.c,yes,18,5,handle_client,"
  file falcon180b-15880.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Searching algorithm ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < client_count; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_count >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more clients.\n"");
            continue;
        }

        clients[client_count] = client_socket;
        client_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,3.5
VULNERABLE,falcon180b-47817.c,yes,18,5,handle_client,"
  file falcon180b-47817.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define SERVER_PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d said: %s\n"", client_socket, buffer);

        for(int i=0; i<num_clients; i++) {
            if(client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 12, 0);
            close(client_socket);
        } else {
            client_sockets[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",69,4.0
VULNERABLE,falcon180b-59033.c,yes,18,5,handle_client,"
  file falcon180b-59033.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        send(client_socket, buffer, bytes_received, 0);
    }
    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\r\n"", 17, 0);
            close(client_socket);
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket.\r\n"");
        exit(1);
    }
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket.\r\n"");
        exit(1);
    }
    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket.\r\n"");
        exit(1);
    }
    printf(""Chat server started on port 8080.\r\n"");
    accept_connections();
    return 0;
}",70,3.333
VULNERABLE,gemini_pro-22139.c,yes,12,5,thread_function,"
  file gemini_pro-22139.c line 12 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"#define NUM_THREADS 5

// Define the thread function
void *thread_function(void *arg) {
    // Get the thread ID
    int thread_id = *(int *)arg;

    // Print a message from the thread
    printf(""Hello from thread %d!\n"", thread_id);

    // Sleep for a random amount of time","//GEMINI-pro DATASET v1.0 Category: Threading Library Implementation ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Define the number of threads to create
#define NUM_THREADS 5

// Define the thread function
void *thread_function(void *arg) {
    // Get the thread ID
    int thread_id = *(int *)arg;

    // Print a message from the thread
    printf(""Hello from thread %d!\n"", thread_id);

    // Sleep for a random amount of time
    sleep(rand() % 5);

    // Return NULL
    return NULL;
}

int main() {
    // Initialize the random number generator
    srand(time(NULL));

    // Create an array of thread IDs
    pthread_t thread_ids[NUM_THREADS];

    // Create the threads
    for (int i = 0; i < NUM_THREADS; i++) {
        // Create the thread
        if (pthread_create(&thread_ids[i], NULL, thread_function, &i) != 0) {
            perror(""pthread_create"");
            return EXIT_FAILURE;
        }
    }

    // Join the threads
    for (int i = 0; i < NUM_THREADS; i++) {
        // Join the thread
        if (pthread_join(thread_ids[i], NULL) != 0) {
            perror(""pthread_join"");
            return EXIT_FAILURE;
        }
    }

    // Print a message from the main thread
    printf(""Hello from the main thread!\n"");

    // Return success
    return EXIT_SUCCESS;
}",54,3.0
VULNERABLE,falcon180b-46669.c,yes,19,5,handle_client,"
  file falcon180b-46669.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;

    char buffer[BUFFER_SIZE];
    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;

    char buffer[BUFFER_SIZE];
    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= sock) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(sock);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, BACKLOG);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        if (num_clients == MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 15, 0);
            close(client_socket);
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,5.0
VULNERABLE,falcon180b-45618.c,yes,12,5,handle_client,"
  file falcon180b-45618.c line 12 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    while (1) {
        bzero(buffer, 1024);
        int bytes_received = recv(client_socket, buffer, 1024, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    while (1) {
        bzero(buffer, 1024);
        int bytes_received = recv(client_socket, buffer, 1024, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    close(server_socket);
    return 0;
}",64,4.5
VULNERABLE,falcon180b-28655.c,yes,17,5,handle_client,"
  file falcon180b-28655.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Electronic Voting System ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d: %s\n"", client_socket, buffer);
    }
    close(client_socket);
    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            break;
        }
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
}

int main() {
    accept_connections();
    return 0;
}",64,2.667
VULNERABLE,gpt35-221.c,yes,72,3,handle_client,"
  file gpt35-221.c line 72 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"
  return 0;
}

void *handle_client(void *arg) {
  int sock = *(int *)arg;
  int read_size;
  char *message = ""Hello, client!"";

  // Sending welcome message to client
  if (send(sock, message, strlen(message), 0) < 0) {","//FormAI DATASET v1.0 Category: Client Server Application ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080

void *handle_client(void *);

int main(int argc, char const *argv[]) {
  int server_fd, new_socket;
  struct sockaddr_in server_addr;
  pthread_t thread;
  int opt = 1;
  int addrlen = sizeof(server_addr);

  // Creating socket file descriptor
  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror(""socket failed"");
    exit(EXIT_FAILURE);
  }

  // Setting socket options
  if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
    perror(""setsockopt"");
    exit(EXIT_FAILURE);
  }

  // Setting socket address
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = INADDR_ANY;
  server_addr.sin_port = htons(PORT);

  // Binding socket
  if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
    perror(""bind failed"");
    exit(EXIT_FAILURE);
  }

  // Listening for incoming connections
  if (listen(server_fd, 3) < 0) {
    perror(""listen"");
    exit(EXIT_FAILURE);
  }

  printf(""Server started on port %d...\n"", PORT);

  // Accepting new connections
  while ((new_socket = accept(server_fd, (struct sockaddr *)&server_addr, (socklen_t *)&addrlen))) {
    printf(""New connection accepted.\n"");

    if (pthread_create(&thread, NULL, handle_client, (void *)&new_socket) < 0) {
      perror(""pthread_create"");
      exit(EXIT_FAILURE);
    }
  }

  if (new_socket < 0) {
    perror(""accept"");
    exit(EXIT_FAILURE);
  }

  return 0;
}

void *handle_client(void *arg) {
  int sock = *(int *)arg;
  int read_size;
  char *message = ""Hello, client!"";

  // Sending welcome message to client
  if (send(sock, message, strlen(message), 0) < 0) {
    perror(""send"");
  }

  // Reading messages from client
  char client_message[1024];
  while ((read_size = recv(sock, client_message, 1024, 0)) > 0) {
    // Adding null terminator to client message
    client_message[read_size] = '\0';

    // Printing client message to console
    printf(""Received message from client: %s\n"", client_message);

    // Sending back message to client
    if (send(sock, client_message, strlen(client_message), 0) < 0) {
      perror(""send"");
      break;
    }

    // Clearing client_message buffer
    memset(client_message, 0, sizeof(client_message));
  }

  if (read_size == 0) {
    printf(""Client disconnected.\n"");
    fflush(stdout);
  } else if (read_size == -1) {
    perror(""recv"");
  }

  // Closing socket
  close(sock);

  return NULL;
}",111,7.0
VULNERABLE,falcon180b-6175.c,yes,28,13,execute_command,"
  file falcon180b-6175.c line 28 column 13 function execute_command
","
  c:@F@execute_command at file falcon180b-6175.c line 76 column 9 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `argv'",dereference failure: accessed expired variable pointer,"    pid = fork();
    if (pid == -1) {
        perror(""fork"");
        return 1;
    } else if (pid == 0) {
        if (execvp(command->arguments[0], command->arguments) == -1) {
            perror(""execvp"");
            exit(1);
        }
    } else {
        waitpid(pid, &status, 0);","//Falcon-180B DATASET v1.0 Category: System administration ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#define MAX_COMMAND_LENGTH 1024
#define MAX_ARGUMENTS 10
#define MAX_ARGUMENT_LENGTH 128

typedef struct {
    char **arguments;
    int argument_count;
} Command;

int execute_command(Command *command) {
    pid_t pid;
    int status;

    pid = fork();
    if (pid == -1) {
        perror(""fork"");
        return 1;
    } else if (pid == 0) {
        if (execvp(command->arguments[0], command->arguments) == -1) {
            perror(""execvp"");
            exit(1);
        }
    } else {
        waitpid(pid, &status, 0);
        if (WIFEXITED(status)) {
            return WEXITSTATUS(status);
        } else if (WIFSIGNALED(status)) {
            fprintf(stderr, ""Command terminated by signal %d\n"", WTERMSIG(status));
            return 1;
        } else {
            fprintf(stderr, ""Unknown exit status\n"");
            return 1;
        }
    }
}

int parse_command(char *input, Command *command) {
    char *token;
    int argc = 0;
    char *argv[MAX_ARGUMENTS];

    token = strtok(input, "" "");
    while (token!= NULL) {
        if (argc >= MAX_ARGUMENTS) {
            fprintf(stderr, ""Too many arguments\n"");
            return 1;
        }
        argv[argc++] = token;
        token = strtok(NULL, "" "");
    }
    command->arguments = argv;
    command->argument_count = argc;

    return 0;
}

int main() {
    char input[MAX_COMMAND_LENGTH];
    Command command;

    while (1) {
        printf(""> "");
        fgets(input, MAX_COMMAND_LENGTH, stdin);
        if (parse_command(input, &command)!= 0) {
            continue;
        }
        execute_command(&command);
    }

    return 0;
}",80,4.0
VULNERABLE,falcon180b-3007.c,yes,19,5,handle_client,"
  file falcon180b-3007.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            break;
        }
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        clients[num_clients++] = client_socket;
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    accept_connections(server_socket);

    return 0;
}",77,3.333
VULNERABLE,falcon180b-37232.c,yes,22,5,handle_client,"
  file falcon180b-37232.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_LINE];

    while (1) {
        memset(buffer, 0, MAX_LINE);
        int bytes_received = recv(client_socket, buffer, MAX_LINE, 0);","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_LINE 1024
#define SERVER_PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_LINE];

    while (1) {
        memset(buffer, 0, MAX_LINE);
        int bytes_received = recv(client_socket, buffer, MAX_LINE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            num_clients--;
            break;
        }

        fprintf(stdout, ""Client %d: %s\n"", client_socket, buffer);

        send(client_socket, buffer, strlen(buffer), 0);
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            fprintf(stderr, ""Error accepting client connection\n"");
            continue;
        }

        num_clients++;
        fprintf(stdout, ""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",69,3.0
VULNERABLE,gpt35-45491.c,yes,69,5,client_handler,"
  file gpt35-45491.c line 69 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"}

void *client_handler(void *arg) {

    // get socket file descriptor from argument
    int client_socket = *(int *)arg;

    // receive message from client
    char buffer[1024] = {0};
    if (recv(client_socket, buffer, 1024, 0) < 0) {
        printf(""Failed to receive message from client\n"");","//FormAI DATASET v1.0 Category: Socket programming ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 5

void *client_handler(void *arg);

int main() {

    // create socket file descriptor
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Failed to create socket descriptor\n"");
        return -1;
    }

    // prepare sockaddr_in structure
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(PORT);

    // bind socket to address and port
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) {
        printf(""Failed to bind socket to address and port\n"");
        close(server_socket);
        return -1;
    }

    // listen for incoming connections
    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Failed to listen for incoming connections\n"");
        close(server_socket);
        return -1;
    }

    // accept incoming connections and handle them in separate threads
    while (1) {

        // accept incoming connection
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket < 0) {
            printf(""Failed to accept incoming connection\n"");
            close(server_socket);
            return -1;
        }

        // create thread for client handling
        pthread_t tid;
        if (pthread_create(&tid, NULL, client_handler, (void *)&client_socket) < 0) {
            printf(""Failed to create client handling thread\n"");
            close(client_socket);
            continue;
        }
    }
}

void *client_handler(void *arg) {

    // get socket file descriptor from argument
    int client_socket = *(int *)arg;

    // receive message from client
    char buffer[1024] = {0};
    if (recv(client_socket, buffer, 1024, 0) < 0) {
        printf(""Failed to receive message from client\n"");
        close(client_socket);
        pthread_exit(NULL);
    }

    // check if message is a palindrome
    int left = 0, right = strlen(buffer) - 1;
    while (right > left) {
        if (buffer[left++] != buffer[right--]) {
            // not a palindrome, send response to client
            char response[] = ""Not a palindrome\n"";
            send(client_socket, response, strlen(response), 0);
            close(client_socket);
            pthread_exit(NULL);
        }
    }

    // message is a palindrome, send response to client
    char response[] = ""Palindrome\n"";
    send(client_socket, response, strlen(response), 0);
    close(client_socket);
    pthread_exit(NULL);
}",96,5.5
VULNERABLE,gemini_pro-14691.c,yes,19,5,handle_client,"
  file gemini_pro-14691.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientfd'",dereference failure: accessed expired variable pointer,"
// Define the function to be executed by the thread
void *handle_client(void *arg)
{
    // Get the socket descriptor for the client
    int sockfd = *(int *)arg;

    // Read the message from the client
    char buffer[MAXLINE];
    int n = read(sockfd, buffer, MAXLINE);
    if (n < 0)","//GEMINI-pro DATASET v1.0 Category: Networking ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define MAXLINE 1024

// Define the function to be executed by the thread
void *handle_client(void *arg)
{
    // Get the socket descriptor for the client
    int sockfd = *(int *)arg;

    // Read the message from the client
    char buffer[MAXLINE];
    int n = read(sockfd, buffer, MAXLINE);
    if (n < 0)
    {
        perror(""Error reading from client"");
        return NULL;
    }

    // Process the message from the client
    // ...

    // Write the response to the client
    n = write(sockfd, buffer, strlen(buffer));
    if (n < 0)
    {
        perror(""Error writing to client"");
        return NULL;
    }

    // Close the socket for the client
    close(sockfd);

    // Return NULL to indicate that the thread has finished executing
    return NULL;
}

int main()
{
    // Create a socket for the server
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0)
    {
        perror(""Error creating socket"");
        return -1;
    }

    // Set the socket options
    int opt = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
    {
        perror(""Error setting socket options"");
        return -1;
    }

    // Bind the socket to the port
    struct sockaddr_in servaddr;
    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);
    if (bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror(""Error binding socket to port"");
        return -1;
    }

    // Listen for incoming connections
    if (listen(sockfd, 5) < 0)
    {
        perror(""Error listening for incoming connections"");
        return -1;
    }

    // Main loop
    while (1)
    {
        // Accept incoming connections
        struct sockaddr_in cliaddr;
        socklen_t len = sizeof(cliaddr);
        int clientfd = accept(sockfd, (struct sockaddr *)&cliaddr, &len);
        if (clientfd < 0)
        {
            perror(""Error accepting incoming connection"");
            continue;
        }

        // Create a new thread to handle the client
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, &clientfd) != 0)
        {
            perror(""Error creating thread"");
            close(clientfd);
            continue;
        }

        // Detach the thread so that it can run independently
        pthread_detach(thread);
    }

    // Close the socket for the server
    close(sockfd);

    return 0;
}",115,5.5
VULNERABLE,gpt35-63037.c,yes,38,23,recvFromClient,"
  file gpt35-63037.c line 38 column 23 function recvFromClient
","
  c:@F@recvFromClient at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `cl'",dereference failure: accessed expired variable pointer,"// Function to handle messages received from specific client
void *recvFromClient(void *args) {
    struct client *cl = (struct client *) args;
    char inBuffer[MAX_MSG_LENGTH];
    while (1) {
        int valRead = read(cl->sockfd, inBuffer, MAX_MSG_LENGTH);
        if (valRead == 0) {
            printf(""Client %s disconnected\n"", cl->name);
            close(cl->sockfd);
            pthread_exit(NULL);
        }","//FormAI DATASET v1.0 Category: Networking ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_MSG_LENGTH 1024

// Client struct to hold socket info
struct client {
    int sockfd;
    char name[50];
};

// Function to handle messages sent to all clients
void *sendToAll(void *args) {
    struct client *cl = (struct client *) args;
    char msg[MAX_MSG_LENGTH];
    while (1) {
        fgets(msg, MAX_MSG_LENGTH, stdin);
        msg[strcspn(msg, ""\n"")] = '\0'; // remove newline character
        sprintf(msg, ""%s: %s"", cl->name, msg);
        if (send(cl->sockfd, msg, strlen(msg), 0) < 0) {
            perror(""Error sending message to all clients"");
        }
    }
}

// Function to handle messages received from specific client
void *recvFromClient(void *args) {
    struct client *cl = (struct client *) args;
    char inBuffer[MAX_MSG_LENGTH];
    while (1) {
        int valRead = read(cl->sockfd, inBuffer, MAX_MSG_LENGTH);
        if (valRead == 0) {
            printf(""Client %s disconnected\n"", cl->name);
            close(cl->sockfd);
            pthread_exit(NULL);
        }
        inBuffer[valRead] = '\0';
        printf(""%s\n"", inBuffer);
    }
}

int main(int argc, char const *argv[]) {
    int serverfd, newSocket, valRead;
    struct sockaddr_in serverAddr;
    struct client clientList[10];
    pthread_t sendThread;

    // Create socket
    serverfd = socket(AF_INET, SOCK_STREAM, 0);
    if (serverfd < 0) {
        perror(""Error creating socket"");
        exit(EXIT_FAILURE);
    }

    // Setup server address and bind socket
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddr.sin_port = htons(PORT);

    // Bind socket to address
    if (bind(serverfd, (struct sockaddr *) &serverAddr, sizeof(serverAddr)) < 0) {
        perror(""Error binding socket"");
        exit(EXIT_FAILURE);
    }

    // Start listening for incoming connections
    if (listen(serverfd, 10) < 0) {
        perror(""Error listening for connections"");
        exit(EXIT_FAILURE);
    }

    printf(""Server listening on port %d\n"", PORT);
    int clientCount = 0;

    // Loop for accepting new clients and handling messages
    while (1) {
        // Accept new connections
        newSocket = accept(serverfd, (struct sockaddr *) NULL, NULL);
        if (newSocket < 0) {
            perror(""Error accepting connection"");
            exit(EXIT_FAILURE);
        }

        // Prompt client for name and add to client list
        struct client cl;
        cl.sockfd = newSocket;
        printf(""Enter your name: "");
        fgets(cl.name, 50, stdin);
        cl.name[strcspn(cl.name, ""\n"")] = '\0'; // remove newline character
        clientList[clientCount] = cl;
        clientCount++;

        // Create thread for receiving messages from client
        pthread_t recvThread;
        if (pthread_create(&recvThread, NULL, recvFromClient, (void *) &cl) != 0) {
            perror(""Error creating thread"");
            exit(EXIT_FAILURE);
        }

        // Start thread for sending message to all clients
        if (clientCount == 1) { // start thread only once
            if (pthread_create(&sendThread, NULL, sendToAll, (void *) &cl) != 0) {
                perror(""Error creating thread"");
                exit(EXIT_FAILURE);
            }
        }
    }

    return 0;
}",117,5.0
VULNERABLE,falcon180b-20962.c,yes,85,5,handle_client,"
  file falcon180b-20962.c line 85 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *handle_client(void *socket_desc) {
    int sock = *((int *) socket_desc);
    char buffer[MAX_MESSAGE_LENGTH];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_LENGTH);
        int bytes_received = recv(sock, buffer, MAX_MESSAGE_LENGTH, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MESSAGE_LENGTH 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc);

int main(int argc, char **argv) {
    int server_socket;
    struct sockaddr_in server_addr;
    int opt = 1;
    int addrlen = sizeof(server_addr);

    // Create socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    // Set options on the socket
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    // Bind the socket
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, 3) < 0) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is running on port 8080\n"");

    while (1) {
        socklen_t client_len;
        int client_socket = accept(server_socket, (struct sockaddr *)&server_addr, &client_len);

        if (client_socket < 0) {
            perror(""accept"");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Please try again later.\n"");
        } else {
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}

void *handle_client(void *socket_desc) {
    int sock = *((int *) socket_desc);
    char buffer[MAX_MESSAGE_LENGTH];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_LENGTH);
        int bytes_received = recv(sock, buffer, MAX_MESSAGE_LENGTH, 0);

        if (bytes_received <= 0) {
            close(sock);
            pthread_exit(NULL);
        }

        send(sock, buffer, strlen(buffer), 0);
    }
}",99,6.5
VULNERABLE,falcon180b-30477.c,yes,29,5,handle_client,"
  file falcon180b-30477.c line 29 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int main_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: System administration ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <termios.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>

#define TRUE 1
#define FALSE 0
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int main_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket!= -1) {
            client_sockets[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",80,4.5
VULNERABLE,gpt35-75842.c,yes,68,3,handle_client,"
  file gpt35-75842.c line 68 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"
  return 0;
}

void *handle_client(void *socket_ptr) {
  int socket = *(int *)socket_ptr;
  int recv_len;
  char buffer[1024] = {0};

  while ((recv_len = recv(socket, buffer, 1024, 0)) > 0) {
    // Echo back the message to the client","//FormAI DATASET v1.0 Category: Educational ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

void *handle_client(void *);

int main(int argc, char const *argv[]) {
  int server_fd, new_socket;
  struct sockaddr_in address;
  int opt = 1;
  int addrlen = sizeof(address);
  pthread_t thread;

  // Create TCP socket
  if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror(""socket failed"");
    exit(EXIT_FAILURE);
  }

  // Set socket options
  if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
    perror(""setsockopt failed"");
    exit(EXIT_FAILURE);
  }

  // Bind socket to address and port
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(PORT);

  if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
    perror(""bind failed"");
    exit(EXIT_FAILURE);
  }

  // Listen for incoming connections
  if (listen(server_fd, 3) < 0) {
    perror(""listen failed"");
    exit(EXIT_FAILURE);
  }

  printf(""Server running on port %d\n"", PORT);

  // Accept incoming connections in a loop
  while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen))) {
    printf(""New client connected: %s:%d\n"", inet_ntoa(address.sin_addr), ntohs(address.sin_port));

    // Spawn a new thread to handle the client
    if (pthread_create(&thread, NULL, handle_client, (void *)&new_socket) < 0) {
      perror(""pthread_create failed"");
      exit(EXIT_FAILURE);
    }

    pthread_detach(thread);
  }

  return 0;
}

void *handle_client(void *socket_ptr) {
  int socket = *(int *)socket_ptr;
  int recv_len;
  char buffer[1024] = {0};

  while ((recv_len = recv(socket, buffer, 1024, 0)) > 0) {
    // Echo back the message to the client
    send(socket, buffer, recv_len, 0);
  }

  printf(""Client disconnected\n"");

  close(socket);
  return NULL;
}",81,4.5
VULNERABLE,falcon180b-55297.c,yes,21,5,handle_client,"
  file falcon180b-55297.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 5

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 51, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-39984.c,yes,24,5,handle_client,"
  file falcon180b-39984.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

char *response = ""HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<html><body><h1>Welcome to the Smart Home Light Control System!</h1></body></html>"";

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

char *response = ""HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<html><body><h1>Welcome to the Smart Home Light Control System!</h1></body></html>"";

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        send(client_socket, response, strlen(response), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\r\n"", strlen(""Server is full. Please try again later.\r\n""), 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-50204.c,yes,18,5,handle_client,"
  file falcon180b-50204.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
pthread_t thread_ids[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
pthread_t thread_ids[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5000);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 5000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        pthread_create(&thread_ids[num_clients], NULL, handle_client, (void *) &client_socket);
        num_clients++;
    }

    return 0;
}",87,6.0
VULNERABLE,falcon180b-32820.c,yes,17,5,handle_client,"
  file falcon180b-32820.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",66,3.0
VULNERABLE,gemini_pro-33913.c,yes,50,5,thread_func,"
  file gemini_pro-33913.c line 50 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientfd'",dereference failure: accessed expired variable pointer,"}

// Thread function
void *thread_func(void *arg) {
    // Get the socket descriptor
    int sockfd = *(int *)arg;

    // Receive the filename from the client
    char filename[BUFFER_SIZE];
    int bytes_received = recv(sockfd, filename, BUFFER_SIZE, 0);
    if (bytes_received < 0) {","//GEMINI-pro DATASET v1.0 Category: Antivirus scanner ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 4444
#define BUFFER_SIZE 1024

// Antivirus scanner function
int scan_file(char *filename) {
    // Open the file
    FILE *fp = fopen(filename, ""rb"");
    if (fp == NULL) {
        perror(""fopen"");
        return -1;
    }

    // Read the file into a buffer
    int size = 1000000;
    char *buffer = malloc(size);
    int bytes_read = fread(buffer, 1, size, fp);

    // Close the file
    fclose(fp);

    // Scan the buffer for viruses
    int num_viruses = 0;
    for (int i = 0; i < bytes_read; i++) {
        if (buffer[i] == 'V') {
            num_viruses++;
        }
    }

    // Free the buffer
    free(buffer);

    // Return the number of viruses found
    return num_viruses;
}

// Thread function
void *thread_func(void *arg) {
    // Get the socket descriptor
    int sockfd = *(int *)arg;

    // Receive the filename from the client
    char filename[BUFFER_SIZE];
    int bytes_received = recv(sockfd, filename, BUFFER_SIZE, 0);
    if (bytes_received < 0) {
        perror(""recv"");
        close(sockfd);
        pthread_exit(NULL);
    }

    // Scan the file for viruses
    int num_viruses = scan_file(filename);

    // Send the number of viruses found to the client
    int bytes_sent = send(sockfd, &num_viruses, sizeof(int), 0);
    if (bytes_sent < 0) {
        perror(""send"");
        close(sockfd);
        pthread_exit(NULL);
    }

    // Close the socket
    close(sockfd);

    // Exit the thread
    pthread_exit(NULL);
}

int main() {
    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror(""socket"");
        return -1;
    }

    // Set the socket options
    int opt = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)) < 0) {
        perror(""setsockopt"");
        close(sockfd);
        return -1;
    }

    // Bind the socket to the port
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);
    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror(""bind"");
        close(sockfd);
        return -1;
    }

    // Listen for incoming connections
    if (listen(sockfd, 5) < 0) {
        perror(""listen"");
        close(sockfd);
        return -1;
    }

    // Accept incoming connections and create threads for each client
    while (1) {
        int clientfd = accept(sockfd, NULL, NULL);
        if (clientfd < 0) {
            perror(""accept"");
            continue;
        }

        // Create a new thread for the client
        pthread_t thread;
        if (pthread_create(&thread, NULL, thread_func, &clientfd) != 0) {
            perror(""pthread_create"");
            close(clientfd);
            continue;
        }
    }

    // Close the socket
    close(sockfd);

    return 0;
}",135,5.0
VULNERABLE,falcon180b-9182.c,yes,17,5,handle_client,"
  file falcon180b-9182.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int clients_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Tower of Hanoi Problem ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 5000

int clients[MAX_CLIENTS];
int clients_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is ready to accept connections...\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (clients_count >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[clients_count] = client_socket;
        clients_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",70,3.5
VULNERABLE,falcon180b-64262.c,yes,18,5,handle_client,"
  file falcon180b-64262.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            client_socket = -1;
            break;
        }

        send(client_socket, buffer, strlen(buffer), 0);
    }
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (client_sockets[i]!= sender_socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,3.0
VULNERABLE,gpt35-23638.c,yes,29,5,handleClient,"
  file gpt35-23638.c line 29 column 5 function handleClient
","
  c:@F@handleClient at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"struct client_info clients[MAX_CLIENTS];

// Function to handle client
void *handleClient(void *arg) {
    // Get the socket file descriptor
    int socket_fd = *(int*)arg;

    // Receive the nickname
    char nickname[20];
    if (recv(socket_fd, nickname, sizeof(nickname), 0) <= 0) {
        perror(""Nickname failed to receive"");","//FormAI DATASET v1.0 Category: Networking ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 9000
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

// Structure for client Information
struct client_info {
    int socket_fd;
    struct sockaddr_in address;
    char nickname[20];
};

// Global variables
int client_count = 0;
struct client_info clients[MAX_CLIENTS];

// Function to handle client
void *handleClient(void *arg) {
    // Get the socket file descriptor
    int socket_fd = *(int*)arg;

    // Receive the nickname
    char nickname[20];
    if (recv(socket_fd, nickname, sizeof(nickname), 0) <= 0) {
        perror(""Nickname failed to receive"");
        close(socket_fd);
        return NULL;
    };
    // store the client information
    struct client_info client;
    client.socket_fd = socket_fd;
    client.address = clients[client_count].address;
    strcpy(client.nickname, nickname);
    clients[client_count++] = client;

    // Welcome message
    char welcome_msg[BUFFER_SIZE];
    sprintf(welcome_msg, ""%s has joined the chat\n"", nickname);
    for (int i = 0; i < client_count; i++) {
        send(clients[i].socket_fd, welcome_msg, strlen(welcome_msg), 0);
    }

    // Start the chat
    char buffer[BUFFER_SIZE];
    while (1) {
        // Receive message
        int receive_status = recv(socket_fd, buffer, sizeof(buffer), 0);
        if (receive_status <= 0) {
            printf(""%s left the chat\n"", nickname);
            break;
        }

        // Check if message is exit command
        if (strcmp(buffer, ""exit\n"") == 0) {
            printf(""%s left the chat\n"", nickname);
            break;
        }

        // Send message to all clients
        for (int i = 0; i < client_count; i++) {
            if (clients[i].socket_fd != socket_fd) {
                char message[BUFFER_SIZE];
                sprintf(message, ""%s: %s"", nickname, buffer);
                send(clients[i].socket_fd, message, strlen(message), 0);
            }
        }
    }

    // Remove the client from active client list
    for (int i = 0; i < client_count; i++) {
        if (clients[i].socket_fd == socket_fd) {
            int j;
            for (j = i; j < client_count - 1; j++) {
                clients[j] = clients[j+1];
            }
            client_count--;
            break;
        }
    }

    // Notify all clients
    char leave_msg[BUFFER_SIZE];
    sprintf(leave_msg, ""%s left the chat\n"", nickname);
    for (int i = 0; i < client_count; i++) {
        send(clients[i].socket_fd, leave_msg, strlen(leave_msg), 0);
    }

    // Close the socket
    close(socket_fd);

    return NULL;
}

// Main function
int main() {
    // Create a socket
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror(""Socket creation failed"");
        exit(1);
    }

    // Set server address
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(PORT);

    // Bind the socket
    if (bind(server_fd, (struct sockaddr*)&server_address, sizeof(server_address)) == -1) {
        perror(""Bind failed"");
        exit(1);
    }

    // Listen for incoming connections
    if (listen(server_fd, MAX_CLIENTS) == -1) {
        perror(""Listen failed"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    // Loop for accepting clients
    while (1) {
        // Accept a client connection
        struct sockaddr_in client_address;
        socklen_t address_len = sizeof(client_address);
        int client_fd = accept(server_fd, (struct sockaddr*)&client_address, &address_len);
        if (client_fd == -1) {
            perror(""Accept failed"");
            continue;
        }

        // Check if maximum clients limit has been reached
        if (client_count == MAX_CLIENTS) {
            printf(""Maximum clients limit reached. Connection request rejected.\n"");
            close(client_fd);
            continue;
        }

        // Create a thread to handle client
        pthread_t thread;
        if (pthread_create(&thread, NULL, handleClient, &client_fd) != 0) {
            perror(""Thread creation failed"");
            close(client_fd);
        }
        // Detach the thread
        pthread_detach(thread);
    }

    // Close the server socket
    close(server_fd);

    return 0;
}",164,10.0
VULNERABLE,falcon180b-53792.c,yes,19,5,handle_client,"
  file falcon180b-53792.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == client_socket) {
            clients[i] = -1;
        }
    }

    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket!= -1) {
            printf(""Client %d connected\n"", client_socket);

            for (int i = 0; i < num_clients; i++) {
                if (clients[i] == -1) {
                    clients[i] = client_socket;
                    num_clients++;
                    break;
                }
            }

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    close(server_socket);

    return 0;
}",98,7.5
VULNERABLE,gpt35-68313.c,yes,16,5,handle_client,"
  file gpt35-68313.c line 16 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"#define PORT 8080

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg){
    int client_sock = *((int *)arg);
    char buffer[1024] = {0};

    while(1){
        memset(buffer, 0, sizeof(buffer));
        int valread = read(client_sock, buffer, 1024);","//FormAI DATASET v1.0 Category: TCP/IP Programming ; Style: decentralized
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<unistd.h>
#include<pthread.h>

#define PORT 8080

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg){
    int client_sock = *((int *)arg);
    char buffer[1024] = {0};

    while(1){
        memset(buffer, 0, sizeof(buffer));
        int valread = read(client_sock, buffer, 1024);
        if(valread < 1){
            close(client_sock);
            return NULL;
        }
        printf(""Client sent: %s"", buffer);

        if(strcmp(buffer, ""exit\n"") == 0){
            close(client_sock);
            return NULL;
        }

        pthread_mutex_lock(&mutex);
        FILE *fp = fopen(""messages.txt"", ""a"");
        fprintf(fp, ""Client %d: %s"", client_sock, buffer);
        fclose(fp);
        pthread_mutex_unlock(&mutex);

        send(client_sock, buffer, strlen(buffer), 0);
    }
}

int main(){
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};

    // Create server socket
    if((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0){
        perror(""Socket failed"");
        exit(EXIT_FAILURE);
    }

    // Set server socket options
    if(setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))){
        perror(""setsockopt failed"");
        exit(EXIT_FAILURE);
    }
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind server socket to port
    if(bind(server_fd, (struct sockaddr *)&address, addrlen) < 0){
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if(listen(server_fd, 5) < 0){
        perror(""listen failed"");
        exit(EXIT_FAILURE);
    }
    printf(""Server started listening on port %d...\n"", PORT);

    // Handle incoming connections
    while((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))){
        printf(""New client connected. Client ID: %d\n"", new_socket);

        pthread_t thread_id;
        if(pthread_create(&thread_id, NULL, handle_client, (void *)&new_socket) < 0){
            perror(""thread create failed"");
            exit(EXIT_FAILURE);
        }
    }

    // Close server socket
    close(server_fd);
    return 0;
}",92,5.5
VULNERABLE,falcon180b-42921.c,yes,18,5,handle_client,"
  file falcon180b-42921.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define MAX_CLIENTS 10
#define MAX_MSG_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MSG_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MSG_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",68,3.0
VULNERABLE,falcon180b-543.c,yes,18,5,handle_client,"
  file falcon180b-543.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",84,5.0
VULNERABLE,falcon180b-36916.c,yes,51,5,scheduler_thread,"
  file falcon180b-36916.c line 51 column 5 function scheduler_thread
","
  c:@F@scheduler_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `scheduler'",dereference failure: accessed expired variable pointer,"}

// Scheduler thread function
void *scheduler_thread(void *arg) {
    scheduler_t *scheduler = arg;
    task_t *task = scheduler->head;

    while (task!= NULL) {
        task->function(task->param);
        task = task->next;
    }","//Falcon-180B DATASET v1.0 Category: Task Scheduler ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

// Task structure
typedef struct {
    void (*function)(void *param);
    void *param;
    struct task *next;
} task_t;

// Task Scheduler structure
typedef struct {
    task_t *head;
    pthread_t scheduler_thread;
} scheduler_t;

// Function prototypes
void add_task(scheduler_t *scheduler, void (*function)(void *param), void *param);
void start_scheduler(scheduler_t *scheduler);
void *scheduler_thread(void *arg);

// Add a task to the scheduler
void add_task(scheduler_t *scheduler, void (*function)(void *param), void *param) {
    task_t *task = malloc(sizeof(task_t));
    task->function = function;
    task->param = param;
    task->next = NULL;

    if (scheduler->head == NULL) {
        scheduler->head = task;
    } else {
        task_t *current = scheduler->head;
        while (current->next!= NULL) {
            current = current->next;
        }
        current->next = task;
    }
}

// Start the scheduler
void start_scheduler(scheduler_t *scheduler) {
    pthread_create(&scheduler->scheduler_thread, NULL, scheduler_thread, scheduler);
}

// Scheduler thread function
void *scheduler_thread(void *arg) {
    scheduler_t *scheduler = arg;
    task_t *task = scheduler->head;

    while (task!= NULL) {
        task->function(task->param);
        task = task->next;
    }

    return NULL;
}

// Example task function
void example_task(void *param) {
    printf(""Hello, world!\n"");
}

int main() {
    scheduler_t scheduler;
    scheduler.head = NULL;
    scheduler.scheduler_thread = 0;

    add_task(&scheduler, example_task, NULL);

    start_scheduler(&scheduler);

    return 0;
}",76,1.6
VULNERABLE,falcon180b-36928.c,yes,20,5,handle_request,"
  file falcon180b-36928.c line 20 column 5 function handle_request
","
  c:@F@handle_request at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_request(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_request(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d requested: %s\n"", client_socket, request);

        // do something with the request

        send(client_socket, ""Request processed."", strlen(""Request processed.""), 0);
    }

    close(client_socket);
    num_clients--;
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_request, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        accept_connections();
    }

    return 0;
}",68,2.667
VULNERABLE,falcon180b-12584.c,yes,36,5,execute_thread,"
  file falcon180b-12584.c line 36 column 5 function execute_thread
","
  c:@F@execute_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int total_time_quanta = 0;

// Define the function to execute a thread
void* execute_thread(void* arg) {
    // Get the thread ID
    int thread_id = *(int*) arg;

    // Calculate the burst time
    int burst_time = ready_queue[thread_id].burst_time;

    // Calculate the waiting time","//Falcon-180B DATASET v1.0 Category: CPU Scheduling Algorithms ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Define the maximum number of threads
#define MAX_THREADS 10

// Define the thread structure
typedef struct {
    int id;
    int priority;
    int burst_time;
    int waiting_time;
    int turnaround_time;
} Thread;

// Define the ready queue
Thread ready_queue[MAX_THREADS];

// Define the number of threads currently in the system
int num_threads = 0;

// Define the current time
int current_time = 0;

// Define the time quantum
int time_quantum = 2;

// Define the total number of time quanta
int total_time_quanta = 0;

// Define the function to execute a thread
void* execute_thread(void* arg) {
    // Get the thread ID
    int thread_id = *(int*) arg;

    // Calculate the burst time
    int burst_time = ready_queue[thread_id].burst_time;

    // Calculate the waiting time
    int waiting_time = 0;

    // Calculate the turnaround time
    int turnaround_time = 0;

    // Execute the thread
    printf(""Thread %d is executing...\n"", thread_id);
    sleep(burst_time / time_quantum);

    // Update the waiting time
    waiting_time = burst_time - turnaround_time;

    // Update the turnaround time
    turnaround_time = burst_time + waiting_time;

    // Print the results
    printf(""Thread %d finished execution.\n"", thread_id);
    printf(""Waiting time: %d\n"", waiting_time);
    printf(""Turnaround time: %d\n"", turnaround_time);

    // Exit the thread
    pthread_exit(0);
}

// Define the function to add a thread to the ready queue
void add_thread(int id, int priority, int burst_time) {
    // Check if the ready queue is full
    if (num_threads >= MAX_THREADS) {
        printf(""Error: Ready queue is full.\n"");
        return;
    }

    // Add the thread to the ready queue
    ready_queue[num_threads].id = id;
    ready_queue[num_threads].priority = priority;
    ready_queue[num_threads].burst_time = burst_time;

    // Increment the number of threads
    num_threads++;
}

// Define the function to execute the threads
void execute_threads() {
    // Initialize the current time
    current_time = 0;

    // Initialize the total number of time quanta
    total_time_quanta = 0;

    // Execute each thread
    for (int i = 0; i < num_threads; i++) {
        // Calculate the time quantum for the current thread
        int time_quanta = ready_queue[i].burst_time / time_quantum;

        // Update the total number of time quanta
        total_time_quanta += time_quanta;

        // Execute the thread
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, execute_thread, (void*) &i);

        // Update the current time
        current_time += time_quanta;
    }

    // Wait for all threads to finish
    for (int i = 0; i < num_threads; i++) {
        pthread_join(NULL, NULL);
    }
}

// Define the main function
int main() {
    // Add threads to the ready queue
    add_thread(1, 1, 5);
    add_thread(2, 2, 3);
    add_thread(3, 3, 8);

    // Execute the threads
    execute_threads();

    // Exit the program
    return 0;
}",125,1.75
VULNERABLE,gemini_pro-2385.c,yes,36,9,print_shape,"
  file gemini_pro-2385.c line 36 column 9 function print_shape
","
  c:@F@print_shape at file gemini_pro-2385.c line 70 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `sides'",dereference failure: accessed expired variable pointer,"// Print the details of a shape
void print_shape(shape_t *shape) {
    PRINTF(""Shape: %s"", shape->name);
    PRINTF(""Number of sides: %d"", shape->num_sides);
    for (int i = 0; i < shape->num_sides; i++) {
        PRINTF(""Side %d: %d"", i + 1, shape->sides[i]);
    }
}

// Create a rectangle
shape_t *create_rectangle(char *name, int width, int height) {","//GEMINI-pro DATASET v1.0 Category: Educational ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>

// Define a macro to simplify printing
#define PRINTF(fmt, ...) printf(fmt ""\n"", ##__VA_ARGS__)

// Define a struct to represent a shape
typedef struct shape {
    char *name;
    int num_sides;
    int *sides;
} shape_t;

// Create a new shape
shape_t *create_shape(char *name, int num_sides, int *sides) {
    shape_t *shape = malloc(sizeof(shape_t));
    shape->name = name;
    shape->num_sides = num_sides;
    shape->sides = sides;
    return shape;
}

// Free the memory allocated for a shape
void free_shape(shape_t *shape) {
    free(shape->name);
    free(shape->sides);
    free(shape);
}

// Print the details of a shape
void print_shape(shape_t *shape) {
    PRINTF(""Shape: %s"", shape->name);
    PRINTF(""Number of sides: %d"", shape->num_sides);
    for (int i = 0; i < shape->num_sides; i++) {
        PRINTF(""Side %d: %d"", i + 1, shape->sides[i]);
    }
}

// Create a rectangle
shape_t *create_rectangle(char *name, int width, int height) {
    int sides[] = {width, height, width, height};
    return create_shape(name, 4, sides);
}

// Create a circle
shape_t *create_circle(char *name, int radius) {
    int sides[] = {radius};
    return create_shape(name, 1, sides);
}

// Create a triangle
shape_t *create_triangle(char *name, int side1, int side2, int side3) {
    int sides[] = {side1, side2, side3};
    return create_shape(name, 3, sides);
}

// Main function
int main() {
    // Create a rectangle
    shape_t *rectangle = create_rectangle(""Rectangle"", 5, 3);

    // Create a circle
    shape_t *circle = create_circle(""Circle"", 4);

    // Create a triangle
    shape_t *triangle = create_triangle(""Triangle"", 3, 4, 5);

    // Print the details of each shape
    print_shape(rectangle);
    print_shape(circle);
    print_shape(triangle);

    // Free the memory allocated for each shape
    free_shape(rectangle);
    free_shape(circle);
    free_shape(triangle);

    return 0;
}",80,1.143
VULNERABLE,gemini_pro-21236.c,yes,59,12,checkAnswer,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file gemini_pro-21236.c line 59 column 12 function checkAnswer
  c:@F@checkAnswer at file gemini_pro-21236.c line 81 column 13 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `answer'",dereference failure: accessed expired variable pointer,"    return answer;
}

// Function to check if the answer is correct
int checkAnswer(char* answer, char* correctAnswer) {
    return strcmp(answer, correctAnswer) == 0;
}

// Function to display the result
void displayResult(int score) {
    printf(""Your score is %d out of %d\n"", score, sizeof(questions) / sizeof(struct Question));","//GEMINI-pro DATASET v1.0 Category: Online Examination System ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to store question and answer
struct Question {
    char question[256];
    char options[4][64];
    char answer[64];
};

// Array of questions
struct Question questions[] = {
    {
        ""What is the capital of India?"",
        {""Delhi"", ""Mumbai"", ""Chennai"", ""Kolkata""},
        ""Delhi""
    },
    {
        ""Who is the current Prime Minister of India?"",
        {""Narendra Modi"", ""Rahul Gandhi"", ""Arvind Kejriwal"", ""Mamata Banerjee""},
        ""Narendra Modi""
    },
    {
        ""What is the national animal of India?"",
        {""Tiger"", ""Lion"", ""Elephant"", ""Leopard""},
        ""Tiger""
    },
    {
        ""What is the national bird of India?"",
        {""Peacock"", ""Parrot"", ""Eagle"", ""Owl""},
        ""Peacock""
    },
    {
        ""What is the national flower of India?"",
        {""Lotus"", ""Rose"", ""Jasmine"", ""Marigold""},
        ""Lotus""
    }
};

// Function to display the question and options
void displayQuestion(struct Question question) {
    printf(""%s\n"", question.question);
    for (int i = 0; i < 4; i++) {
        printf(""%d. %s\n"", i + 1, question.options[i]);
    }
}

// Function to get the user's answer
char* getAnswer() {
    char answer[64];
    scanf(""%s"", answer);
    return answer;
}

// Function to check if the answer is correct
int checkAnswer(char* answer, char* correctAnswer) {
    return strcmp(answer, correctAnswer) == 0;
}

// Function to display the result
void displayResult(int score) {
    printf(""Your score is %d out of %d\n"", score, sizeof(questions) / sizeof(struct Question));
}

// Main function
int main() {
    // Initialize the score
    int score = 0;

    // Loop through the questions
    for (int i = 0; i < sizeof(questions) / sizeof(struct Question); i++) {
        // Display the question and options
        displayQuestion(questions[i]);

        // Get the user's answer
        char* answer = getAnswer();

        // Check if the answer is correct
        if (checkAnswer(answer, questions[i].answer)) {
            // Increment the score
            score++;
        }
    }

    // Display the result
    displayResult(score);

    return 0;
}",91,1.6
VULNERABLE,falcon180b-47337.c,yes,26,5,handle_client,"
  file falcon180b-47337.c line 26 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"        }
    }
}

void *handle_client(void *socket_ptr) {
    int client_socket = *(int *) socket_ptr;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Website Uptime Monitor ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < client_count; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

void *handle_client(void *socket_ptr) {
    int client_socket = *(int *) socket_ptr;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        broadcast(client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);

        if (client_socket!= -1) {
            printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

            clients[client_count++] = client_socket;
        }
    }

    return 0;
}",84,4.0
VULNERABLE,falcon180b-35438.c,yes,19,5,handle_client,"
  file falcon180b-35438.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            break;
        }
        send(client_socket, buffer, bytes_received, 0);
    }
    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if(client_socket < 0) {
            continue;
        }
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        clients[num_clients++] = client_socket;
    }

    return 0;
}",53,3.0
VULNERABLE,falcon180b-30194.c,yes,18,5,handle_client,"
  file falcon180b-30194.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 8080
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            printf(""Client %d disconnected\n"", client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Failed to create socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Failed to bind socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Failed to listen on socket\n"");
        exit(1);
    }

    printf(""Server is running on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket!= -1) {
            printf(""Client %d connected\n"", client_socket);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);

            client_sockets[num_clients++] = client_socket;
        }
    }

    return 0;
}",77,4.5
VULNERABLE,falcon180b-32098.c,yes,19,5,handle_client,"
  file falcon180b-32098.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""127.0.0.1"", &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Try again later.\n"");
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-34699.c,yes,22,5,handle_client,"
  file falcon180b-34699.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Spam Detection System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char *token = strtok(buffer, "" "");
        while (token!= NULL) {
            if (isalpha(token[0])) {
                int i;
                for (i = 0; i < strlen(token); i++) {
                    if (!isalpha(token[i])) {
                        break;
                    }
                }
                if (i == strlen(token)) {
                    printf(""Possible spam: %s\n"", token);
                }
            }
            token = strtok(NULL, "" "");
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    close(server_socket);
    return 0;
}",84,5.5
VULNERABLE,falcon180b-23128.c,yes,25,5,thread_function,"
  file falcon180b-23128.c line 25 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"
// Define the thread function
void *thread_function(void *arg)
{
    // Get the thread ID
    int thread_id = *(int *) arg;

    // Print a message from the thread
    printf(""Thread %d started.\n"", thread_id);

    // Wait for a random amount of time","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Define the number of threads
#define NUM_THREADS 5

// Define the size of the shared buffer
#define BUFFER_SIZE 10

// Define the mutex for the shared buffer
pthread_mutex_t buffer_mutex = PTHREAD_MUTEX_INITIALIZER;

// Define the shared buffer
int buffer[BUFFER_SIZE];

// Define the thread IDs
pthread_t threads[NUM_THREADS];

// Define the thread function
void *thread_function(void *arg)
{
    // Get the thread ID
    int thread_id = *(int *) arg;

    // Print a message from the thread
    printf(""Thread %d started.\n"", thread_id);

    // Wait for a random amount of time
    int delay = rand() % 5;
    usleep(delay * 100000);

    // Add a random number to the shared buffer
    int value = rand() % 100;
    pthread_mutex_lock(&buffer_mutex);
    buffer[thread_id] = value;
    pthread_mutex_unlock(&buffer_mutex);

    // Print a message from the thread
    printf(""Thread %d added %d to the buffer.\n"", thread_id, value);

    // Exit the thread
    return NULL;
}

int main()
{
    // Initialize the random number generator
    srand(time(NULL));

    // Create the threads
    for (int i = 0; i < NUM_THREADS; i++)
    {
        // Create the thread
        pthread_create(&threads[i], NULL, thread_function, (void *) &i);
    }

    // Wait for the threads to finish
    for (int i = 0; i < NUM_THREADS; i++)
    {
        // Join the thread
        pthread_join(threads[i], NULL);
    }

    // Print the contents of the shared buffer
    printf(""Shared buffer:\n"");
    for (int i = 0; i < NUM_THREADS; i++)
    {
        printf(""%d: %d\n"", i, buffer[i]);
    }

    return 0;
}",74,2.5
VULNERABLE,falcon180b-68206.c,yes,18,5,handle_client,"
  file falcon180b-68206.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *) socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 12345
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *) socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d said: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 48, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-6197.c,yes,73,17,main,"
  file falcon180b-6197.c line 73 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `name'",dereference failure: accessed expired variable pointer,"                scanf(""%s"", name);
                search_entry(phonebook, size, name);
                break;
            case 3:
                printf(""Enter name to delete: "");
                scanf(""%s"", name);
                delete_entry(phonebook, &size, name);
                break;
            case 4:
                printf(""Exiting...\n"");
                exit(0);","//Falcon-180B DATASET v1.0 Category: Phone Book ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ENTRIES 100 // Maximum number of entries in the phone book

struct entry {
    char name[50]; // Name of the person
    char phone[15]; // Phone number of the person
};

void add_entry(struct entry *phonebook, int size) {
    printf(""Enter name: "");
    scanf(""%s"", phonebook[size].name);
    printf(""Enter phone number: "");
    scanf(""%s"", phonebook[size].phone);
}

void search_entry(struct entry *phonebook, int size, char *name) {
    for (int i = 0; i < size; i++) {
        if (strcmp(phonebook[i].name, name) == 0) {
            printf(""Name: %s\nPhone number: %s\n"", phonebook[i].name, phonebook[i].phone);
            return;
        }
    }
    printf(""Entry not found.\n"");
}

void delete_entry(struct entry *phonebook, int *size, char *name) {
    for (int i = 0; i < *size; i++) {
        if (strcmp(phonebook[i].name, name) == 0) {
            for (int j = i; j < *size - 1; j++) {
                strcpy(phonebook[j].name, phonebook[j+1].name);
                strcpy(phonebook[j].phone, phonebook[j+1].phone);
            }
            (*size)--;
            return;
        }
    }
    printf(""Entry not found.\n"");
}

int main() {
    struct entry phonebook[MAX_ENTRIES];
    int size = 0;

    printf(""Phone Book\n"");
    printf(""--------------------\n"");

    while (1) {
        printf(""1. Add entry\n2. Search entry\n3. Delete entry\n4. Exit\n"");
        int choice;
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                if (size >= MAX_ENTRIES) {
                    printf(""Phone book is full.\n"");
                } else {
                    add_entry(phonebook, size);
                    size++;
                }
                break;
            case 2:
                printf(""Enter name to search: "");
                char name[50];
                scanf(""%s"", name);
                search_entry(phonebook, size, name);
                break;
            case 3:
                printf(""Enter name to delete: "");
                scanf(""%s"", name);
                delete_entry(phonebook, &size, name);
                break;
            case 4:
                printf(""Exiting...\n"");
                exit(0);
            default:
                printf(""Invalid choice.\n"");
        }
    }

    return 0;
}",85,3.75
VULNERABLE,falcon180b-40095.c,yes,18,5,handle_client,"
  file falcon180b-40095.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));","//Falcon-180B DATASET v1.0 Category: Digital Auction System ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 5

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);

    pthread_exit(0);
}

void accept_connections(int server_socket) {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections(server_socket);

    close(server_socket);

    return 0;
}",93,3.667
VULNERABLE,falcon180b-12002.c,yes,21,5,handle_client,"
  file falcon180b-12002.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        send(client_socket, buffer, bytes_received, 0);
    }
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (client_sockets[i]!= sender_socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(5000);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port 5000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",82,3.333
VULNERABLE,falcon180b-16857.c,yes,21,5,handle_client,"
  file falcon180b-16857.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>
#include <fcntl.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1000

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",66,3.5
VULNERABLE,falcon180b-66050.c,yes,18,5,handle_client,"
  file falcon180b-66050.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(sock, buffer, bytes_received, 0);
    }

    close(sock);
    return NULL;
}

int main() {
    int opt = 1;
    int addrlen = sizeof(struct sockaddr_in);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server is running on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (client_sockets[i] == 0) {
                client_sockets[i] = client_socket;
                pthread_create(&threads[i], NULL, handle_client, &client_socket);
                break;
            }
        }
    }

    return 0;
}",85,5.5
VULNERABLE,falcon180b-64882.c,yes,17,5,handle_client,"
  file falcon180b-64882.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    for (int i = 0; i < MAX_CLIENTS; i++) {
        if (clients[i] == client_socket) {
            clients[i] = -1;
            break;
        }
    }

    num_clients--;

    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 5);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",82,5.0
VULNERABLE,falcon180b-65520.c,yes,18,5,handle_client,"
  file falcon180b-65520.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        //TODO: Implement light control logic here

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            break;
        }

        printf(""Client connected: %d\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

        clients[num_clients++] = client_socket;
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port %d\n"", PORT);

    accept_connections(server_socket);

    return 0;
}",91,4.0
VULNERABLE,falcon180b-49080.c,yes,25,5,haunt_room,"
  file falcon180b-49080.c line 25 column 5 function haunt_room
","
  c:@F@haunt_room at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `room_id'",dereference failure: accessed expired variable pointer,"    {4, ""Library"", ""The library is lined with bookshelves that stretch to the ceiling. A single candle flickers on a desk, illuminating an old tome bound in human skin.""},
    {5, ""Basement"", ""The basement stairs groan under your weight as you descend into the darkness. The only light comes from a single bare bulb swinging overhead.""}
};

void *haunt_room(void *arg) {
    int room_id = *(int *) arg;
    printf(""You enter room %d...\n"", room_id);
    sleep(1);
    printf(""A chill runs down your spine as you feel a ghostly presence.\n"");
    sleep(2);
    printf(""The temperature drops suddenly, and your breath fogs in the air.\n"");","//Falcon-180B DATASET v1.0 Category: Haunted House Simulator ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

#define NUM_ROOMS 5
#define NUM_THREADS 10

struct room {
    int id;
    char *name;
    char *description;
};

struct room haunted_house[NUM_ROOMS] = {
    {1, ""Foyer"", ""You enter the haunted house through the creaky front door and find yourself in the dimly lit foyer. The air is thick with dust and cobwebs hang from the ceiling.""},
    {2, ""Living Room"", ""The living room is filled with antique furniture covered in sheets. A fireplace crackles in the corner, casting eerie shadows on the walls.""},
    {3, ""Kitchen"", ""The kitchen is dark and musty. Pots and pans hang from the ceiling, swaying slightly as if moved by an unseen force.""},
    {4, ""Library"", ""The library is lined with bookshelves that stretch to the ceiling. A single candle flickers on a desk, illuminating an old tome bound in human skin.""},
    {5, ""Basement"", ""The basement stairs groan under your weight as you descend into the darkness. The only light comes from a single bare bulb swinging overhead.""}
};

void *haunt_room(void *arg) {
    int room_id = *(int *) arg;
    printf(""You enter room %d...\n"", room_id);
    sleep(1);
    printf(""A chill runs down your spine as you feel a ghostly presence.\n"");
    sleep(2);
    printf(""The temperature drops suddenly, and your breath fogs in the air.\n"");
    sleep(1);
    printf(""You hear whispers echoing through the room, but you can't make out what they're saying.\n"");
    sleep(2);
    printf(""Suddenly, a gust of wind blows out your flashlight, plunging you into darkness.\n"");
    sleep(1);
    printf(""As your eyes adjust, you see a spectral figure materialize before you.\n"");
    sleep(2);
    printf(""It reaches out with icy fingers, and you feel a shiver run through your entire body.\n"");
    sleep(1);
    printf(""Just when you think you can't take it anymore, the ghostly apparition vanishes, leaving you alone in the darkness.\n"");
    sleep(2);
    printf(""You quickly exit the room, heart pounding in your chest.\n"");
    pthread_exit(0);
}

int main() {
    srand(time(NULL));

    int num_threads = NUM_THREADS;
    pthread_t threads[NUM_THREADS];

    for (int i = 0; i < num_threads; i++) {
        int room_id = rand() % NUM_ROOMS;
        pthread_create(&threads[i], NULL, haunt_room, &room_id);
        sleep(1);
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
        sleep(1);
    }

    return 0;
}",64,2.0
VULNERABLE,falcon180b-64660.c,yes,23,5,generate_fibonacci,"
  file falcon180b-64660.c line 23 column 5 function generate_fibonacci
","
  c:@F@generate_fibonacci at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `start_index'",dereference failure: accessed expired variable pointer,"// Semaphore for synchronization
sem_t semaphore;

// Function to generate Fibonacci sequence
void *generate_fibonacci(void *arg) {
    int start_index = *(int *) arg;
    int end_index = start_index + (NUM_FIBONACCI / NUM_THREADS);

    for (int i = start_index; i < end_index; i++) {
        if (fibonacci_numbers[i] == 0) {
            sem_wait(&semaphore);","//Falcon-180B DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define MAX_NUM_THREADS 10
#define MAX_NUM_FIBONACCI 100
#define NUM_THREADS 2
#define NUM_FIBONACCI 50

// Shared data between threads
int fibonacci_numbers[MAX_NUM_FIBONACCI];
int num_fibonacci;

// Semaphore for synchronization
sem_t semaphore;

// Function to generate Fibonacci sequence
void *generate_fibonacci(void *arg) {
    int start_index = *(int *) arg;
    int end_index = start_index + (NUM_FIBONACCI / NUM_THREADS);

    for (int i = start_index; i < end_index; i++) {
        if (fibonacci_numbers[i] == 0) {
            sem_wait(&semaphore);

            int prev_num = (i == 0)? 0 : fibonacci_numbers[i - 1];
            int curr_num = (i == 0)? 1 : fibonacci_numbers[i - 2] + prev_num;
            fibonacci_numbers[i] = curr_num;

            sem_post(&semaphore);
        }
    }

    return NULL;
}

// Main function
int main() {
    int thread_ids[NUM_THREADS];
    pthread_t threads[NUM_THREADS];

    // Initialize semaphore
    sem_init(&semaphore, 0, 1);

    // Create threads
    for (int i = 0; i < NUM_THREADS; i++) {
        int start_index = i * (NUM_FIBONACCI / NUM_THREADS);
        thread_ids[i] = i;
        pthread_create(&threads[i], NULL, generate_fibonacci, &start_index);
    }

    // Join threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print Fibonacci sequence
    printf(""Fibonacci sequence:\n"");
    for (int i = 0; i < num_fibonacci; i++) {
        printf(""%d "", fibonacci_numbers[i]);
    }

    return 0;
}",68,4.5
VULNERABLE,gemini_pro-23004.c,yes,16,5,client_thread,"
  file gemini_pro-23004.c line 16 column 5 function client_thread
","
  c:@F@client_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sockfd'",dereference failure: accessed expired variable pointer,"#define PORT 8080

// Client thread function
void *client_thread(void *arg)
{
    int sockfd = *(int *)arg;
    char buffer[1024];

    // Receive a message from the server
    int n = recv(sockfd, buffer, sizeof(buffer), 0);
    if (n == -1)","//GEMINI-pro DATASET v1.0 Category: Client Server Application ; Style: standalone
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

// Client thread function
void *client_thread(void *arg)
{
    int sockfd = *(int *)arg;
    char buffer[1024];

    // Receive a message from the server
    int n = recv(sockfd, buffer, sizeof(buffer), 0);
    if (n == -1)
    {
        perror(""recv"");
        exit(EXIT_FAILURE);
    }
    else if (n == 0)
    {
        printf(""Server disconnected\n"");
        close(sockfd);
        pthread_exit(NULL);
    }
    else
    {
        // Print the message received from the server
        printf(""Received from server: %s\n"", buffer);

        // Send a response to the server
        n = send(sockfd, ""Hello from client"", strlen(""Hello from client"") + 1, 0);
        if (n == -1)
        {
            perror(""send"");
            exit(EXIT_FAILURE);
        }
    }

    // Close the socket
    close(sockfd);

    return NULL;
}

// Server function
void *server_function(void *arg)
{
    int server_sockfd = *(int *)arg;

    // Listen for incoming connections
    int client_sockfd;
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    while ((client_sockfd = accept(server_sockfd, (struct sockaddr *)&client_addr, &client_addr_len)) >= 0)
    {
        pthread_t client_thread_id;

        // Create a new thread to handle the client connection
        if (pthread_create(&client_thread_id, NULL, client_thread, &client_sockfd) != 0)
        {
            perror(""pthread_create"");
            exit(EXIT_FAILURE);
        }
    }

    if (client_sockfd == -1)
    {
        perror(""accept"");
        exit(EXIT_FAILURE);
    }

    // Close the server socket
    close(server_sockfd);

    return NULL;
}

int main(int argc, char **argv)
{
    // Create a socket
    int server_sockfd;
    if ((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Bind the socket to an address and port
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);
    if (bind(server_sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
    {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_sockfd, 5) == -1)
    {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    // Create a thread to handle the server function
    pthread_t server_thread_id;
    if (pthread_create(&server_thread_id, NULL, server_function, &server_sockfd) != 0)
    {
        perror(""pthread_create"");
        exit(EXIT_FAILURE);
    }

    // Join the server thread
    pthread_join(server_thread_id, NULL);

    // Close the server socket
    close(server_sockfd);

    return 0;
}",129,4.333
VULNERABLE,falcon180b-7188.c,yes,19,5,handle_client,"
  file falcon180b-7188.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_REQUEST_SIZE];

    while (1) {
        memset(buffer, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8888
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_REQUEST_SIZE];

    while (1) {
        memset(buffer, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Request received from client %d: %s\n"", client_socket, buffer);

        if (strcmp(buffer, ""turn on"") == 0) {
            system(""echo 'Turning on lights'"");
        } else if (strcmp(buffer, ""turn off"") == 0) {
            system(""echo 'Turning off lights'"");
        } else {
            send(client_socket, ""Invalid request"", strlen(""Invalid request""), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full"", strlen(""Server full""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-58735.c,yes,17,5,thread_function,"
  file falcon180b-58735.c line 17 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Number of threads
#define NUM_THREADS 5

// Thread function
void *thread_function(void *arg) {
    int id = *(int*) arg;
    printf(""Thread %d started\n"", id);

    // Lock the mutex
    pthread_mutex_lock(&mutex);
","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex for synchronization
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for signaling
pthread_cond_t condition = PTHREAD_COND_INITIALIZER;

// Number of threads
#define NUM_THREADS 5

// Thread function
void *thread_function(void *arg) {
    int id = *(int*) arg;
    printf(""Thread %d started\n"", id);

    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Signal the main thread that a thread has started
    pthread_cond_signal(&condition);

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    // Do some work
    for (int i = 0; i < 1000000; i++) {
        printf(""Thread %d is working...\n"", id);
    }

    return NULL;
}

// Main function
int main() {
    pthread_t threads[NUM_THREADS];

    // Create threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_function, (void*) &i);
    }

    // Wait for threads to start
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_cond_wait(&condition, &mutex);
    }

    // Unlock the mutex and exit
    pthread_mutex_unlock(&mutex);
    printf(""All threads have started\n"");

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",60,3.0
VULNERABLE,falcon180b-70345.c,yes,20,5,handle_client,"
  file falcon180b-70345.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BACKLOG 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.0
VULNERABLE,falcon180b-67728.c,yes,21,5,handle_client,"
  file falcon180b-67728.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }
}

int main() {
    int server_port = 8080;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", server_port);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);

        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",93,6.0
VULNERABLE,falcon180b-1796.c,yes,21,5,handle_client,"
  file falcon180b-1796.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Too many clients\n"");
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.5
VULNERABLE,falcon180b-16471.c,yes,18,5,handle_client,"
  file falcon180b-16471.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",71,4.0
VULNERABLE,gpt35-35808.c,yes,20,3,client_communication,"
  file gpt35-35808.c line 20 column 3 function client_communication
","
  c:@F@client_communication at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `arg'",dereference failure: accessed expired variable pointer,"
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //mutex lock for thread safety

void *client_communication(void *arg) {
  char buffer[1024];
  int client_num = *(int*)arg;
  int client_fd = client_socket[client_num];

  while(1) {
    memset(buffer, 0, sizeof(buffer));
    ssize_t count = recv(client_fd, buffer, sizeof(buffer), 0); //receive message from client","//FormAI DATASET v1.0 Category: Chat server ; Style: intelligent
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define max_clients 2 //maximum number of clients that the server can handle

int num_clients = 0;
int client_socket[max_clients];

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //mutex lock for thread safety

void *client_communication(void *arg) {
  char buffer[1024];
  int client_num = *(int*)arg;
  int client_fd = client_socket[client_num];

  while(1) {
    memset(buffer, 0, sizeof(buffer));
    ssize_t count = recv(client_fd, buffer, sizeof(buffer), 0); //receive message from client
    if(count <= 0) {
      pthread_mutex_lock(&mutex);
      close(client_fd);
      printf(""Client %d disconnected.\n"", client_num+1);
      client_socket[client_num] = 0;
      num_clients--;
      pthread_mutex_unlock(&mutex);
      return NULL;
    }

    printf(""Client %d: %s"", client_num+1, buffer);

    pthread_mutex_lock(&mutex);
    for(int i=0; i<max_clients; i++) {
      if(client_socket[i] != 0 && i != client_num) { //send to all other clients
        send(client_socket[i], buffer, sizeof(buffer), 0);
      }
    }
    pthread_mutex_unlock(&mutex);
  }
}

int main() {
  int server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if(server_fd < 0) {
    perror(""socket() failed"");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in server_address, client_address;
  server_address.sin_family = AF_INET;
  server_address.sin_addr.s_addr = INADDR_ANY;
  server_address.sin_port = htons(8080);

  int address_len = sizeof(server_address);

  if(bind(server_fd, (struct sockaddr *)&server_address, address_len) < 0) {
    perror(""bind() failed"");
    exit(EXIT_FAILURE);
  }

  if(listen(server_fd, 2) < 0) { //server can handle maximum 2 clients
    perror(""listen() failed"");
    exit(EXIT_FAILURE);
  }

  printf(""Server is listening on port 8080...\n"");

  while(num_clients < max_clients) { //accept clients and create threads for them
    int client_fd = accept(server_fd, (struct sockaddr *)&client_address, (socklen_t *)&address_len);

    if(client_fd < 0) {
      perror(""accept() failed"");
      exit(EXIT_FAILURE);
    }

    printf(""Connection accepted from %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));

    pthread_mutex_lock(&mutex);
    client_socket[num_clients] = client_fd;
    printf(""Client %d connected.\n"", num_clients+1);
    num_clients++;

    pthread_t thread;
    int arg = num_clients-1;
    pthread_create(&thread, NULL, client_communication, &arg);
    pthread_mutex_unlock(&mutex);
  }
  return 0;
}",95,6.0
VULNERABLE,falcon180b-51986.c,yes,19,5,handle_client,"
  file falcon180b-51986.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Music Library Management System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);

        if (server_socket == -1) {
            printf(""Error creating socket\n"");
            exit(1);
        }

        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(PORT);
        server_addr.sin_addr.s_addr = INADDR_ANY;

        if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
            printf(""Error binding socket\n"");
            exit(1);
        }

        if (listen(server_socket, 3) == -1) {
            printf(""Error listening on socket\n"");
            exit(1);
        }

        printf(""Server is listening on port %d\n"", PORT);

        while (num_clients < MAX_CLIENTS) {
            socklen_t addr_size = sizeof(struct sockaddr_in);
            int client_socket = accept(server_socket, (struct sockaddr *) &client_sockets[num_clients], &addr_size);

            if (client_socket == -1) {
                printf(""Error accepting connection\n"");
            } else {
                num_clients++;
                pthread_t thread_id;
                pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            }
        }
    }
}

int main() {
    srand(time(NULL));

    accept_connections();

    return 0;
}",85,3.667
VULNERABLE,gpt35-35536.c,yes,70,5,client_handler,"
  file gpt35-35536.c line 70 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"    }
    return 0;
}

void *client_handler(void *args) {
    int client_sock = *(int *)args;
    char filename[BUF_SIZE];
    char recv_buf[BUF_SIZE];

    //get the name of the file to be received from the client
    memset(filename, '\0', BUF_SIZE);","//FormAI DATASET v1.0 Category: Networking ; Style: thoughtful
/*This C program is a simple file transfer Client-Server application using socket programming in C. 
It is created in a manner where the client sends a file named 'test.txt' to the server where it is then saved in the same directory where the server program is located.*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define BUF_SIZE 1024

void *client_handler(void *);

int main(int argc, char *argv[]) {
    int server_sock, client_sock;
    struct sockaddr_in server_addr, client_addr;
    char buf[BUF_SIZE];

    //Create a socket
    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror(""Error: Socket cannot be created"");
        return EXIT_FAILURE;
    }

    //Specify server details
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    //Bind the socket to the server address and port
    if (bind(server_sock, (struct sockaddr*) &server_addr, sizeof(server_addr)) == -1) {
        perror(""Error: Address binding failed"");
        return EXIT_FAILURE;
    }

    //Listen for incoming requests
    if (listen(server_sock, 5) == -1) {
        perror(""Error: Listen failed"");
        return EXIT_FAILURE;
    }

    puts(""Server waiting for incoming connections..."");

    while (1) {
        socklen_t client_len = sizeof(client_addr);

        //accept incoming client connection
        if ((client_sock = accept(server_sock, (struct sockaddr*) &client_addr, &client_len)) == -1) {
            perror(""Error: Accept failed"");
            return EXIT_FAILURE;
        }

        puts(""Connection Accepted"");

        //Handle client message in a separate thread
        pthread_t handler_thread;
        if (pthread_create(&handler_thread, NULL, client_handler, (void*) &client_sock) < 0) {
            perror(""Error: Thread creation failed"");
            return EXIT_FAILURE;
        }
    }
    return 0;
}

void *client_handler(void *args) {
    int client_sock = *(int *)args;
    char filename[BUF_SIZE];
    char recv_buf[BUF_SIZE];

    //get the name of the file to be received from the client
    memset(filename, '\0', BUF_SIZE);
    if (recv(client_sock, filename, BUF_SIZE, 0) == -1) {
        perror(""Error: File name receipt failed"");
        return NULL;
    }

    //open file or create if not present
    FILE *fp;
    if ((fp = fopen(filename, ""wb"")) == NULL) {
        perror(""Error: File creation failed"");
        return NULL;
    }

    //Receive data from client and save it to file
    memset(recv_buf, '\0', BUF_SIZE);
    int bytes_received;
    while ((bytes_received = recv(client_sock, recv_buf, BUF_SIZE, 0)) > 0) {
        fwrite(recv_buf, 1, bytes_received, fp);
    }

    if (bytes_received == -1) {
        perror(""Error: File download failed"");
    } else {
        puts(""File received successfully"");
    }

    fclose(fp);
    close(client_sock);
    return NULL;
}",104,6.0
VULNERABLE,llama2-13B_2413.c,yes,67,9,main,"
  file llama2-13B_2413.c line 67 column 9 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `index2'",dereference failure: accessed expired variable pointer,"    int arr[5] = {1, 2, 3, 4, 5};
    int target = 4;
    int* index = search_element(arr, 5, target);

    if (index != NULL) {
        printf(""Element found at index %d\n"", *index);
    } else {
        printf(""Element not found\n"");
    }

    return 0;","//LLAMA2-13B DATASET v1.0 Category: Searching algorithm ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to search an element in an array
int* search_element(int arr[], int size, int target) {
    int i, j, k;
    int* index = NULL;

    // Initialize the search range
    i = 0;
    j = size - 1;

    // Calculate the probability of finding the element in the first half of the array
    double p1 = (double)i / (double)size;

    // Calculate the probability of finding the element in the second half of the array
    double p2 = (double)(size - j) / (double)size;

    // Calculate the expected value of the search
    double expected = p1 * (i + 1) + p2 * (size - j);

    // Calculate the standard deviation of the search
    double stddev = sqrt(p1 * p2 * (i + 1) * (size - j));

    // Initialize the search loop
    for (k = 0; k < 100; k++) {
        // Generate a random number between 0 and 1
        double rnd = drand48();

        // Calculate the probability of the element being in the first half of the array
        double p = p1 + (rnd * (1 - p1)) * (1 - p2);

        // Calculate the index of the element in the first half of the array
        int index1 = (int)(i + (p * (size - i)));

        // Check if the element is found
        if (arr[index1] == target) {
            // Found the element, return the index
            return &index1;
        }

        // Calculate the probability of the element being in the second half of the array
        p = p2 + (rnd * (1 - p2)) * (1 - p1);

        // Calculate the index of the element in the second half of the array
        int index2 = (int)(size - (p * (i - (size - i))));

        // Check if the element is found
        if (arr[index2] == target) {
            // Found the element, return the index
            return &index2;
        }
    }

    // If the element is not found, return NULL
    return NULL;
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int target = 4;
    int* index = search_element(arr, 5, target);

    if (index != NULL) {
        printf(""Element found at index %d\n"", *index);
    } else {
        printf(""Element not found\n"");
    }

    return 0;
}",73,3.0
VULNERABLE,gpt35-46899.c,yes,18,5,client_handler,"
  file gpt35-46899.c line 18 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"int client_count = 0;
int client_sockets[MAX_CLIENTS];
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *client_handler(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    char message[1024];
    int n;

    pthread_mutex_lock(&mutex);","//FormAI DATASET v1.0 Category: Client Server Application ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8080
#define MAX_CLIENTS 10

int client_count = 0;
int client_sockets[MAX_CLIENTS];
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *client_handler(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    char message[1024];
    int n;

    pthread_mutex_lock(&mutex);
    client_count++;
    pthread_mutex_unlock(&mutex);

    printf(""New client connected - ID %d\n"", client_socket);

    while ((n = read(client_socket, buffer, 1024)) > 0) {
        buffer[n] = '\0';
        sprintf(message, ""Client %d: %s"", client_socket, buffer);
        printf(""%s"", message);

        pthread_mutex_lock(&mutex);
        for (int i = 0; i < client_count; i++) {
            if (client_sockets[i] != client_socket) {
                write(client_sockets[i], message, strlen(message));
            }
        }
        pthread_mutex_unlock(&mutex);
    }

    pthread_mutex_lock(&mutex);
    for (int i = 0; i < client_count; i++) {
        if (client_sockets[i] == client_socket) {
            for (int j = i; j < client_count-1; j++) {
                client_sockets[j] = client_sockets[j+1];
            }
            client_count--;
            break;
        }
    }
    close(client_socket);
    pthread_mutex_unlock(&mutex);

    printf(""Client %d disconnected\n"", client_socket);

    return NULL;
}

int main() {
    int server_socket, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    pthread_t tid;

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror(""Socket creation error"");
        return -1;
    }

    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""Bind error"");
        return -1;
    }

    if (listen(server_socket, 3) < 0) {
        perror(""Listen error"");
        return -1;
    }

    printf(""Server started and listening on port %d\n"", PORT);

    while (1) {
        if ((new_socket = accept(server_socket, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {
            perror(""Accept error"");
            break;
        }

        pthread_create(&tid, NULL, &client_handler, &new_socket);

        pthread_mutex_lock(&mutex);
        client_sockets[client_count] = new_socket;
        pthread_mutex_unlock(&mutex);
    }

    close(server_socket);
    return 0;
}",104,6.5
VULNERABLE,falcon180b-19638.c,yes,24,5,deposit,"
  file falcon180b-19638.c line 24 column 5 function deposit
","
  c:@F@deposit at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `account_id'",dereference failure: accessed expired variable pointer,"    {4, ""Alice Johnson"", 4000.00},
    {5, ""Charlie Brown"", 5000.00}
};

void *deposit(void *arg) {
    int account_id = *(int *)arg;
    Account *account = &accounts[account_id - 1];

    printf(""Depositing $100 into account %d (%s)\n"", account_id, account->name);
    account->balance += 100.00;
}","//Falcon-180B DATASET v1.0 Category: Banking Record System ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_ACCOUNTS 5
#define NUM_THREADS 10

typedef struct {
    int id;
    char name[50];
    float balance;
} Account;

Account accounts[NUM_ACCOUNTS] = {
    {1, ""John Doe"", 1000.00},
    {2, ""Jane Doe"", 2000.00},
    {3, ""Bob Smith"", 3000.00},
    {4, ""Alice Johnson"", 4000.00},
    {5, ""Charlie Brown"", 5000.00}
};

void *deposit(void *arg) {
    int account_id = *(int *)arg;
    Account *account = &accounts[account_id - 1];

    printf(""Depositing $100 into account %d (%s)\n"", account_id, account->name);
    account->balance += 100.00;
}

void *withdraw(void *arg) {
    int account_id = *(int *)arg;
    Account *account = &accounts[account_id - 1];

    printf(""Withdrawing $100 from account %d (%s)\n"", account_id, account->name);
    account->balance -= 100.00;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int i;

    for (i = 0; i < NUM_THREADS; i++) {
        int account_id = rand() % NUM_ACCOUNTS + 1;
        pthread_create(&threads[i], NULL, i % 2 == 0? deposit : withdraw, (void *)&account_id);
    }

    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",53,2.0
VULNERABLE,falcon180b-63239.c,yes,19,5,monitor_thread,"
  file falcon180b-63239.c line 19 column 5 function monitor_thread
","
  c:@F@monitor_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `sock'",dereference failure: accessed expired variable pointer,"
int sockets[MAX_SOCKETS];
int num_sockets = 0;

void *monitor_thread(void *arg) {
    int sock = *(int *) arg;
    char buffer[BUFFER_SIZE];
    int bytes_received;

    while (1) {
        bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_SOCKETS 10
#define BUFFER_SIZE 1024

int sockets[MAX_SOCKETS];
int num_sockets = 0;

void *monitor_thread(void *arg) {
    int sock = *(int *) arg;
    char buffer[BUFFER_SIZE];
    int bytes_received;

    while (1) {
        bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }

        printf(""Received %d bytes on socket %d\n"", bytes_received, sock);
    }

    close(sock);
    return NULL;
}

void start_monitoring(int sock) {
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, monitor_thread, (void *) &sock);
    num_sockets++;
}

int main() {
    int server_sock, client_sock, new_sock;
    struct sockaddr_in server_addr, client_addr;
    int opt = 1;
    int addrlen = sizeof(client_addr);

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(12345);

    server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        printf(""Error setting socket option\n"");
        exit(1);
    }

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_sock, MAX_SOCKETS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    while (1) {
        client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &addrlen);
        if (client_sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Accepted connection from %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        start_monitoring(client_sock);
    }

    return 0;
}",86,3.667
VULNERABLE,falcon180b-20219.c,yes,16,5,thread_func,"
  file falcon180b-20219.c line 16 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"
// Shared data
int shared_data = 0;

void* thread_func(void* arg) {
    int id = *((int*) arg);

    printf(""Thread %d started\n"", id);

    // Lock the mutex
    pthread_mutex_lock(&mutex);","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Shared data
int shared_data = 0;

void* thread_func(void* arg) {
    int id = *((int*) arg);

    printf(""Thread %d started\n"", id);

    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Wait for the condition variable to be signaled
    pthread_cond_wait(&cond, &mutex);

    // Increment the shared data
    shared_data++;

    // Signal the condition variable
    pthread_cond_signal(&cond);

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    printf(""Thread %d finished\n"", id);

    return NULL;
}

int main() {
    int num_threads = 5;
    pthread_t threads[num_threads];

    // Create the threads
    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, thread_func, (void*) &i);
    }

    // Join the threads
    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    printf(""Shared data: %d\n"", shared_data);

    return 0;
}",57,2.0
VULNERABLE,gemini_pro-21213.c,yes,47,3,server_thread,"
  file gemini_pro-21213.c line 47 column 3 function server_thread
","
  c:@F@server_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sockfd'",dereference failure: accessed expired variable pointer,"  printf(""%s is %s\n"", device_names[device], device_control_commands[device_states[device]]);
}

// Define the smart home server function
void *server_thread(void *args) {
  int sockfd = *(int *)args;
  char buffer[1024];
  while (1) {
    memset(buffer, 0, sizeof(buffer));
    int n = read(sockfd, buffer, sizeof(buffer));
    if (n <= 0) {","//GEMINI-pro DATASET v1.0 Category: Smart home automation ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

// Define the smart home devices
#define LIGHT 1
#define FAN 2
#define DOOR 3
#define WINDOW 4

// Define the smart home device states
#define ON 1
#define OFF 0

// Define the smart home device names
char *device_names[] = {""Light"", ""Fan"", ""Door"", ""Window""};

// Define the smart home device states
int device_states[] = {OFF, OFF, OFF, OFF};

// Define the smart home device control commands
char *device_control_commands[] = {""on"", ""off""};

// Define the smart home device control function
void control_device(int device, int state) {
  device_states[device] = state;
  printf(""%s is now %s\n"", device_names[device], device_control_commands[state]);
}

// Define the smart home device status function
void get_device_status(int device) {
  printf(""%s is %s\n"", device_names[device], device_control_commands[device_states[device]]);
}

// Define the smart home server function
void *server_thread(void *args) {
  int sockfd = *(int *)args;
  char buffer[1024];
  while (1) {
    memset(buffer, 0, sizeof(buffer));
    int n = read(sockfd, buffer, sizeof(buffer));
    if (n <= 0) {
      perror(""Error reading from socket"");
      close(sockfd);
      pthread_exit(NULL);
    }
    char *command = strtok(buffer, "" "");
    if (strcmp(command, ""control"") == 0) {
      char *device_name = strtok(NULL, "" "");
      char *state = strtok(NULL, "" "");
      int device = -1;
      for (int i = 0; i < 4; i++) {
        if (strcmp(device_name, device_names[i]) == 0) {
          device = i;
          break;
        }
      }
      if (device == -1) {
        printf(""Invalid device name\n"");
      } else {
        int state_int = -1;
        for (int i = 0; i < 2; i++) {
          if (strcmp(state, device_control_commands[i]) == 0) {
            state_int = i;
            break;
          }
        }
        if (state_int == -1) {
          printf(""Invalid state\n"");
        } else {
          control_device(device, state_int);
        }
      }
    } else if (strcmp(command, ""status"") == 0) {
      char *device_name = strtok(NULL, "" "");
      int device = -1;
      for (int i = 0; i < 4; i++) {
        if (strcmp(device_name, device_names[i]) == 0) {
          device = i;
          break;
        }
      }
      if (device == -1) {
        printf(""Invalid device name\n"");
      } else {
        get_device_status(device);
      }
    } else {
      printf(""Invalid command\n"");
    }
  }
  return NULL;
}

int main() {
  // Create a socket for the server
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    perror(""Error creating socket"");
    return EXIT_FAILURE;
  }

  // Bind the socket to the server address
  struct sockaddr_in server_addr;
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = INADDR_ANY;
  server_addr.sin_port = htons(5000);
  if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
    perror(""Error binding socket"");
    return EXIT_FAILURE;
  }

  // Listen for incoming connections
  if (listen(sockfd, 5) == -1) {
    perror(""Error listening for connections"");
    return EXIT_FAILURE;
  }

  // Create a thread for each incoming connection
  while (1) {
    struct sockaddr_in client_addr;
    int client_len = sizeof(client_addr);
    int client_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &client_len);
    if (client_sockfd == -1) {
      perror(""Error accepting connection"");
      continue;
    }
    pthread_t thread;
    if (pthread_create(&thread, NULL, server_thread, &client_sockfd) != 0) {
      perror(""Error creating thread"");
      close(client_sockfd);
      continue;
    }
  }

  // Close the server socket
  close(sockfd);

  return EXIT_SUCCESS;
}",150,5.75
VULNERABLE,falcon180b-17450.c,yes,17,5,handle_client,"
  file falcon180b-17450.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Interprocess communication ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 100

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",67,3.0
VULNERABLE,gemini_pro-4425.c,yes,21,3,generate_primes,"
  file gemini_pro-4425.c line 21 column 3 function generate_primes
","
  c:@F@generate_primes at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int current_prime = 2;

// Create a thread function that generates prime numbers
void *generate_primes(void *arg) {
  // Get the thread number
  int thread_num = *(int *)arg;

  // Generate prime numbers until the current prime number is greater than the maximum prime number
  while (current_prime <= MAX_PRIMES) {
    // Lock the mutex
    pthread_mutex_lock(&mutex);","//GEMINI-pro DATASET v1.0 Category: Prime Number Generator ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Define the maximum number of primes to generate
#define MAX_PRIMES 1000000

// Define the number of threads to use
#define NUM_THREADS 4

// Create a mutex to protect the shared variable
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Create a shared variable to store the current prime number
int current_prime = 2;

// Create a thread function that generates prime numbers
void *generate_primes(void *arg) {
  // Get the thread number
  int thread_num = *(int *)arg;

  // Generate prime numbers until the current prime number is greater than the maximum prime number
  while (current_prime <= MAX_PRIMES) {
    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Check if the current prime number is prime
    int is_prime = 1;
    for (int i = 2; i <= current_prime / 2; i++) {
      if (current_prime % i == 0) {
        is_prime = 0;
        break;
      }
    }

    // If the current prime number is prime, print it
    if (is_prime) {
      printf(""%d "", current_prime);
    }

    // Increment the current prime number
    current_prime++;

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);
  }

  // Exit the thread
  pthread_exit(NULL);
}

// Create a main function that creates and runs the threads
int main() {
  // Create an array of thread IDs
  pthread_t threads[NUM_THREADS];

  // Create the threads
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_create(&threads[i], NULL, generate_primes, &i);
  }

  // Wait for the threads to finish
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  // Destroy the mutex
  pthread_mutex_destroy(&mutex);

  // Exit the program
  return 0;
}",73,4.0
VULNERABLE,falcon180b-43023.c,yes,21,5,handle_client,"
  file falcon180b-43023.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);

        if (server_socket == -1) {
            printf(""Error creating socket\n"");
            exit(1);
        }

        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(PORT);

        if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
            printf(""Error binding socket\n"");
            exit(1);
        }

        if (listen(server_socket, MAX_CLIENTS) == -1) {
            printf(""Error listening on socket\n"");
            exit(1);
        }

        printf(""Server listening on port %d\n"", PORT);

        while (num_clients < MAX_CLIENTS) {
            int client_socket = accept(server_socket, NULL, NULL);

            if (client_socket == -1) {
                printf(""Error accepting connection\n"");
                exit(1);
            }

            printf(""Client connected: %d\n"", client_socket);
            client_sockets[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }
}

int main() {
    accept_connections();

    return 0;
}",88,3.667
VULNERABLE,falcon180b-51339.c,yes,16,5,handle_client,"
  file falcon180b-51339.c line 16 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 3) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");
    accept_connections(server_socket);

    return 0;
}",79,3.333
VULNERABLE,codellama_13b-8329.c,yes,52,9,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file codellama_13b-8329.c line 52 column 9 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `color'",dereference failure: accessed expired variable pointer,"
        // Print the hexadecimal value
        printf(""Hexadecimal value: %s\n"", hex);

        // Convert the hexadecimal value to its corresponding color code
        strcpy(color, hex_to_color(hex));

        // Print the color code
        printf(""Color code: %s\n"", color);

        return 0;","//Code Llama-13B DATASET v1.0 Category: Color Code Converter ; Style: enthusiastic
#include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    // Function to convert a color code to its corresponding hexadecimal value
    char* color_to_hex(char* color) {
        char hex[7];
        if (strcmp(color, ""red"") == 0) {
            strcpy(hex, ""#FF0000"");
        } else if (strcmp(color, ""green"") == 0) {
            strcpy(hex, ""#00FF00"");
        } else if (strcmp(color, ""blue"") == 0) {
            strcpy(hex, ""#0000FF"");
        } else {
            strcpy(hex, """");
        }
        return hex;
    }

    // Function to convert a hexadecimal value to its corresponding color code
    char* hex_to_color(char* hex) {
        char color[6];
        if (strcmp(hex, ""#FF0000"") == 0) {
            strcpy(color, ""red"");
        } else if (strcmp(hex, ""#00FF00"") == 0) {
            strcpy(color, ""green"");
        } else if (strcmp(hex, ""#0000FF"") == 0) {
            strcpy(color, ""blue"");
        } else {
            strcpy(color, """");
        }
        return color;
    }

    // Main function to demonstrate the use of the color code converter
    int main() {
        char color[6];
        char hex[7];

        // Get input from the user
        printf(""Enter a color code (red, green, or blue): "");
        scanf(""%s"", color);

        // Convert the color code to its corresponding hexadecimal value
        strcpy(hex, color_to_hex(color));

        // Print the hexadecimal value
        printf(""Hexadecimal value: %s\n"", hex);

        // Convert the hexadecimal value to its corresponding color code
        strcpy(color, hex_to_color(hex));

        // Print the color code
        printf(""Color code: %s\n"", color);

        return 0;
    }",58,3.0
VULNERABLE,falcon180b-13264.c,yes,18,5,handle_client,"
  file falcon180b-13264.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if(bytes_received <= 0) break;","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if(bytes_received <= 0) break;
        for(int i = 0; i < num_clients; i++) {
            if(clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 17, 0);
            close(client_socket);
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",57,4.0
VULNERABLE,falcon180b-21504.c,yes,19,5,handle_client,"
  file falcon180b-21504.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (true) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Metadata Extractor ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (true) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent request: %s\n"", client_socket, request);

        // Do something with the request here

        send(client_socket, ""Response"", strlen(""Response""), 0);
    }

    close(client_socket);
    num_clients--;
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        int listening_socket = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in server_addr;

        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(PORT);

        bind(listening_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
        listen(listening_socket, 3);

        printf(""Listening on port %d\n"", PORT);

        int client_socket = accept(listening_socket, NULL, NULL);
        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();

    while (true) {
        sleep(1);
    }

    return 0;
}",73,2.333
VULNERABLE,falcon180b-60811.c,yes,18,5,handle_client,"
  file falcon180b-60811.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",63,4.0
VULNERABLE,falcon180b-24693.c,yes,18,5,handle_client,"
  file falcon180b-24693.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Temperature monitor ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10

#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }

        printf(""%s\n"", buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }

    return 0;
}",82,5.0
VULNERABLE,falcon180b-4084.c,yes,21,5,handle_client,"
  file falcon180b-4084.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: File Synchronizer ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define PORT 8080
#define SERVER_IP ""127.0.0.1""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void add_client(int socket) {
    for (int i = 0; i < MAX_CLIENTS; i++) {
        if (client_sockets[i] == 0) {
            client_sockets[i] = socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &socket);
            break;
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is running on %s:%d\n"", SERVER_IP, PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        add_client(client_socket);
    }

    return 0;
}",73,3.333
VULNERABLE,falcon180b-16316.c,yes,26,5,listen_thread,"
  file falcon180b-16316.c line 26 column 5 function listen_thread
","
  c:@F@listen_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"        }
    }
}

void *listen_thread(void *socket) {
    int new_socket = *((int *) socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(new_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void broadcast(int sender_socket, char message[]) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

void *listen_thread(void *socket) {
    int new_socket = *((int *) socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(new_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(new_socket);
            break;
        }
        broadcast(new_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }
    printf(""Server started on port %d\n"", PORT);
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int new_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);
        if (new_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }
        printf(""New client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, listen_thread, (void *) &new_socket);
        clients[num_clients++] = new_socket;
    }
    return 0;
}",73,4.0
VULNERABLE,gemini_pro-8026.c,yes,18,2,handle_client,"
  file gemini_pro-8026.c line 18 column 2 function handle_client
","
  c:gemini_pro-8026.c@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#define PORT 8080

static int server_socket;

static void *handle_client(void *arg) {
	int client_socket = *(int *)arg;
	char buffer[256];
	int bytes_read;

	while ((bytes_read = read(client_socket, buffer, sizeof(buffer))) > 0) {
		int fortune = rand() % 10;","//GEMINI-pro DATASET v1.0 Category: Automated Fortune Teller ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <signal.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080

static int server_socket;

static void *handle_client(void *arg) {
	int client_socket = *(int *)arg;
	char buffer[256];
	int bytes_read;

	while ((bytes_read = read(client_socket, buffer, sizeof(buffer))) > 0) {
		int fortune = rand() % 10;
		char *fortunes[] = {
			""You will have a great day!"",
			""You will meet a new friend."",
			""You will get a promotion."",
			""You will win a lottery."",
			""You will find love."",
			""You will have a successful year."",
			""You will be happy and healthy."",
			""You will achieve your goals."",
			""You will have a long and prosperous life."",
			""You will be loved and admired.""
		};

		int fortune_length = strlen(fortunes[fortune]);
		send(client_socket, fortunes[fortune], fortune_length, 0);
	}

	close(client_socket);
	return NULL;
}

static void signal_handler(int signum) {
	close(server_socket);
	exit(0);
}

int main() {
	srand(time(NULL));

	signal(SIGINT, signal_handler);

	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket == -1) {
		perror(""socket"");
		exit(1);
	}

	struct sockaddr_in server_address;
	server_address.sin_family = AF_INET;
	server_address.sin_addr.s_addr = INADDR_ANY;
	server_address.sin_port = htons(PORT);

	if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
		perror(""bind"");
		exit(1);
	}

	if (listen(server_socket, 10) == -1) {
		perror(""listen"");
		exit(1);
	}

	while (1) {
		int client_socket = accept(server_socket, NULL, NULL);
		if (client_socket == -1) {
			perror(""accept"");
			continue;
		}

		pthread_t thread;
		if (pthread_create(&thread, NULL, handle_client, &client_socket) != 0) {
			perror(""pthread_create"");
			close(client_socket);
			continue;
		}
	}

	close(server_socket);

	return 0;
}",94,3.333
VULNERABLE,falcon180b-63967.c,yes,19,5,handle_client,"
  file falcon180b-63967.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket_copy);
            pthread_exit(NULL);
        }
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }
}

void broadcast(int sender_socket, char message[]) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client connected, socket fd is %d\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        clients[num_clients++] = client_socket;
    }

    return 0;
}",82,4.667
VULNERABLE,gemini_pro-13187.c,yes,35,5,handle_client,"
  file gemini_pro-13187.c line 35 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sockfd'",dereference failure: accessed expired variable pointer,"pthread_mutex_t client_list_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to handle client connections
void *handle_client(void *arg) {
    // Get the client socket
    int sockfd = *(int *)arg;

    // Get the client name
    char name[MAX_MSG_LEN];
    recv(sockfd, name, sizeof(name), 0);
","//GEMINI-pro DATASET v1.0 Category: Chat server ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

// Default port number
#define PORT 8080

// Maximum number of clients
#define MAX_CLIENTS 10

// Maximum message length
#define MAX_MSG_LEN 1024

// Client structure
typedef struct client {
    int sockfd;
    char name[MAX_MSG_LEN];
} client_t;

// Client list
client_t clients[MAX_CLIENTS];

// Mutex to protect the client list
pthread_mutex_t client_list_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to handle client connections
void *handle_client(void *arg) {
    // Get the client socket
    int sockfd = *(int *)arg;

    // Get the client name
    char name[MAX_MSG_LEN];
    recv(sockfd, name, sizeof(name), 0);

    // Add the client to the client list
    pthread_mutex_lock(&client_list_mutex);
    for (int i = 0; i < MAX_CLIENTS; i++) {
        if (clients[i].sockfd == 0) {
            clients[i].sockfd = sockfd;
            strcpy(clients[i].name, name);
            break;
        }
    }
    pthread_mutex_unlock(&client_list_mutex);

    // Send a welcome message to the client
    char welcome_msg[MAX_MSG_LEN];
    sprintf(welcome_msg, ""Welcome to the chat server, %s!"", name);
    send(sockfd, welcome_msg, strlen(welcome_msg), 0);

    // Loop to handle client messages
    while (1) {
        // Receive a message from the client
        char msg[MAX_MSG_LEN];
        int recv_len = recv(sockfd, msg, sizeof(msg), 0);

        // Check if the client has disconnected
        if (recv_len == 0) {
            pthread_mutex_lock(&client_list_mutex);
            for (int i = 0; i < MAX_CLIENTS; i++) {
                if (clients[i].sockfd == sockfd) {
                    clients[i].sockfd = 0;
                    break;
                }
            }
            pthread_mutex_unlock(&client_list_mutex);
            break;
        }

        // Send the message to all other clients
        pthread_mutex_lock(&client_list_mutex);
        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i].sockfd != sockfd && clients[i].sockfd != 0) {
                send(clients[i].sockfd, msg, recv_len, 0);
            }
        }
        pthread_mutex_unlock(&client_list_mutex);
    }

    // Close the client socket
    close(sockfd);

    return NULL;
}

int main() {
    // Create a server socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");
        return EXIT_FAILURE;
    }

    // Set the socket options
    int opt = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        return EXIT_FAILURE;
    }

    // Bind the socket to the port
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(PORT);
    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror(""bind"");
        return EXIT_FAILURE;
    }

    // Listen for connections
    if (listen(sockfd, MAX_CLIENTS) < 0) {
        perror(""listen"");
        return EXIT_FAILURE;
    }

    // Loop to accept client connections
    while (1) {
        // Accept a client connection
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);
        int client_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);
        if (client_sockfd < 0) {
            perror(""accept"");
            continue;
        }

        // Create a new thread to handle the client connection
        pthread_t tid;
        if (pthread_create(&tid, NULL, handle_client, (void *)&client_sockfd) != 0) {
            perror(""pthread_create"");
            close(client_sockfd);
        }
    }

    // Close the server socket
    close(sockfd);

    return EXIT_SUCCESS;
}",147,9.0
VULNERABLE,falcon180b-13829.c,yes,26,5,handle_client,"
  file falcon180b-13829.c line 26 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
char request_buffer[MAX_REQUEST_SIZE];
char response_buffer[MAX_RESPONSE_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    pthread_mutex_lock(&lock);
    printf(""Client %d connected\n"", client_socket);
    pthread_mutex_unlock(&lock);
","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_REQUEST_SIZE 1024
#define MAX_RESPONSE_SIZE 4096

int server_socket;
int client_socket;

pthread_t thread_id;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

char request_buffer[MAX_REQUEST_SIZE];
char response_buffer[MAX_RESPONSE_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    pthread_mutex_lock(&lock);
    printf(""Client %d connected\n"", client_socket);
    pthread_mutex_unlock(&lock);

    while (1) {
        memset(request_buffer, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request_buffer, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_mutex_lock(&lock);
            printf(""Client %d disconnected\n"", client_socket);
            pthread_mutex_unlock(&lock);
            break;
        }

        pthread_mutex_lock(&lock);
        printf(""Request received from client %d: %s\n"", client_socket, request_buffer);
        pthread_mutex_unlock(&lock);

        strcat(response_buffer, ""Server response to client "");
        strcat(response_buffer, request_buffer);

        send(client_socket, response_buffer, strlen(response_buffer), 0);
    }

    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        pthread_mutex_lock(&lock);
        printf(""Client %d connected\n"", client_socket);
        pthread_mutex_unlock(&lock);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",74,2.5
VULNERABLE,falcon180b-12669.c,yes,26,5,traffic_light,"
  file falcon180b-12669.c line 26 column 5 function traffic_light
","
  c:@F@traffic_light at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"        light_state[i] = RED_LIGHT;
    }
}

void *traffic_light(void *arg) {
    int light_num = *(int *) arg;
    while (1) {
        int next_state = (light_state[light_num] + 1) % NUM_LIGHTS;
        if (next_state == RED_LIGHT) {
            printf(""Light %d is now red\n"", light_num);
        } else if (next_state == YELLOW_LIGHT) {","//Falcon-180B DATASET v1.0 Category: Traffic Light Controller ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM_LIGHTS 4
#define NUM_THREADS 4
#define RED_LIGHT 0
#define YELLOW_LIGHT 1
#define GREEN_LIGHT 2
#define PEDESTRIAN_LIGHT 3

sem_t light_sem[NUM_LIGHTS];
int light_state[NUM_LIGHTS];

void init_lights() {
    for (int i = 0; i < NUM_LIGHTS; i++) {
        sem_init(&light_sem[i], 0, 0);
        light_state[i] = RED_LIGHT;
    }
}

void *traffic_light(void *arg) {
    int light_num = *(int *) arg;
    while (1) {
        int next_state = (light_state[light_num] + 1) % NUM_LIGHTS;
        if (next_state == RED_LIGHT) {
            printf(""Light %d is now red\n"", light_num);
        } else if (next_state == YELLOW_LIGHT) {
            printf(""Light %d is now yellow\n"", light_num);
        } else if (next_state == GREEN_LIGHT) {
            printf(""Light %d is now green\n"", light_num);
        } else if (next_state == PEDESTRIAN_LIGHT) {
            printf(""Light %d is now pedestrian\n"", light_num);
        }
        sem_wait(&light_sem[light_num]);
        sem_post(&light_sem[next_state]);
        sleep(1);
    }
    return NULL;
}

int main() {
    init_lights();
    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, traffic_light, &i);
    }
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    return 0;
}",55,3.667
VULNERABLE,falcon180b-54838.c,yes,20,5,handle_client,"
  file falcon180b-54838.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d says: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""127.0.0.1"", &server_addr.sin_addr);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }
        clients[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",78,5.0
VULNERABLE,falcon180b-16367.c,yes,18,5,handle_client,"
  file falcon180b-16367.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 5
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            close(client_socket);
            clients[num_clients--] = -1;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",65,3.0
VULNERABLE,falcon180b-45869.c,yes,25,5,handle_client,"
  file falcon180b-45869.c line 25 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Antivirus scanner ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        buffer[bytes_received] = '\0';
        printf(""Client %d: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",78,3.5
VULNERABLE,falcon180b-18250.c,yes,20,5,handle_client,"
  file falcon180b-18250.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

int main(int argc, char **argv) {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.0
VULNERABLE,gpt35-16928.c,yes,18,3,handle_client,"
  file gpt35-16928.c line 18 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;

// function to handle client connections
void* handle_client(void* arg) {
  int client_socket = *(int*)arg;
  char buffer[256];

  while (1) {
    // read client message
    bzero(buffer, 256);","//FormAI DATASET v1.0 Category: Chat server ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

// global variables
#define MAX_CLIENTS 10
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

// function to handle client connections
void* handle_client(void* arg) {
  int client_socket = *(int*)arg;
  char buffer[256];

  while (1) {
    // read client message
    bzero(buffer, 256);
    int n = read(client_socket, buffer, 255);
    if (n < 0) {
      perror(""Error reading from socket"");
      break;
    }

    // broadcast message to all other clients
    for (int i = 0; i < num_clients; i++) {
      if (client_sockets[i] != client_socket) {
        n = write(client_sockets[i], buffer, strlen(buffer));
        if (n < 0) {
          perror(""Error writing to socket"");
          break;
        }
      }
    }
  }

  // remove client from list
  for (int i = 0; i < num_clients; i++) {
    if (client_sockets[i] == client_socket) {
      for (int j = i; j < num_clients - 1; j++) {
        client_sockets[j] = client_sockets[j + 1];
      }
      num_clients--;
      break;
    }
  }

  // close connection and exit thread
  close(client_socket);
  pthread_exit(NULL);
}

int main() {
  // create server socket
  int server_socket = socket(AF_INET, SOCK_STREAM, 0);
  if (server_socket < 0) {
    perror(""Error creating socket"");
    exit(1);
  }

  // set server address
  struct sockaddr_in server_address;
  bzero((char*) &server_address, sizeof(server_address));
  server_address.sin_family = AF_INET;
  server_address.sin_addr.s_addr = INADDR_ANY;
  server_address.sin_port = htons(8080);

  // bind server socket to address
  if (bind(server_socket, (struct sockaddr*) &server_address, sizeof(server_address)) < 0) {
    perror(""Error binding socket to address"");
    exit(1);
  }

  // listen for client connections
  listen(server_socket, 5);
  printf(""Server listening on port 8080...\n"");

  while (1) {
    // accept client connection
    struct sockaddr_in client_address;
    socklen_t client_address_length = sizeof(client_address);
    int client_socket = accept(server_socket, (struct sockaddr*) &client_address, &client_address_length);
    if (client_socket < 0) {
      perror(""Error accepting client connection"");
      continue;
    }

    // limit number of clients
    if (num_clients >= MAX_CLIENTS) {
      printf(""Maximum number of clients reached\n"");
      close(client_socket);
      continue;
    }

    // add client to list
    client_sockets[num_clients] = client_socket;
    num_clients++;

    // create thread to handle client
    pthread_t thread_id;
    int result = pthread_create(&thread_id, NULL, handle_client, &client_socket);
    if (result != 0) {
      perror(""Error creating thread"");
      continue;
    }

    // detach thread
    pthread_detach(thread_id);
  }

  // close server socket
  close(server_socket);
  return 0;
}",119,8.0
VULNERABLE,falcon180b-19816.c,yes,15,3,encrypt_thread,"
  file falcon180b-19816.c line 15 column 3 function encrypt_thread
","
  c:@F@encrypt_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `start'",dereference failure: accessed expired variable pointer,"
pthread_t threads[NUM_THREADS];
char buffer[BUFFER_SIZE];

void* encrypt_thread(void* arg) {
  int start = *(int*)arg;
  int end = start + BUFFER_SIZE;

  for (int i = start; i < end; i++) {
    buffer[i] ^= 0xAA;
  }","//Falcon-180B DATASET v1.0 Category: File Encyptor ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h>

#define BUFFER_SIZE 4096
#define NUM_THREADS 4

pthread_t threads[NUM_THREADS];
char buffer[BUFFER_SIZE];

void* encrypt_thread(void* arg) {
  int start = *(int*)arg;
  int end = start + BUFFER_SIZE;

  for (int i = start; i < end; i++) {
    buffer[i] ^= 0xAA;
  }

  return NULL;
}

int main() {
  FILE* input_file = fopen(""input.txt"", ""r"");
  if (input_file == NULL) {
    printf(""Error opening input file\n"");
    return 1;
  }

  FILE* output_file = fopen(""output.txt"", ""w"");
  if (output_file == NULL) {
    printf(""Error opening output file\n"");
    return 1;
  }

  int file_size = 0;
  char c;
  while ((c = fgetc(input_file))!= EOF) {
    buffer[file_size++] = c;
  }

  time_t start_time = time(NULL);
  int chunk_size = file_size / NUM_THREADS;

  for (int i = 0; i < NUM_THREADS; i++) {
    int start = i * chunk_size;
    int end = (i == NUM_THREADS - 1)? file_size : (i + 1) * chunk_size;

    pthread_create(&threads[i], NULL, encrypt_thread, (void*)&start);
  }

  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  time_t end_time = time(NULL);
  double elapsed_time = difftime(end_time, start_time);

  fprintf(output_file, ""Encryption completed in %.2f seconds\n"", elapsed_time);

  fclose(input_file);
  fclose(output_file);

  return 0;
}",67,4.5
VULNERABLE,falcon180b-39953.c,yes,18,5,handle_client,"
  file falcon180b-39953.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char buffer[BUFFER_SIZE];
    int client_socket = *(int *) socket_desc;

    while(1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char buffer[BUFFER_SIZE];
    int client_socket = *(int *) socket_desc;

    while(1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0)
            break;

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

void broadcast(int sender_socket, char message[BUFFER_SIZE]) {
    for(int i = 0; i < num_clients; i++) {
        if(client_sockets[i]!= sender_socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 51, 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",71,3.0
VULNERABLE,falcon180b-51974.c,yes,22,5,handle_client,"
  file falcon180b-51974.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
struct sockaddr_in server_addr;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_create(&threads[num_clients - 1], NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,gemini_pro-3793.c,yes,69,5,free_book,"
  file gemini_pro-3793.c line 69 column 5 function free_book
","
  c:@F@free_book at file gemini_pro-3793.c line 101 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `title'",dereference failure: accessed expired variable pointer,"void free_book(Book *book) {
    for (int i = 0; i < book->num_pages; i++) {
        free(book->pages[i].content);
    }
    free(book->pages);
    free(book->title);
    free(book);
}

// Print the content of a page
void print_page(Page *page) {","//GEMINI-pro DATASET v1.0 Category: Ebook reader ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Page of the book
typedef struct Page {
    int number;
    char *content;
} Page;

// Book structure
typedef struct Book {
    char *title;
    int num_pages;
    Page *pages;
} Book;

// Create a new book
Book *create_book(char *title, int num_pages) {
    Book *book = malloc(sizeof(Book));
    book->title = title;
    book->num_pages = num_pages;
    book->pages = malloc(sizeof(Page) * num_pages);
    for (int i = 0; i < num_pages; i++) {
        book->pages[i].number = i + 1;
        book->pages[i].content = NULL;
    }
    return book;
}

// Load a book from a file
Book *load_book(char *filename) {
    FILE *fp = fopen(filename, ""r"");
    if (fp == NULL) {
        fprintf(stderr, ""Error opening file %s\n"", filename);
        return NULL;
    }

    // Read the title of the book
    char title[256];
    fgets(title, 256, fp);

    // Read the number of pages in the book
    int num_pages;
    fscanf(fp, ""%d"", &num_pages);

    // Create a new book
    Book *book = create_book(title, num_pages);

    // Read the content of each page
    for (int i = 0; i < num_pages; i++) {
        char content[1024];
        fgets(content, 1024, fp);
        book->pages[i].content = strdup(content);
    }

    fclose(fp);

    return book;
}

// Free the memory allocated for a book
void free_book(Book *book) {
    for (int i = 0; i < book->num_pages; i++) {
        free(book->pages[i].content);
    }
    free(book->pages);
    free(book->title);
    free(book);
}

// Print the content of a page
void print_page(Page *page) {
    printf(""Page %d:\n%s"", page->number, page->content);
}

// Print the table of contents of a book
void print_toc(Book *book) {
    printf(""Table of Contents:\n"");
    for (int i = 0; i < book->num_pages; i++) {
        printf(""  %d. %s"", book->pages[i].number, book->pages[i].content);
    }
}

// Main function
int main() {
    // Load a book from a file
    Book *book = load_book(""book.txt"");
    if (book == NULL) {
        return -1;
    }

    // Print the table of contents
    print_toc(book);

    // Print the first page of the book
    print_page(&book->pages[0]);

    // Free the memory allocated for the book
    free_book(book);

    return 0;
}",104,2.0
VULNERABLE,falcon180b-21614.c,yes,18,5,handle_client,"
  file falcon180b-21614.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Spam Detection System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        char *message = strtok(buffer, ""\r\n"");
        while (message!= NULL) {
            if (strstr(message, ""spam"")!= NULL) {
                printf(""SPAM DETECTED!\n"");
            }
            message = strtok(NULL, ""\r\n"");
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full!\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    close(server_socket);
    return 0;
}",72,4.0
VULNERABLE,falcon180b-22683.c,yes,22,5,handle_client,"
  file falcon180b-22683.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Fractal Generation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 12345
#define IP ""127.0.0.1""
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        pthread_mutex_lock(&mutex);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= sock) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
        pthread_mutex_unlock(&mutex);
    }
    close(sock);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, IP, &server_addr.sin_addr);
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on %s:%d\n"", IP, PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        pthread_mutex_lock(&mutex);
        clients[num_clients++] = client_socket;
        pthread_mutex_unlock(&mutex);
    }

    return 0;
}",64,3.5
VULNERABLE,falcon180b-70128.c,yes,20,5,threadFunction,"
  file falcon180b-70128.c line 20 column 5 function threadFunction
","
  c:@F@threadFunction at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientSocket'",dereference failure: accessed expired variable pointer,"int globalSocket = -1;
int activeThreads = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *threadFunction(void *socketDescriptor) {
    int clientSocket = *((int *) socketDescriptor);
    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);
        if(bytesRead <= 0) {","//Falcon-180B DATASET v1.0 Category: System process viewer ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX 10

int globalSocket = -1;
int activeThreads = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *threadFunction(void *socketDescriptor) {
    int clientSocket = *((int *) socketDescriptor);
    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);
        if(bytesRead <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", clientSocket, buffer);
    }
    close(clientSocket);
    pthread_mutex_lock(&mutex);
    activeThreads--;
    pthread_mutex_unlock(&mutex);
    pthread_exit(NULL);
}

int main() {
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if(serverSocket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in serverAddress;
    memset(&serverAddress, 0, sizeof(serverAddress));
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(8080);
    serverAddress.sin_addr.s_addr = htonl(INADDR_ANY);

    if(bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if(listen(serverSocket, MAX) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port 8080\n"");

    while(1) {
        int clientSocket = accept(serverSocket, NULL, NULL);
        if(clientSocket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t threadId;
        pthread_create(&threadId, NULL, threadFunction, (void *)&clientSocket);

        pthread_mutex_lock(&mutex);
        activeThreads++;
        pthread_mutex_unlock(&mutex);
    }

    close(serverSocket);
    return 0;
}",79,4.5
VULNERABLE,falcon180b-61742.c,yes,19,5,handle_client,"
  file falcon180b-61742.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        send(client_socket, buffer, bytes_received, 0);
    }
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        printf(""Error setting SO_REUSEADDR\n"");
        exit(1);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding to port %d\n"", PORT);
        exit(1);
    }

    if (listen(server_socket, 3) < 0) {
        printf(""Error listening\n"");
        exit(1);
    }

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        memset(&client_addr, 0, sizeof(client_addr));
        socklen_t addr_size = sizeof(client_addr);

        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",88,5.0
VULNERABLE,falcon180b-50852.c,yes,40,18,main,"
  file string.c line 78 column 3 function strlen
","
  c:@F@strlen at file falcon180b-50852.c line 40 column 18 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"    print_message(""You entered: "");
    print_cheerful_message(user_input);

    // check if the user input is a palindrome
    int is_palindrome = 1;
    int length = strlen(user_input);
    for(int i = 0; i < length/2; i++) {
        if(user_input[i]!= user_input[length-i-1]) {
            is_palindrome = 0;
            break;
        }","//Falcon-180B DATASET v1.0 Category: Educational ; Style: cheerful
#include <stdio.h>

// function to print a message
void print_message(char* message) {
    printf(""%s\n"", message);
}

// function to print a cheerful message
void print_cheerful_message(char* message) {
    printf(""Yay! %s\n"", message);
}

// function to print a sad message
void print_sad_message(char* message) {
    printf(""Oh no! %s\n"", message);
}

// function to get user input as a string
char* get_user_input() {
    char input[100];
    printf(""Enter something: "");
    scanf(""%s"", input);
    return input;
}

int main() {
    // print a cheerful welcome message
    print_cheerful_message(""Welcome to the program!"");

    // get user input
    char* user_input = get_user_input();

    // print a message with the user input
    print_message(""You entered: "");
    print_cheerful_message(user_input);

    // check if the user input is a palindrome
    int is_palindrome = 1;
    int length = strlen(user_input);
    for(int i = 0; i < length/2; i++) {
        if(user_input[i]!= user_input[length-i-1]) {
            is_palindrome = 0;
            break;
        }
    }
    if(is_palindrome) {
        print_cheerful_message(""The input is a palindrome!"");
    } else {
        print_sad_message(""The input is not a palindrome :("");
    }

    // print a cheerful goodbye message
    print_cheerful_message(""Thanks for using the program!"");

    return 0;
}",57,1.6
VULNERABLE,falcon180b-48677.c,yes,18,5,handle_client,"
  file falcon180b-48677.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int max_clients = MAX_CLIENTS;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <pthread.h>

#define MAX_CLIENTS 50
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int max_clients = MAX_CLIENTS;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Chat server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= max_clients) {
            send(client_socket, ""Server is full. Please try again later.\n"", 46, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",71,4.0
VULNERABLE,falcon180b-32093.c,yes,18,5,handle_client,"
  file falcon180b-32093.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        // Send response back to client
        send(client_socket, ""Response from server"", strlen(""Response from server""), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full, cannot accept more connections\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.0
VULNERABLE,gemini_pro-21180.c,yes,31,5,traffic_light_controller,"
  file gemini_pro-21180.c line 31 column 5 function traffic_light_controller
","
  c:@F@traffic_light_controller at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"pthread_t traffic_light_threads[NUM_TRAFFIC_LIGHTS];

// Function to control a traffic light
void *traffic_light_controller(void *arg)
{
    int traffic_light_id = *(int *)arg;
    while (true)
    {
        // Acquire the traffic lights mutex
        pthread_mutex_lock(&traffic_lights_mutex);
","//GEMINI-pro DATASET v1.0 Category: Traffic Light Controller ; Style: protected
// Traffic Light Controller in C

#include <stdbool.h>
#include <pthread.h>
#include <semaphore.h>

// Define the traffic light states
#define RED 0
#define YELLOW 1
#define GREEN 2

// Define the number of traffic lights
#define NUM_TRAFFIC_LIGHTS 3

// Define the traffic light colors
const char *traffic_light_colors[] = {""RED"", ""YELLOW"", ""GREEN""};

// Create a semaphore for each traffic light
sem_t traffic_lights[NUM_TRAFFIC_LIGHTS];

// Create a mutex to protect the traffic lights
pthread_mutex_t traffic_lights_mutex = PTHREAD_MUTEX_INITIALIZER;

// Create a thread for each traffic light
pthread_t traffic_light_threads[NUM_TRAFFIC_LIGHTS];

// Function to control a traffic light
void *traffic_light_controller(void *arg)
{
    int traffic_light_id = *(int *)arg;
    while (true)
    {
        // Acquire the traffic lights mutex
        pthread_mutex_lock(&traffic_lights_mutex);

        // Set the traffic light to red
        sem_wait(&traffic_lights[traffic_light_id]);

        // Sleep for a while
        sleep(1);

        // Set the traffic light to yellow
        sem_post(&traffic_lights[traffic_light_id]);

        // Sleep for a while
        sleep(1);

        // Set the traffic light to green
        sem_post(&traffic_lights[traffic_light_id]);

        // Sleep for a while
        sleep(1);

        // Release the traffic lights mutex
        pthread_mutex_unlock(&traffic_lights_mutex);
    }
    return NULL;
}

// Main function
int main()
{
    // Initialize the semaphores
    for (int i = 0; i < NUM_TRAFFIC_LIGHTS; i++)
    {
        sem_init(&traffic_lights[i], 0, 0);
    }

    // Create the traffic light threads
    for (int i = 0; i < NUM_TRAFFIC_LIGHTS; i++)
    {
        pthread_create(&traffic_light_threads[i], NULL, traffic_light_controller, &i);
    }

    // Join the traffic light threads
    for (int i = 0; i < NUM_TRAFFIC_LIGHTS; i++)
    {
        pthread_join(traffic_light_threads[i], NULL);
    }

    // Destroy the semaphores
    for (int i = 0; i < NUM_TRAFFIC_LIGHTS; i++)
    {
        sem_destroy(&traffic_lights[i]);
    }

    // Destroy the traffic lights mutex
    pthread_mutex_destroy(&traffic_lights_mutex);

    return 0;
}",92,3.5
VULNERABLE,gpt35-20819.c,yes,31,5,handle_client,"
  file gpt35-20819.c line 31 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    }
    exit(0);
}

void* handle_client(void* socket_ptr) {
    int socket = *(int*)socket_ptr;
    char data[MAX_DATA_SIZE];
    while(1) {
        int bytes_received = recv(socket, data, sizeof(data), 0);
        if(bytes_received <= 0) {
            break;","//FormAI DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netinet/in.h> 
#include <arpa/inet.h>
#include <sys/socket.h>
#include <string.h>

#define MAX_CLIENTS 100
#define MAX_DATA_SIZE 4096
#define QOS_THRESHOLD 1000

int client_count = 0;
int client_sockets[MAX_CLIENTS];

void handle_signal(int sig) {
    printf(""Closing connections...\n"");
    for(int i = 0; i < client_count; i++) {
        close(client_sockets[i]);
    }
    exit(0);
}

void* handle_client(void* socket_ptr) {
    int socket = *(int*)socket_ptr;
    char data[MAX_DATA_SIZE];
    while(1) {
        int bytes_received = recv(socket, data, sizeof(data), 0);
        if(bytes_received <= 0) {
            break;
        }
        // Do some processing here...
        printf(""Received %d bytes from client\n"", bytes_received);
        if(bytes_received > QOS_THRESHOLD) {
            printf(""Quality of Service threshold exceeded!\n"");
            // Do something to handle this...
        }
    }
    close(socket);
}

int main() {
    signal(SIGINT, handle_signal);
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket < 0) {
        perror(""socket() failed"");
        exit(1);
    }
    struct sockaddr_in server_address = {0};
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(8000);
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    if(bind(server_socket, (struct sockaddr*) &server_address, sizeof(server_address)) < 0) {
        perror(""bind() failed"");
        exit(1);
    }
    if(listen(server_socket, MAX_CLIENTS) < 0) {
        perror(""listen() failed"");
        exit(1);
    }
    printf(""Server running...\n"");
    while(1) {
        struct sockaddr_in client_address = {0};
        socklen_t client_address_len = sizeof(client_address);
        int client_socket = accept(server_socket, (struct sockaddr*) &client_address, &client_address_len);
        if(client_socket < 0) {
            perror(""accept() failed"");
            exit(1);
        }
        client_sockets[client_count++] = client_socket;
        printf(""New client connected: %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));
        pthread_t thread;
        if(pthread_create(&thread, NULL, handle_client, &client_socket) < 0) {
            perror(""pthread_create() failed"");
            exit(1);
        }
        pthread_detach(thread);
    }
    return 0;
}",86,4.333
VULNERABLE,falcon180b-46679.c,yes,46,5,thread_function,"
  file falcon180b-46679.c line 46 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"    sleep(2);
    sem_post(&full);
}

void* thread_function(void* arg) {
    int id = *(int*) arg;
    thread_id[id] = id;

    for (int i = 0; i < MAX; i++) {
        push(i);
    }","//Falcon-180B DATASET v1.0 Category: Tower of Hanoi Problem ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define MAX 100
#define NUM_THREADS 3

int top = -1;
int shared_stack[MAX];
int thread_stack[NUM_THREADS][MAX];
int thread_id[NUM_THREADS];

sem_t mutex;
sem_t empty;
sem_t full;

void init_semaphores() {
    sem_init(&mutex, 0, 1);
    sem_init(&empty, 0, NUM_THREADS);
    sem_init(&full, 0, 0);
}

void push(int value) {
    sleep(1);
    sem_wait(&empty);
    sem_wait(&mutex);

    shared_stack[++top] = value;

    for (int i = 0; i < NUM_THREADS; i++) {
        if (thread_id[i] == value) {
            thread_stack[i][++thread_id[i]] = value;
            break;
        }
    }

    sem_post(&mutex);
    sleep(2);
    sem_post(&full);
}

void* thread_function(void* arg) {
    int id = *(int*) arg;
    thread_id[id] = id;

    for (int i = 0; i < MAX; i++) {
        push(i);
    }

    return NULL;
}

int main() {
    init_semaphores();

    pthread_t threads[NUM_THREADS];

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_function, (void*) &i);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",70,2.25
VULNERABLE,falcon180b-17241.c,yes,103,17,main,"
  file falcon180b-17241.c line 103 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `symbol'",dereference failure: accessed expired variable pointer,"                buy_shares(companies, n, symbol);
                break;

            case 2:
                printf(""\nEnter company symbol: "");
                scanf(""%s"", symbol);
                sell_shares(companies, n, symbol);
                break;

            case 3:
                exit(0);","//Falcon-180B DATASET v1.0 Category: Stock market tracker ; Style: puzzling
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>

#define MAX 1000

struct company{
    char name[20];
    char symbol[10];
    float price;
    int shares;
};

void add_company(struct company companies[], int n){
    printf(""Enter company name: "");
    scanf(""%s"", companies[n].name);
    printf(""Enter company symbol: "");
    scanf(""%s"", companies[n].symbol);
    printf(""Enter company price per share: "");
    scanf(""%f"", &companies[n].price);
    printf(""Enter number of shares: "");
    scanf(""%d"", &companies[n].shares);
}

void display_companies(struct company companies[], int n){
    printf(""\nCompany\tSymbol\tPrice per share\tShares\n"");
    for(int i=0; i<n; i++){
        printf(""%s\t%s\t%.2f\t%d\n"", companies[i].name, companies[i].symbol, companies[i].price, companies[i].shares);
    }
}

void buy_shares(struct company companies[], int n, char symbol[]){
    int found = 0;
    for(int i=0; i<n; i++){
        if(strcmp(companies[i].symbol, symbol) == 0){
            printf(""\nEnter number of shares to buy: "");
            scanf(""%d"", &companies[i].shares);
            found = 1;
            break;
        }
    }
    if(found == 0){
        printf(""\nCompany not found!"");
    }
}

void sell_shares(struct company companies[], int n, char symbol[]){
    int found = 0;
    for(int i=0; i<n; i++){
        if(strcmp(companies[i].symbol, symbol) == 0){
            printf(""\nEnter number of shares to sell: "");
            scanf(""%d"", &companies[i].shares);
            found = 1;
            break;
        }
    }
    if(found == 0){
        printf(""\nCompany not found!"");
    }
}

void main(){
    struct company companies[MAX];
    int n = 0;

    printf(""\nWelcome to the Stock Market Tracker!\n"");

    while(n<MAX){
        printf(""\nDo you want to add a company? (y/n): "");
        char choice;
        scanf(""%c"", &choice);

        if(choice == 'y' || choice == 'Y'){
            add_company(companies, n);
            n++;
        }
        else{
            break;
        }
    }

    while(1){
        system(""clear"");
        printf(""\nCompany\tSymbol\tPrice per share\tShares\n"");
        display_companies(companies, n);

        printf(""\nWhat do you want to do?\n1. Buy shares\n2. Sell shares\n3. Exit\n"");
        int choice;
        scanf(""%d"", &choice);

        switch(choice){
            case 1:
                printf(""\nEnter company symbol: "");
                char symbol[10];
                scanf(""%s"", symbol);
                buy_shares(companies, n, symbol);
                break;

            case 2:
                printf(""\nEnter company symbol: "");
                scanf(""%s"", symbol);
                sell_shares(companies, n, symbol);
                break;

            case 3:
                exit(0);

            default:
                printf(""\nInvalid choice!"");
        }
    }
}",114,3.8
VULNERABLE,gpt35-33378.c,yes,67,5,connection_handler,"
  file gpt35-33378.c line 67 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"/*
 * This will handle connection for each client
 * */
void *connection_handler(void *socket_desc) {
    // Get the socket descriptor
    int sock = *(int *)socket_desc;
    int read_size;
    char *message, client_message[2000];

    // Send some messages to the client
    message = ""Greetings! I am your connection handler\n"";","//FormAI DATASET v1.0 Category: Socket programming ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 9999

void *connection_handler(void *);

int main() {
    int socket_desc, new_socket, c;
    struct sockaddr_in server, client;

    // Create socket
    socket_desc = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_desc == -1) {
        printf(""Could not create socket"");
        return 1;
    }

    // Prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    // Bind
    if (bind(socket_desc, (struct sockaddr *)&server, sizeof(server)) < 0) {
        perror(""bind failed"");
        return 1;
    }

    // Listen
    listen(socket_desc, 5);

    puts(""Waiting for incoming connections..."");

    c = sizeof(struct sockaddr_in);
    while ((new_socket = accept(socket_desc, (struct sockaddr *)&client, (socklen_t *)&c))) {
        puts(""Connection accepted"");

        pthread_t sniffer_thread;
        if (pthread_create(&sniffer_thread, NULL, connection_handler, (void *)&new_socket) < 0) {
            perror(""Could not create thread"");
            return 1;
        }

        puts(""Handler assigned"");
    }

    if (new_socket < 0) {
        perror(""accept failed"");
        return 1;
    }

    return 0;
}

/*
 * This will handle connection for each client
 * */
void *connection_handler(void *socket_desc) {
    // Get the socket descriptor
    int sock = *(int *)socket_desc;
    int read_size;
    char *message, client_message[2000];

    // Send some messages to the client
    message = ""Greetings! I am your connection handler\n"";
    write(sock, message, strlen(message));

    message = ""Now type something and I shall repeat what you type \n"";
    write(sock, message, strlen(message));

    // Receive a message from client
    while ((read_size = recv(sock, client_message, 2000, 0)) > 0) {
        // End of string marker
        client_message[read_size] = '\0';

        // Send the message back to client
        write(sock, client_message, strlen(client_message));
    }

    if (read_size == 0) {
        puts(""Client disconnected"");
        fflush(stdout);
    } else if (read_size == -1) {
        perror(""recv failed"");
    }

    // Free socket pointer
    free(socket_desc);

    return 0;
}",98,5.0
VULNERABLE,falcon180b-8676.c,yes,19,5,handle_client,"
  file falcon180b-8676.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
char buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
char buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(3000);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            continue;
        }
        client_sockets[num_clients++] = client_socket;
        pthread_t tid;
        pthread_create(&tid, NULL, handle_client, (void *) &client_socket);
        printf(""Client %d connected\n"", client_socket);
    }

    return 0;
}",58,3.0
VULNERABLE,falcon180b-4868.c,yes,19,5,handle_client,"
  file falcon180b-4868.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Network Topology Mapper ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define THREADS 5

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        int i;
        for (i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                client_count++;
                break;
            }
        }

        if (i == MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",80,4.5
VULNERABLE,falcon180b-68315.c,yes,22,5,handle_client,"
  file falcon180b-68315.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MESSAGE_SIZE];

    while(1) {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_MESSAGE_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MESSAGE_SIZE];

    while(1) {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        for(int i=0; i<num_clients; i++) {
            if(clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Chat Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 46, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-37419.c,yes,17,5,thread_function,"
  file falcon180b-37419.c line 17 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `thread_ids'",dereference failure: accessed expired variable pointer,"// Number of threads
#define NUM_THREADS 5

// Function to be executed by each thread
void *thread_function(void *arg) {
    int thread_id = *(int *) arg;

    printf(""Thread %d started\n"", thread_id);

    // Lock the mutex before entering critical section
    pthread_mutex_lock(&mutex);","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex for critical section
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for signaling between threads
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Number of threads
#define NUM_THREADS 5

// Function to be executed by each thread
void *thread_function(void *arg) {
    int thread_id = *(int *) arg;

    printf(""Thread %d started\n"", thread_id);

    // Lock the mutex before entering critical section
    pthread_mutex_lock(&mutex);

    // Signal the main thread that this thread is ready
    pthread_cond_signal(&cond);

    // Unlock the mutex after exiting critical section
    pthread_mutex_unlock(&mutex);

    printf(""Thread %d finished\n"", thread_id);

    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS] = {1, 2, 3, 4, 5};

    // Create threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]);
    }

    // Wait for all threads to signal readiness
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_cond_wait(&cond, &mutex);
    }

    // Print message and exit
    printf(""All threads finished\n"");

    return 0;
}",53,2.0
VULNERABLE,falcon180b-46164.c,yes,20,5,handle_client,"
  file falcon180b-46164.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        send(client_socket, buffer, bytes_received, 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket)!= 0) {
            printf(""Error creating thread\n"");
            close(client_socket);
        }
    }

    close(server_socket);
    return 0;
}",79,5.5
VULNERABLE,falcon180b-24943.c,yes,21,5,calculateSentiment,"
  file falcon180b-24943.c line 21 column 5 function calculateSentiment
","
  c:@F@calculateSentiment at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `sentenceData'",dereference failure: accessed expired variable pointer,"
// Function to calculate the sentiment of a sentence
void *calculateSentiment(void *data) {
    SentenceData *sentenceData = (SentenceData *) data;
    char *sentence = sentenceData->sentence;
    int length = sentenceData->length;

    // TODO: Implement sentiment analysis algorithm here

    pthread_exit(NULL);
}","//Falcon-180B DATASET v1.0 Category: Sentiment analysis tool ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <pthread.h>

#define MAX_SENTENCE_LENGTH 1000
#define NUM_THREADS 4

// Struct to pass data between threads
typedef struct {
    char sentence[MAX_SENTENCE_LENGTH];
    int length;
} SentenceData;

// Function to calculate the sentiment of a sentence
void *calculateSentiment(void *data) {
    SentenceData *sentenceData = (SentenceData *) data;
    char *sentence = sentenceData->sentence;
    int length = sentenceData->length;

    // TODO: Implement sentiment analysis algorithm here

    pthread_exit(NULL);
}

int main() {
    FILE *inputFile;
    char inputBuffer[MAX_SENTENCE_LENGTH];
    int numSentences = 0;
    pthread_t threads[NUM_THREADS];

    // Open input file
    inputFile = fopen(""input.txt"", ""r"");
    if (inputFile == NULL) {
        printf(""Error opening input file.\n"");
        exit(1);
    }

    // Read sentences from input file
    while (fgets(inputBuffer, MAX_SENTENCE_LENGTH, inputFile)!= NULL) {
        // Remove newline character from end of sentence
        inputBuffer[strcspn(inputBuffer, ""\n"")] = '\0';

        // Create sentence data struct
        SentenceData sentenceData;
        strcpy(sentenceData.sentence, inputBuffer);
        sentenceData.length = strlen(inputBuffer);

        // Add sentence to thread queue
        pthread_create(&threads[numSentences % NUM_THREADS], NULL, calculateSentiment, &sentenceData);
        numSentences++;
    }

    // Close input file
    fclose(inputFile);

    // Join threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",65,2.5
VULNERABLE,gpt35-23394.c,yes,20,5,monitor_qos,"
  file gpt35-23394.c line 20 column 5 function monitor_qos
","
  c:@F@monitor_qos at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `sockfd'",dereference failure: accessed expired variable pointer,"// Function to monitor network quality of service
void *monitor_qos(void *args) {
    struct timespec start, end;
    long long execution_time = 0;
    char buffer[BUFSIZE];
    int sockfd = *(int*)args;
    while(1) {
        // Get the start time
        clock_gettime(CLOCK_MONOTONIC, &start);
        // Send a test message to the server to check for delay and packet loss
        if(send(sockfd, ""Test"", strlen(""Test""), 0) < 0) {","//FormAI DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>
#include <time.h>

#define BUFSIZE 1024
#define PORT 9000
#define IP ""127.0.0.1""

// Function to monitor network quality of service
void *monitor_qos(void *args) {
    struct timespec start, end;
    long long execution_time = 0;
    char buffer[BUFSIZE];
    int sockfd = *(int*)args;
    while(1) {
        // Get the start time
        clock_gettime(CLOCK_MONOTONIC, &start);
        // Send a test message to the server to check for delay and packet loss
        if(send(sockfd, ""Test"", strlen(""Test""), 0) < 0) {
            perror(""Error sending message"");
            exit(1);
        }
        // Receive the test message back from the server
        bzero(buffer, BUFSIZE);
        if(recv(sockfd, buffer, BUFSIZE, 0) < 0) {
            perror(""Error receiving message"");
            exit(1);
        }
        // Get the end time
        clock_gettime(CLOCK_MONOTONIC, &end);
        // Calculate the execution time
        execution_time = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_nsec - start.tv_nsec) / 1000;
        // Check for packet loss
        if(strlen(buffer) == 0) {
            printf(""Packet loss detected\n"");
            // Implement code to handle packet loss
        }
        else {
            // Check for delay
            if(execution_time > 1000000) {
                printf(""Network delay of %lld microseconds detected\n"", execution_time);
                // Implement code to handle network delay
            }
        }
        // Wait for 5 seconds before sending the next test message
        sleep(5);
    }
    return NULL;
}

// Main function
int main() {
    struct sockaddr_in server_addr;
    int sockfd;
    pthread_t t1;
    char buffer[BUFSIZE];
    // Create the network socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0) {
        perror(""Error creating socket"");
        return 1;
    }
    // Set the server address structure
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    if(inet_pton(AF_INET, IP, &server_addr.sin_addr) <= 0) {
        perror(""Error setting server address"");
        return 1;
    }
    // Connect to the server
    if(connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror(""Error connecting to server"");
        return 1;
    }
    // Create a separate thread to monitor the network quality of service
    if(pthread_create(&t1, NULL, monitor_qos, &sockfd) != 0) {
        perror(""Error creating thread"");
        return 1;
    }
    // Loop to send and receive messages from the server
    while(1) {
        printf(""Message: "");
        fgets(buffer, BUFSIZE, stdin);
        // Send the message to the server
        if(send(sockfd, buffer, strlen(buffer), 0) < 0) {
            perror(""Error sending message"");
            return 1;
        }
        // Receive the response from the server
        bzero(buffer, BUFSIZE);
        if(recv(sockfd, buffer, BUFSIZE, 0) < 0) {
            perror(""Error receiving message"");
            return 1;
        }
        printf(""Server response: %s\n"", buffer);
    }
    close(sockfd);
    return 0;
}",106,7.0
VULNERABLE,codellama_13b-11598.c,yes,38,9,print_network_list,"
  file codellama_13b-11598.c line 38 column 9 function print_network_list
","
  c:@F@print_network_list at file codellama_13b-11598.c line 65 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `networks_list'",dereference failure: accessed expired variable pointer,"}

// Function to print a list of wireless networks
void print_network_list(char **networks, int num_networks) {
    for (int i = 0; i < num_networks; i++) {
        printf(""[%d] %s\n"", i + 1, networks[i]);
    }
}

// Function to scan for wireless networks
void scan_networks(char ***networks, int *num_networks) {","//Code Llama-13B DATASET v1.0 Category: Wireless Network Scanner ; Style: funny
/*
 * Wireless Network Scanner
 * A funny example program
 *
 * By: [Your Name]
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to print a line of dashes
void print_line() {
    for (int i = 0; i < 80; i++) {
        printf(""-"");
    }
    printf(""\n"");
}

// Function to print a banner
void print_banner() {
    printf("" ________________________________________________________\n"");
    printf(""|                                                        |\n"");
    printf(""|    WIRELESS NETWORK SCANNER                           |\n"");
    printf(""|    By: [Your Name]                                     |\n"");
    printf(""|________________________________________________________|\n"");
}

// Function to print a message
void print_message(char *message) {
    printf(""[*] %s\n"", message);
}

// Function to print a list of wireless networks
void print_network_list(char **networks, int num_networks) {
    for (int i = 0; i < num_networks; i++) {
        printf(""[%d] %s\n"", i + 1, networks[i]);
    }
}

// Function to scan for wireless networks
void scan_networks(char ***networks, int *num_networks) {
    // Simulate scanning for wireless networks
    char *networks_list[] = {""Wi-Fi"", ""Ethernet"", ""5G""};
    *networks = networks_list;
    *num_networks = sizeof(networks_list) / sizeof(char*);
}

int main() {
    // Initialize variables
    char **networks;
    int num_networks;

    // Print banner
    print_banner();

    // Scan for wireless networks
    scan_networks(&networks, &num_networks);

    // Print message
    print_message(""Scanning for wireless networks..."");

    // Print list of wireless networks
    print_network_list(networks, num_networks);

    // Print message
    print_message(""Scan complete!"");

    // Print line
    print_line();

    return 0;
}",74,1.333
VULNERABLE,codellama_13b-3965.c,yes,92,13,search_element,"
  file string.c line 93 column 5 function strcmp
","
  c:@F@strcmp at file codellama_13b-3965.c line 92 column 13 function search_element
  c:@F@search_element at file codellama_13b-3965.c line 46 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `element'",dereference failure: accessed expired variable pointer,"}

void search_element(char** periodic_table, char* element) {
    // Search the periodic table for the element
    for (int i = 0; i < 118; i++) {
        if (strcmp(periodic_table[i], element) == 0) {
            printf(""Element found: %s\n"", periodic_table[i]);
            return;
        }
    }
","//Code Llama-13B DATASET v1.0 Category: Periodic Table Quiz ; Style: distributed
/*
 * C Periodic Table Quiz Example Program
 *
 * This program allows the user to input a chemical element and it will display
 * the information about that element from the periodic table.
 *
 * The program uses a distributed approach, where the periodic table data is
 * stored in a separate file and is loaded into memory when the program starts.
 *
 * The program uses the following functions:
 * - read_periodic_table_data: reads the periodic table data from the file
 * - display_periodic_table: displays the periodic table to the user
 * - input_element: prompts the user for a chemical element and returns the element's symbol
 * - search_element: searches the periodic table for the element and returns its information
 *
 * The program is structured as follows:
 * - The program starts by reading the periodic table data from a file
 * - The program then prompts the user for a chemical element
 * - The program searches the periodic table for the element and displays its information
 * - The program then displays the periodic table to the user
 * - The program exits
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function prototypes
void read_periodic_table_data(char** periodic_table);
void display_periodic_table(char** periodic_table);
char* input_element();
void search_element(char** periodic_table, char* element);

// Global variables
char* periodic_table_data[118];

int main() {
    // Read the periodic table data from the file
    read_periodic_table_data(periodic_table_data);

    // Prompt the user for a chemical element
    char* element = input_element();

    // Search the periodic table for the element
    search_element(periodic_table_data, element);

    // Display the periodic table to the user
    display_periodic_table(periodic_table_data);

    return 0;
}

void read_periodic_table_data(char** periodic_table) {
    // Open the periodic table data file
    FILE* file = fopen(""periodic_table.txt"", ""r"");
    if (file == NULL) {
        printf(""Error opening periodic table data file\n"");
        return;
    }

    // Read the periodic table data from the file
    for (int i = 0; i < 118; i++) {
        periodic_table[i] = malloc(sizeof(char) * 100);
        fgets(periodic_table[i], 100, file);
    }

    // Close the file
    fclose(file);
}

void display_periodic_table(char** periodic_table) {
    // Display the periodic table to the user
    for (int i = 0; i < 118; i++) {
        printf(""%s\n"", periodic_table[i]);
    }
}

char* input_element() {
    // Prompt the user for a chemical element
    char element[100];
    printf(""Enter a chemical element: "");
    fgets(element, 100, stdin);

    // Return the element's symbol
    return element;
}

void search_element(char** periodic_table, char* element) {
    // Search the periodic table for the element
    for (int i = 0; i < 118; i++) {
        if (strcmp(periodic_table[i], element) == 0) {
            printf(""Element found: %s\n"", periodic_table[i]);
            return;
        }
    }

    // If the element is not found, display an error message
    printf(""Element not found\n"");
}",100,2.0
VULNERABLE,falcon180b-62615.c,yes,20,5,handle_client,"
  file falcon180b-62615.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main(int argc, char *argv[]) {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full"", strlen(""Server is full""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",70,3.0
VULNERABLE,falcon180b-1578.c,yes,17,5,handle_client,"
  file falcon180b-1578.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full."", strlen(""Server is full.""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",71,4.0
VULNERABLE,falcon180b-15636.c,yes,22,5,thread_function,"
  file falcon180b-15636.c line 22 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *thread_function(void *param)
{
    int client_socket = *(int *)param;
    char buffer[MAX_MESSAGE_SIZE];

    while (1)
    {
        memset(buffer, 0, MAX_MESSAGE_SIZE);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define MAX_MESSAGE_SIZE 1024

int sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *thread_function(void *param)
{
    int client_socket = *(int *)param;
    char buffer[MAX_MESSAGE_SIZE];

    while (1)
    {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_SIZE, 0);

        if (bytes_received <= 0)
        {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

void handle_client(int client_socket)
{
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, thread_function, (void *)&client_socket);
    num_clients++;
}

int main()
{
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1)
    {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
    {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1)
    {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1)
    {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1)
        {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS)
        {
            close(client_socket);
            printf(""Server full\n"");
            continue;
        }

        handle_client(client_socket);
    }

    close(server_socket);
    return 0;
}",100,3.667
VULNERABLE,falcon180b-15731.c,yes,17,5,handle_client,"
  file falcon180b-15731.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = num_clients;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-16070.c,yes,17,5,handle_client,"
  file falcon180b-16070.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
int client_socks[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;

    char buf[BUF_SIZE];
    while (1) {
        memset(buf, 0, BUF_SIZE);
        int bytes_received = recv(client_sock, buf, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Building a POP3 Client ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int client_socks[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;

    char buf[BUF_SIZE];
    while (1) {
        memset(buf, 0, BUF_SIZE);
        int bytes_received = recv(client_sock, buf, BUF_SIZE, 0);
        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_sock);
            close(client_sock);
            pthread_exit(0);
        }

        printf(""Received message from client %d: %s"", client_sock, buf);
    }

    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(110);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_sock, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""POP3 server started on port 110\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &client_size);

        if (client_sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_sock);
            continue;
        }

        client_socks[num_clients] = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
    }

    return 0;
}",84,5.0
VULNERABLE,gemini_pro-34590.c,yes,18,3,sum_array,"
  file gemini_pro-34590.c line 18 column 3 function sum_array
","
  c:@F@sum_array at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `arr'",dereference failure: accessed expired variable pointer,"int sum = 0;

// Thread function to calculate the sum of an array
void *sum_array(void *arg) {
  int *arr = (int *)arg;
  int size = arr[0];
  int i;

  // Acquire the mutex lock
  pthread_mutex_lock(&mutex);
","//GEMINI-pro DATASET v1.0 Category: Threading Library Implementation ; Style: multivariable
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

// Mutex to protect shared data
pthread_mutex_t mutex;

// Condition variable to signal when shared data is ready
pthread_cond_t cond;

// Shared data
int sum = 0;

// Thread function to calculate the sum of an array
void *sum_array(void *arg) {
  int *arr = (int *)arg;
  int size = arr[0];
  int i;

  // Acquire the mutex lock
  pthread_mutex_lock(&mutex);

  // Calculate the sum of the array
  for (i = 1; i <= size; i++) {
    sum += arr[i];
  }

  // Signal that the sum is ready
  pthread_cond_signal(&cond);

  // Release the mutex lock
  pthread_mutex_unlock(&mutex);

  return NULL;
}

int main() {
  int arr[] = {5, 1, 2, 3, 4};
  int size = sizeof(arr) / sizeof(int);
  pthread_t thread;

  // Initialize the mutex and condition variable
  pthread_mutex_init(&mutex, NULL);
  pthread_cond_init(&cond, NULL);

  // Create a thread to calculate the sum of the array
  pthread_create(&thread, NULL, sum_array, arr);

  // Wait for the sum to be ready
  pthread_mutex_lock(&mutex);
  pthread_cond_wait(&cond, &mutex);

  // Print the sum of the array
  printf(""The sum of the array is: %d\n"", sum);

  // Destroy the mutex and condition variable
  pthread_mutex_destroy(&mutex);
  pthread_cond_destroy(&cond);

  return 0;
}",62,1.5
VULNERABLE,falcon180b-13301.c,yes,19,5,handle_client,"
  file falcon180b-13301.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define PORT 8080
#define MAX_CLIENTS 10
#define DELIMITER "" ""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char *delimiter = strchr(buffer, DELIMITER);
        if (delimiter!= NULL) {
            *delimiter = '\0';
        }

        printf(""Client %d: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 17, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",80,4.5
VULNERABLE,falcon180b-7491.c,yes,28,5,handle_client,"
  file falcon180b-7491.c line 28 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"char buffer[BUFFER_SIZE];
char username[20];
char password[20];

void *handle_client(void *args) {
    int client_socket = *((int *) args);
    printf(""New client connected with socket %d\n"", client_socket);

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX 1000
#define PORT 8080
#define SERVER_ADDR ""127.0.0.1""
#define SERVER_PORT 8080
#define BUFFER_SIZE 1024

int server_socket;
int client_socket;
struct sockaddr_in server_addr;
struct sockaddr_in client_addr;

char *message = ""Welcome to the email server!\n"";
char buffer[BUFFER_SIZE];
char username[20];
char password[20];

void *handle_client(void *args) {
    int client_socket = *((int *) args);
    printf(""New client connected with socket %d\n"", client_socket);

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Received message from client %d: %s"", client_socket, buffer);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while(1) {
        printf(""Waiting for client connection...\n"");
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, sizeof(client_addr));
        printf(""Client connected with socket %d\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",58,2.5
VULNERABLE,falcon180b-41593.c,yes,18,5,handle_client,"
  file falcon180b-41593.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",68,3.0
VULNERABLE,falcon180b-22817.c,yes,24,5,handle_client,"
  file falcon180b-22817.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int listening_socket;
int client_sockets[MAX_CONNECTIONS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while (TRUE) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define TRUE   1
#define FALSE  0
#define DEBUG  TRUE

#define MAX_CONNECTIONS 10
#define BACKLOG 10
#define MAX_DATA_SIZE 1024

int listening_socket;
int client_sockets[MAX_CONNECTIONS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while (TRUE) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            client_socket = -1;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int opt = TRUE;
    setsockopt(listening_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(listening_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(listening_socket, BACKLOG);

    printf(""Server is listening on port 8080...\n"");

    while (TRUE) {
        int client_socket = accept(listening_socket, (struct sockaddr *) &client_addr, sizeof(client_addr));

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CONNECTIONS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(listening_socket);
    return 0;
}",87,4.5
VULNERABLE,falcon180b-20425.c,yes,17,5,thread_watermark,"
  file falcon180b-20425.c line 17 column 5 function thread_watermark
","
  c:@F@thread_watermark at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `start_row'",dereference failure: accessed expired variable pointer,"unsigned char* image;
unsigned char* watermark;
int watermark_size;

void* thread_watermark(void* arg) {
    int start_row = *(int*)arg;
    int end_row = start_row + HEIGHT / NUM_THREADS;

    for (int i = start_row; i < end_row; i++) {
        for (int j = 0; j < WIDTH; j++) {
            // Apply watermarking algorithm here","//Falcon-180B DATASET v1.0 Category: Digital Watermarking ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define WIDTH 512
#define HEIGHT 512
#define NUM_THREADS 4

// Global variables
unsigned char* image;
unsigned char* watermark;
int watermark_size;

void* thread_watermark(void* arg) {
    int start_row = *(int*)arg;
    int end_row = start_row + HEIGHT / NUM_THREADS;

    for (int i = start_row; i < end_row; i++) {
        for (int j = 0; j < WIDTH; j++) {
            // Apply watermarking algorithm here
        }
    }

    return NULL;
}

int main() {
    image = (unsigned char*)malloc(WIDTH * HEIGHT * sizeof(unsigned char));
    watermark = (unsigned char*)malloc(watermark_size * sizeof(unsigned char));

    // Initialize image and watermark data here

    pthread_t threads[NUM_THREADS];

    for (int i = 0; i < NUM_THREADS; i++) {
        int start_row = i * HEIGHT / NUM_THREADS;
        int end_row = (i + 1) * HEIGHT / NUM_THREADS;

        pthread_create(&threads[i], NULL, thread_watermark, (void*)&start_row);
    }

    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Save watermarked image here

    free(image);
    free(watermark);

    return 0;
}",54,3.0
VULNERABLE,falcon180b-26740.c,yes,19,5,handle_client,"
  file falcon180b-26740.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System process viewer ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is running on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 41, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }

    return 0;
}",68,3.0
VULNERABLE,falcon180b-65380.c,yes,18,5,handle_client,"
  file falcon180b-65380.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Data recovery tool ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int sock = *(int *) client_socket;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(sock);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", sock, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= sock) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more clients.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-44865.c,yes,45,5,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-44865.c line 45 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"    printf(""Enter your address: "");
    strcpy(address, get_input(""""));

    // Get user input for phone number
    printf(""Enter your phone number: "");
    strcpy(phone_number, get_input(""""));

    // Print sanitized user input
    printf(""Name: %s\n"", name);
    printf(""Address: %s\n"", address);
    printf(""Phone Number: %s\n"", phone_number);","//Falcon-180B DATASET v1.0 Category: User Input Sanitizer ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_INPUT_SIZE 100

// Function to sanitize user input
void sanitize_input(char *input) {
    int i = 0;
    while (i < strlen(input)) {
        if (!isalnum(input[i])) {
            input[i] = '\0';
        }
        i++;
    }
}

// Function to get user input
char *get_input(char *prompt) {
    char input[MAX_INPUT_SIZE];
    printf(""%s"", prompt);
    fgets(input, MAX_INPUT_SIZE, stdin);
    input[strcspn(input, ""\n"")] = '\0';
    sanitize_input(input);
    return input;
}

int main() {
    char name[MAX_INPUT_SIZE];
    char address[MAX_INPUT_SIZE];
    char phone_number[MAX_INPUT_SIZE];

    // Get user input for name
    printf(""Enter your name: "");
    strcpy(name, get_input(""""));

    // Get user input for address
    printf(""Enter your address: "");
    strcpy(address, get_input(""""));

    // Get user input for phone number
    printf(""Enter your phone number: "");
    strcpy(phone_number, get_input(""""));

    // Print sanitized user input
    printf(""Name: %s\n"", name);
    printf(""Address: %s\n"", address);
    printf(""Phone Number: %s\n"", phone_number);

    return 0;
}",53,1.667
VULNERABLE,falcon180b-6088.c,yes,27,5,recv_thread,"
  file falcon180b-6088.c line 27 column 5 function recv_thread
","
  c:@F@recv_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"        }
    }
}

void *recv_thread(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int client_count = 0;

void broadcast(int sender_socket, char message[]) {
    for (int i = 0; i < num_clients; i++) {
        if (client_sockets[i]!= sender_socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

void *recv_thread(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d: %s\n"", client_count, buffer);
        broadcast(client_socket, buffer);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        client_count++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, recv_thread, (void *)&client_socket);
    }

    return 0;
}",73,3.0
VULNERABLE,falcon180b-4564.c,yes,17,5,handle_client,"
  file falcon180b-4564.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if(bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for(int i=0; i<num_clients; i++) {
            if(client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        if(num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.5
VULNERABLE,falcon180b-15281.c,yes,20,5,handle_client,"
  file falcon180b-15281.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    memset(&client_addr, 0, sizeof(client_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",78,3.5
VULNERABLE,falcon180b-42762.c,yes,21,5,handle_client,"
  file falcon180b-42762.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int sock;
struct sockaddr_in server_addr;
pthread_t thread_id;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (TRUE) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define PORT 8080
#define TRUE 1
#define FALSE 0

int sock;
struct sockaddr_in server_addr;
pthread_t thread_id;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (TRUE) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (strcmp(buffer, ""on"") == 0) {
            system(""gpio write 18 1"");
        } else if (strcmp(buffer, ""off"") == 0) {
            system(""gpio write 18 0"");
        } else if (strcmp(buffer, ""status"") == 0) {
            char response[20];
            sprintf(response, ""Light is %s"", (system(""gpio read 18"") == 0)? ""off"" : ""on"");
            send(client_socket, response, strlen(response), 0);
        }
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int opt = TRUE;
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(sock, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(sock, 5);

    while (TRUE) {
        int client_socket = accept(sock, NULL, NULL);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(sock);
    return 0;
}",63,4.0
VULNERABLE,falcon180b-38783.c,yes,18,5,handle_client,"
  file falcon180b-38783.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MESSAGE_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define MAX_MESSAGE_SIZE 100

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MESSAGE_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket!= -1) {
            printf(""Client connected: %d\n"", client_socket);

            int i;
            for (i = 0; i < MAX_CLIENTS; i++) {
                if (clients[i] == 0) {
                    clients[i] = client_socket;
                    client_count++;
                    break;
                }
            }

            if (i == MAX_CLIENTS) {
                printf(""Maximum clients reached\n"");
            } else {
                pthread_t thread_id;
                pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            }
        }
    }

    close(server_socket);
    return 0;
}",88,6.0
VULNERABLE,gemini_pro-21955.c,yes,62,3,main,"
  file gemini_pro-21955.c line 62 column 3 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `digest'",dereference failure: accessed expired variable pointer,"    printf(""%02x"", hash[i]);
  }
  printf(""\n"");

  // Free the hash
  free(hash);

  return 0;
}","//GEMINI-pro DATASET v1.0 Category: Cryptographic hash function ; Style: romantic
#include <stdio.h>
#include <string.h>
#include <openssl/sha.h>
#include <openssl/evp.h>

// Custom hash function
unsigned char* loveHash(const char *message, int messageLen) {
  // Create an SHA256 context
  EVP_MD_CTX *ctx = EVP_MD_CTX_new();
  if (!ctx) {
    printf(""Error creating SHA256 context\n"");
    return NULL;
  }

  // Initialize the context
  if (!EVP_DigestInit_ex(ctx, EVP_sha256(), NULL)) {
    printf(""Error initializing SHA256 context\n"");
    EVP_MD_CTX_free(ctx);
    return NULL;
  }

  // Update the context with the message
  if (!EVP_DigestUpdate(ctx, message, messageLen)) {
    printf(""Error updating SHA256 context\n"");
    EVP_MD_CTX_free(ctx);
    return NULL;
  }

  // Finalize the context and get the digest
  unsigned char digest[SHA256_DIGEST_LENGTH];
  unsigned int digestLen;
  if (!EVP_DigestFinal_ex(ctx, digest, &digestLen)) {
    printf(""Error finalizing SHA256 context\n"");
    EVP_MD_CTX_free(ctx);
    return NULL;
  }

  // Clean up
  EVP_MD_CTX_free(ctx);

  // Return the digest
  return digest;
}

int main() {
  // Our secret love message
  const char *message = ""My heart beats only for you, my beloved."";
  int messageLen = strlen(message);

  // Create a hash of the message
  unsigned char *hash = loveHash(message, messageLen);

  // Print the hash in hexadecimal format
  printf(""Our love's eternal bond, in the form of a cryptographic hash:\n"");
  for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
    printf(""%02x"", hash[i]);
  }
  printf(""\n"");

  // Free the hash
  free(hash);

  return 0;
}",65,3.5
VULNERABLE,falcon180b-49103.c,yes,18,5,handle_client,"
  file falcon180b-49103.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Packet Monitoring ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }

    return 0;
}",89,6.0
VULNERABLE,falcon180b-1530.c,yes,18,5,handle_client,"
  file falcon180b-1530.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define PORT 8080
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-7737.c,yes,20,5,handle_client,"
  file falcon180b-7737.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"int client_socks[MAX_CLIENTS];
int num_clients = 0;
int quit = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;

    char buffer[1024];
    while (1) {
        bzero(buffer, 1024);
        int bytes_received = recv(client_sock, buffer, 1024, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 5000

int sock;
int client_socks[MAX_CLIENTS];
int num_clients = 0;
int quit = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;

    char buffer[1024];
    while (1) {
        bzero(buffer, 1024);
        int bytes_received = recv(client_sock, buffer, 1024, 0);

        if (bytes_received <= 0) {
            break;
        }

        if (strstr(buffer, ""LIGHT ON"")!= NULL) {
            system(""gpio -g write 4 1"");
        } else if (strstr(buffer, ""LIGHT OFF"")!= NULL) {
            system(""gpio -g write 4 0"");
        }
    }

    close(client_sock);

    return NULL;
}

void accept_connections() {
    while (!quit) {
        socklen_t addr_size;
        struct sockaddr_in client_addr;
        addr_size = sizeof(client_addr);

        int client_sock = accept(sock, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_sock, ""Server is full. Please try again later.\r\n"", 51, 0);
            close(client_sock);
            continue;
        }

        client_socks[num_clients] = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
    }
}

int main() {
    sock = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(sock, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(sock, 10);

    accept_connections();

    return 0;
}",79,3.0
VULNERABLE,gpt35-60341.c,yes,64,5,connection_handler,"
  file gpt35-60341.c line 64 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *connection_handler(void *socket_desc) {
    int sock = *(int *) socket_desc;
    int read_size;
    char *message, client_message[2000];

    // Welcome message
    message = ""Connected to the Chat Server! Say something...\n"";","//FormAI DATASET v1.0 Category: Chat server ; Style: Sherlock Holmes
// The case of the Chat Server
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8888

void *connection_handler(void *);

int main(void) {
    int socket_desc, client_sock, c;
    struct sockaddr_in server, client;

    // Create socket
    socket_desc = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_desc == -1) {
        printf(""Could not create socket"");
        return 1;
    }

    // Prepare socket structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    // Bind socket
    if (bind(socket_desc, (struct sockaddr *) &server, sizeof(server)) < 0) {
        printf(""Binding failed"");
        return 1;
    }

    // Listen
    listen(socket_desc, 3);
    puts(""Server up and running!"");

    // Accept incoming connections
    c = sizeof(struct sockaddr_in);
    while ((client_sock = accept(socket_desc, (struct sockaddr *) &client, (socklen_t *) &c))) {
        puts(""New connection accepted"");

        pthread_t sniffer_thread;
        if (pthread_create(&sniffer_thread, NULL, connection_handler, (void *) &client_sock) < 0) {
            printf(""Could not create thread"");
            return 1;
        }

        puts(""Handler assigned"");
    }

    if (client_sock < 0) {
        printf(""Accept failed"");
        return 1;
    }

    return 0;
}

void *connection_handler(void *socket_desc) {
    int sock = *(int *) socket_desc;
    int read_size;
    char *message, client_message[2000];

    // Welcome message
    message = ""Connected to the Chat Server! Say something...\n"";
    write(sock, message, strlen(message));

    // Handle client messages
    while ((read_size = recv(sock, client_message, 2000, 0)) > 0) {
        // Add null terminator to message
        client_message[read_size] = '\0';

        // Echo back message to client
        write(sock, client_message, strlen(client_message));

        // Clear buffer
        memset(client_message, 0, 2000);
    }

    if (read_size == 0) {
        puts(""Client disconnected"");
        fflush(stdout);
    } else if (read_size == -1) {
        printf(""Receive failed"");
    }

    // Free socket pointer
    free(socket_desc);

    return 0;
}",95,5.0
VULNERABLE,falcon180b-3601.c,yes,69,17,main,"
  file falcon180b-3601.c line 69 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `result'",dereference failure: accessed expired variable pointer,"                encrypted = encrypt(message, key);
                printf(""\nEncrypted Message: %s\n"", encrypted);
                break;
            case 2:
                printf(""Enter your encrypted message: "");
                scanf(""%s"", encrypted);
                printf(""Enter your key: "");
                scanf(""%s"", key);
                decrypted = decrypt(encrypted, key);
                printf(""\nDecrypted Message: %s\n"", decrypted);
                break;","//Falcon-180B DATASET v1.0 Category: Cryptography Implementation ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define SIZE 100

char *encrypt(char *message, char *key) {
    char result[SIZE];
    int i, j, k;
    for (i = 0, j = 0; message[i]!= '\0'; i++) {
        result[i] = message[i] + key[j];
        if (result[i] > 'z') {
            result[i] -= 26;
        } else if (result[i] < 'a') {
            result[i] += 26;
        }
        j++;
        if (j == strlen(key)) {
            j = 0;
        }
    }
    result[i] = '\0';
    return result;
}

char *decrypt(char *message, char *key) {
    char result[SIZE];
    int i, j, k;
    for (i = 0, j = 0; message[i]!= '\0'; i++) {
        result[i] = message[i] - key[j];
        if (result[i] > 'z') {
            result[i] -= 26;
        } else if (result[i] < 'a') {
            result[i] += 26;
        }
        j++;
        if (j == strlen(key)) {
            j = 0;
        }
    }
    result[i] = '\0';
    return result;
}

int main() {
    char message[SIZE];
    char key[SIZE];
    char *encrypted;
    char *decrypted;
    int choice;
    do {
        printf(""\nWelcome to the Future Cryptography System!\n"");
        printf(""1. Encrypt Message\n2. Decrypt Message\n3. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                printf(""Enter your message: "");
                scanf(""%s"", message);
                printf(""Enter your key: "");
                scanf(""%s"", key);
                encrypted = encrypt(message, key);
                printf(""\nEncrypted Message: %s\n"", encrypted);
                break;
            case 2:
                printf(""Enter your encrypted message: "");
                scanf(""%s"", encrypted);
                printf(""Enter your key: "");
                scanf(""%s"", key);
                decrypted = decrypt(encrypted, key);
                printf(""\nDecrypted Message: %s\n"", decrypted);
                break;
            case 3:
                exit(0);
            default:
                printf(""Invalid choice!\n"");
        }
    } while (1);
    return 0;
}",82,5.0
VULNERABLE,gpt35-62096.c,yes,66,5,handle_client,"
  file gpt35-62096.c line 66 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket_fd'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *handle_client(void *arg) {
    // Get socket file descriptor from argument
    int socket_fd = *(int*)arg;

    // Receive initial username message from client
    char username[32];
    recv(socket_fd, username, 32, 0);
","//FormAI DATASET v1.0 Category: Chat server ; Style: Donald Knuth
// The following code implements a chat server program in C, inspired by Donald Knuth's literate programming style

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

// Define a struct to hold information about connected clients
typedef struct {
    int socket_fd;  // Socket file descriptor of client
    char username[32];  // Username of client
} client_info_t;

// Global variables
int server_socket_fd;
client_info_t clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function prototypes
void *handle_client(void *arg);
void broadcast_message(char *message, int exclude_socket_fd);

int main(int argc, char *argv[]) {
    // Create server socket
    server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);

    // Bind socket to address and port
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(5050);
    bind(server_socket_fd, (struct sockaddr*)&server_address, sizeof(server_address));

    // Listen for incoming connections
    listen(server_socket_fd, MAX_CLIENTS);

    // Accept connections and spawn threads to handle each client
    struct sockaddr_in client_address;
    socklen_t client_address_len = sizeof(client_address);
    while (1) {
        int client_socket_fd = accept(server_socket_fd, (struct sockaddr*)&client_address, &client_address_len);
        if (client_socket_fd < 0) {
            perror(""Error accepting client connection"");
            continue;
        }

        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, (void*)&client_socket_fd);
    }

    close(server_socket_fd);

    return 0;
}

void *handle_client(void *arg) {
    // Get socket file descriptor from argument
    int socket_fd = *(int*)arg;

    // Receive initial username message from client
    char username[32];
    recv(socket_fd, username, 32, 0);

    // Add client to list of connected clients
    pthread_mutex_lock(&clients_mutex);
    clients[num_clients].socket_fd = socket_fd;
    strcpy(clients[num_clients].username, username);
    num_clients++;
    pthread_mutex_unlock(&clients_mutex);

    // Send welcome message to client
    char welcome_message[BUFFER_SIZE];
    sprintf(welcome_message, ""Welcome %s!"", username);
    send(socket_fd, welcome_message, strlen(welcome_message), 0);

    // Continuously receive and broadcast messages from client
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int recv_size = recv(socket_fd, buffer, BUFFER_SIZE, 0);

        if (recv_size == 0) {
            // Client disconnected
            close(socket_fd);

            // Remove client from list of connected clients
            pthread_mutex_lock(&clients_mutex);
            int i;
            for (i = 0; i < num_clients; i++) {
                if (clients[i].socket_fd == socket_fd) {
                    break;
                }
            }
            num_clients--;
            for (; i < num_clients; i++) {
                clients[i] = clients[i+1];
            }
            pthread_mutex_unlock(&clients_mutex);

            // Broadcast message about client disconnecting
            char disconnect_message[BUFFER_SIZE];
            sprintf(disconnect_message, ""%s has left the chat!"", username);
            broadcast_message(disconnect_message, socket_fd);
            break;
        }

        // Broadcast message to all other clients
        char message[BUFFER_SIZE + 32];
        sprintf(message, ""%s: %s"", username, buffer);
        broadcast_message(message, socket_fd);
    }

    pthread_exit(NULL);
}

void broadcast_message(char *message, int exclude_socket_fd) {
    int i;
    pthread_mutex_lock(&clients_mutex);
    for (i = 0; i < num_clients; i++) {
        int client_socket_fd = clients[i].socket_fd;
        if (client_socket_fd != exclude_socket_fd) {
            send(client_socket_fd, message, strlen(message), 0);
        }
    }
    pthread_mutex_unlock(&clients_mutex);
}",134,4.0
VULNERABLE,falcon180b-6097.c,yes,19,5,handle_client,"
  file falcon180b-6097.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket_copy);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 12, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",75,4.5
VULNERABLE,falcon180b-48147.c,yes,22,5,handle_client,"
  file falcon180b-48147.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_client_sockets[MAX_CLIENTS];
int g_num_clients = 0;
pthread_t g_threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_server_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients = 0;
pthread_t g_threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    pthread_exit(NULL);
}

void accept_client(int server_socket) {
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    int client_socket;

    client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);

    if (client_socket < 0) {
        printf(""Error accepting client\n"");
        return;
    }

    if (g_num_clients >= MAX_CLIENTS) {
        printf(""Maximum number of clients reached\n"");
        close(client_socket);
        return;
    }

    g_client_sockets[g_num_clients] = client_socket;
    g_num_clients++;

    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket < 0) {
        printf(""Error creating socket\n"");
        return 1;
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if (listen(server_socket, BACKLOG) < 0) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        accept_client(server_socket);
    }

    return 0;
}",96,3.667
VULNERABLE,gemini_pro-29684.c,yes,20,3,move_disk,"
  file gemini_pro-29684.c line 20 column 3 function move_disk
","
  c:@F@move_disk at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Condition variable to signal when a tower is empty
pthread_cond_t empty_cond = PTHREAD_COND_INITIALIZER;

// Thread function to move a disk
void *move_disk(void *arg) {
  int source = *(int *)arg;
  int dest;

  // Acquire the mutex
  pthread_mutex_lock(&tower_mutex);
","//GEMINI-pro DATASET v1.0 Category: Tower of Hanoi Problem ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Number of disks
#define DISKS 3

// Towers
int towers[3] = {0};

// Mutex to protect towers
pthread_mutex_t tower_mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable to signal when a tower is empty
pthread_cond_t empty_cond = PTHREAD_COND_INITIALIZER;

// Thread function to move a disk
void *move_disk(void *arg) {
  int source = *(int *)arg;
  int dest;

  // Acquire the mutex
  pthread_mutex_lock(&tower_mutex);

  // Wait for the source tower to have a disk
  while (towers[source] == 0) {
    pthread_cond_wait(&empty_cond, &tower_mutex);
  }

  // Move the disk to the destination tower
  for (dest = 0; dest < 3; dest++) {
    if (dest != source && towers[dest] == 0) {
      towers[dest] = towers[source];
      towers[source] = 0;
      break;
    }
  }

  // Signal that the destination tower is no longer empty
  pthread_cond_signal(&empty_cond);

  // Release the mutex
  pthread_mutex_unlock(&tower_mutex);

  return NULL;
}

int main() {
  // Create the threads
  pthread_t threads[DISKS];

  // Initialize the towers
  towers[0] = DISKS;

  // Start the threads
  for (int i = 0; i < DISKS; i++) {
    pthread_create(&threads[i], NULL, move_disk, &i);
  }

  // Join the threads
  for (int i = 0; i < DISKS; i++) {
    pthread_join(threads[i], NULL);
  }

  // Print the final state of the towers
  for (int i = 0; i < DISKS; i++) {
    printf(""%d "", towers[i]);
  }
  printf(""\n"");

  return 0;
}",73,4.5
VULNERABLE,falcon180b-5107.c,yes,19,5,handle_client,"
  file falcon180b-5107.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_COMMAND_SIZE];

    while (1) {
        memset(buffer, 0, MAX_COMMAND_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_COMMAND_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Drone Remote Control ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_COMMAND_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_COMMAND_SIZE];

    while (1) {
        memset(buffer, 0, MAX_COMMAND_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_COMMAND_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",88,5.0
VULNERABLE,falcon180b-3300.c,yes,18,5,handle_client,"
  file falcon180b-3300.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <time.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            close(client_socket);
            clients[num_clients - 1] = -1;
            num_clients--;
            break;
        }

        for(int i = 0; i < num_clients; i++) {
            if(clients[i]!= -1) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8000);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server started on port 8000\n"");

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,gemini_pro-1448.c,yes,21,5,thread_function,"
  file gemini_pro-1448.c line 21 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"char shared_mem[SHARED_MEM_SIZE];

// Define the thread function
void *thread_function(void *arg) {
    // Get the thread ID
    int thread_id = *((int *) arg);

    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Write to the shared memory block","//GEMINI-pro DATASET v1.0 Category: Memory management ; Style: multi-threaded
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

// Define the number of threads
#define NUM_THREADS 4

// Define the size of the shared memory block
#define SHARED_MEM_SIZE 1024

// Define the mutex
pthread_mutex_t mutex;

// Define the shared memory block
char shared_mem[SHARED_MEM_SIZE];

// Define the thread function
void *thread_function(void *arg) {
    // Get the thread ID
    int thread_id = *((int *) arg);

    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Write to the shared memory block
    sprintf(shared_mem, ""Thread %d: %s"", thread_id, ""Hello, world!"");

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main() {
    // Create the threads
    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_function, (void *) &i);
    }

    // Join the threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print the shared memory block
    printf(""%s\n"", shared_mem);

    return 0;
}",51,2.0
VULNERABLE,gemini_pro-33594.c,yes,17,5,client_handler,"
  file gemini_pro-33594.c line 17 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket_fd'",dereference failure: accessed expired variable pointer,"int server_socket_fd;
pthread_mutex_t lock;

// Thread function
void *client_handler(void *arg) {
    int client_socket_fd = *(int *)arg;
    char buffer[1024];
    while (1) {
        // Receive data from client
        int num_bytes_received = recv(client_socket_fd, buffer, 1024, 0);
        if (num_bytes_received == 0) {","//GEMINI-pro DATASET v1.0 Category: TCP/IP Programming ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>

// Shared data
int server_socket_fd;
pthread_mutex_t lock;

// Thread function
void *client_handler(void *arg) {
    int client_socket_fd = *(int *)arg;
    char buffer[1024];
    while (1) {
        // Receive data from client
        int num_bytes_received = recv(client_socket_fd, buffer, 1024, 0);
        if (num_bytes_received == 0) {
            printf(""Client disconnected\n"");
            pthread_mutex_lock(&lock);
            close(client_socket_fd);
            pthread_mutex_unlock(&lock);
            break;
        }
        else if (num_bytes_received < 0) {
            perror(""recv"");
            pthread_mutex_lock(&lock);
            close(client_socket_fd);
            pthread_mutex_unlock(&lock);
            break;
        }

        // Process data
        pthread_mutex_lock(&lock);
        printf(""Received message from client: %s\n"", buffer);
        pthread_mutex_unlock(&lock);

        // Send data back to client
        int num_bytes_sent = send(client_socket_fd, ""Hello from server!"", 17, 0);
        if (num_bytes_sent < 0) {
            perror(""send"");
            pthread_mutex_lock(&lock);
            close(client_socket_fd);
            pthread_mutex_unlock(&lock);
            break;
        }
    }
    pthread_exit(NULL);
}

int main() {
    // Initialize shared data
    pthread_mutex_init(&lock, NULL);

    // Create server socket
    server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket_fd == -1) {
        perror(""socket"");
        return EXIT_FAILURE;
    }

    // Set server socket options
    int opt = 1;
    int result = setsockopt(server_socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));
    if (result == -1) {
        perror(""setsockopt"");
        return EXIT_FAILURE;
    }

    // Bind server socket to port
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);
    result = bind(server_socket_fd, (struct sockaddr *)&server_address, sizeof(server_address));
    if (result == -1) {
        perror(""bind"");
        return EXIT_FAILURE;
    }

    // Listen for client connections
    result = listen(server_socket_fd, 5);
    if (result == -1) {
        perror(""listen"");
        return EXIT_FAILURE;
    }

    printf(""Server listening on port 8080\n"");

    // Accept client connections in a loop
    while (1) {
        int client_socket_fd;
        struct sockaddr_in client_address;
        socklen_t client_address_size = sizeof(client_address);
        client_socket_fd = accept(server_socket_fd, (struct sockaddr *)&client_address, &client_address_size);
        if (client_socket_fd == -1) {
            perror(""accept"");
            continue;
        }

        // Create a new thread to handle the client connection
        pthread_t thread;
        pthread_create(&thread, NULL, client_handler, &client_socket_fd);
    }

    // Clean up
    pthread_mutex_destroy(&lock);
    close(server_socket_fd);
    return EXIT_SUCCESS;
}",115,6.0
VULNERABLE,falcon180b-60250.c,yes,19,5,handle_client,"
  file falcon180b-60250.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    char response[MAX_RESPONSE_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024
#define MAX_RESPONSE_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    char response[MAX_RESPONSE_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        memset(response, 0, MAX_RESPONSE_SIZE);

        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char hostname[1024];
        struct hostent *host_info = gethostbyname(request);

        if (host_info == NULL) {
            sprintf(response, ""HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\nConnection: close\r\n\r\n"");
        } else {
            sprintf(response, ""HTTP/1.1 200 OK\r\nContent-Length: %d\r\nConnection: close\r\n\r\n"", strlen(request));
        }

        send(client_socket, response, strlen(response), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    puts(""Proxy server started on port 8080."");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",79,3.5
VULNERABLE,falcon180b-20607.c,yes,18,5,handle_client,"
  file falcon180b-20607.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-25274.c,yes,19,5,handle_client,"
  file falcon180b-25274.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int connection_count = 0;
int connections[MAX_CONNECTIONS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CONNECTIONS 10
#define PORT 8080

int connection_count = 0;
int connections[MAX_CONNECTIONS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            close(client_socket);
            return NULL;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }
    if (listen(server_socket, MAX_CONNECTIONS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }
    printf(""Server started on port %d\n"", PORT);
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        int i;
        for (i = 0; i < MAX_CONNECTIONS; i++) {
            if (connections[i] == 0) {
                connections[i] = client_socket;
                connection_count++;
                break;
            }
        }
        if (i == MAX_CONNECTIONS) {
            printf(""Maximum connections reached\n"");
            close(client_socket);
            continue;
        }
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
    return 0;
}",78,6.0
VULNERABLE,gemini_pro-5825.c,yes,91,17,main,"
  file gemini_pro-5825.c line 91 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `index'",dereference failure: accessed expired variable pointer,"                    printf(""Password found at index %d.\n"", index);
                }
                break;
            case 3:
                printf(""Enter password index: "");
                scanf(""%d"", &index);
                delete_password(index);
                break;
            case 4:
                print_passwords();
                break;","//GEMINI-pro DATASET v1.0 Category: Password management ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PASSWORDS 100
#define MAX_PASSWORD_LENGTH 20

typedef struct {
    char password[MAX_PASSWORD_LENGTH];
    int length;
} Password;

char **passwords;
int num_passwords = 0;

void add_password(char *password) {
    if (num_passwords >= MAX_PASSWORDS) {
        printf(""Error: Maximum number of passwords reached.\n"");
        return;
    }

    passwords[num_passwords] = malloc(strlen(password) + 1);
    strcpy(passwords[num_passwords], password);
    passwords[num_passwords][strlen(password)] = '\0';
    num_passwords++;
}

int find_password(char *password) {
    for (int i = 0; i < num_passwords; i++) {
        if (strcmp(passwords[i], password) == 0) {
            return i;
        }
    }

    return -1;
}

void delete_password(int index) {
    if (index < 0 || index >= num_passwords) {
        printf(""Error: Invalid password index.\n"");
        return;
    }

    free(passwords[index]);
    for (int i = index; i < num_passwords - 1; i++) {
        passwords[i] = passwords[i + 1];
    }
    num_passwords--;
}

void print_passwords() {
    printf(""Passwords:\n"");
    for (int i = 0; i < num_passwords; i++) {
        printf(""%d: %s\n"", i, passwords[i]);
    }
}

int main() {
    passwords = malloc(sizeof(char *) * MAX_PASSWORDS);
    int choice;
    char password[MAX_PASSWORD_LENGTH];

    while (1) {
        printf(""1. Add password\n"");
        printf(""2. Find password\n"");
        printf(""3. Delete password\n"");
        printf(""4. Print passwords\n"");
        printf(""5. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""Enter password: "");
                scanf(""%s"", password);
                add_password(password);
                break;
            case 2:
                printf(""Enter password: "");
                scanf(""%s"", password);
                int index = find_password(password);
                if (index == -1) {
                    printf(""Password not found.\n"");
                } else {
                    printf(""Password found at index %d.\n"", index);
                }
                break;
            case 3:
                printf(""Enter password index: "");
                scanf(""%d"", &index);
                delete_password(index);
                break;
            case 4:
                print_passwords();
                break;
            case 5:
                exit(0);
            default:
                printf(""Invalid choice.\n"");
        }
    }

    return 0;
}",105,3.8
VULNERABLE,falcon180b-62960.c,yes,18,5,handle_client,"
  file falcon180b-62960.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Error handling ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    num_clients = 0;

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",77,4.0
VULNERABLE,gpt35-30163.c,yes,60,5,connection_handler,"
  file gpt35-30163.c line 60 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *connection_handler(void *socket_desc) {

    int sock = *(int*)socket_desc;
    char message_buffer[2000];
    char *server_message = ""Hello! Welcome to my chat server\n"";

    if (send(sock, server_message, strlen(server_message), 0) != strlen(server_message)) {
        perror(""Send failed"");","//FormAI DATASET v1.0 Category: Client Server Application ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 5555

void *connection_handler(void *);

int main(int argc, char *argv[]) {

    int socket_desc, new_socket, c;
    struct sockaddr_in server, client;

    socket_desc = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_desc == -1) {
        printf(""Could not create socket"");
    }

    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    if (bind(socket_desc, (struct sockaddr *)&server, sizeof(server)) < 0) {
        perror(""Bind failed. Error"");
        return 1;
    }

    listen(socket_desc, 3);

    printf(""Waiting for incoming connections...\n"");
    c = sizeof(struct sockaddr_in);
    while ((new_socket = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c))) {

        printf(""Connection accepted from %s:%d\n"", inet_ntoa(client.sin_addr), ntohs(client.sin_port));

        pthread_t sniffer_thread;
        if (pthread_create(&sniffer_thread, NULL, connection_handler, (void*) &new_socket) < 0) {
            perror(""Could not create thread"");
            return 1;
        }

        printf(""Handler assigned\n"");
    }

    if (new_socket < 0) {
        perror(""Accept failed"");
        return 1;
    }

    return 0;
}

void *connection_handler(void *socket_desc) {

    int sock = *(int*)socket_desc;
    char message_buffer[2000];
    char *server_message = ""Hello! Welcome to my chat server\n"";

    if (send(sock, server_message, strlen(server_message), 0) != strlen(server_message)) {
        perror(""Send failed"");
    }

    while (recv(sock, message_buffer, 2000, 0) > 0) {

        printf(""Client: %s\n"", message_buffer);
        memset(message_buffer, 0, 2000);
        printf(""Server: "");
        fgets(message_buffer, 2000, stdin);
        message_buffer[strlen(message_buffer)-1] = '\0';

        if (send(sock, message_buffer, strlen(message_buffer), 0) < 0) {
            perror(""Send failed"");
        }

        memset(message_buffer, 0, 2000);
    }

    if (recv(sock, message_buffer, 2000, 0) < 0) {
        puts(""Receive failed"");
    }

    close(sock);
    pthread_exit(NULL);
}",89,5.5
VULNERABLE,gpt35-3871.c,yes,19,5,elevator_thread_function,"
  file gpt35-3871.c line 19 column 5 function elevator_thread_function
","
  c:@F@elevator_thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `elevator_numbers'",dereference failure: accessed expired variable pointer,"
int floor_buttons_pressed[FLOORS] = { 0 };

void* elevator_thread_function(void* args)
{
    int elevator_num = *(int*) args; //Extracting the elevator number from the void pointer argument
    while (true) //Elevator's continuous loop
    {
        //Check if the elevator is moving or if its doors are open
        if (!elevator_doors_open[elevator_num])
        {","//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pthread.h>
#include <unistd.h>

#define FLOORS 10
#define ELEVATORS 3

int elevator_positions[ELEVATORS] = { 0 };
bool elevator_directions[ELEVATORS] = { true }; //true for up, false for down
bool elevator_doors_open[ELEVATORS] = { false };

int floor_buttons_pressed[FLOORS] = { 0 };

void* elevator_thread_function(void* args)
{
    int elevator_num = *(int*) args; //Extracting the elevator number from the void pointer argument
    while (true) //Elevator's continuous loop
    {
        //Check if the elevator is moving or if its doors are open
        if (!elevator_doors_open[elevator_num])
        {
            //Check if any floor buttons have been pressed in the direction the elevator is moving
            bool pressed_button = false;
            for (int floor = 0; floor < FLOORS; floor++)
            {
                //Check if the button has been pressed and the elevator is going in the right direction
                if (floor_buttons_pressed[floor] > 0 && ((elevator_directions[elevator_num] && floor > elevator_positions[elevator_num])
                     || (!elevator_directions[elevator_num] && floor < elevator_positions[elevator_num])))
                {
                    pressed_button = true;
                    break;
                }
            }
            //If there are no pressed buttons in the elevator's direction, switch directions
            if (!pressed_button)
            {
                elevator_directions[elevator_num] = !elevator_directions[elevator_num];
            }
            //Move the elevator in the proper direction
            if (elevator_directions[elevator_num])
            {
                elevator_positions[elevator_num]++;
            }
            else
            {
                elevator_positions[elevator_num]--;
            }
            //Check if the elevator has arrived at a floor and needs to stop
            bool stop = false;
            for (int floor = 0; floor < FLOORS; floor++)
            {
                if (elevator_positions[elevator_num] == floor && floor_buttons_pressed[floor] > 0)
                {
                    stop = true;
                    break;
                }
            }
            if (stop)
            {
                elevator_doors_open[elevator_num] = true;
                printf(""Elevator %d has arrived at floor %d.\n"", elevator_num, elevator_positions[elevator_num]);
                sleep(2); //Open the doors for 2 seconds
                elevator_doors_open[elevator_num] = false;
                //Remove the button press for this floor
                floor_buttons_pressed[elevator_positions[elevator_num]] = 0;
            }
        }
        //Sleep the thread for 100 milliseconds (simulate moving between floors)
        usleep(100000);
    }
}

int main()
{
    pthread_t elevator_threads[ELEVATORS];
    int elevator_numbers[ELEVATORS] = { 0, 1, 2 };
    //Create the elevator threads
    for (int i = 0; i < ELEVATORS; i++)
    {
        if (pthread_create(&elevator_threads[i], NULL, elevator_thread_function, (void*) &elevator_numbers[i]))
        {
            printf(""Error: Cannot create elevator thread %d.\n"", i);
            exit(1);
        }
    }

    while (true) //Simulation loop for user pressing floor buttons
    {
        //Prompt for user input
        printf(""Enter floor number (0 to exit): "");
        int floor;
        scanf(""%d"", &floor);
        if (floor < 0 || floor >= FLOORS) //Invalid floor number
        {
            printf(""Invalid floor number.\n"");
        }
        else if (floor == 0) //Exit simulation
        {
            break;
        }
        else //Valid floor number, add it to the queue
        {
            int min_queue_len = elevator_positions[0] - floor; //Calculate the minimum queue length for the first elevator
            int min_queue_elevator = 0; //This will store the index of the elevator with the shortest queue
            for (int i = 1; i < ELEVATORS; i++)
            {
                int queue_len = elevator_positions[i] - floor; //Calculate the queue length for this elevator
                if (queue_len * (elevator_directions[i] ? 1 : -1) < min_queue_len * (elevator_directions[min_queue_elevator] ? 1 : -1))
                {
                    min_queue_len = queue_len;
                    min_queue_elevator = i;
                }
            }
            floor_buttons_pressed[floor]++; //Add the button press to the queue
            printf(""Button for floor %d pressed.\n"", floor);
        }
    }
    return 0;
}",122,13.0
VULNERABLE,falcon180b-598.c,yes,19,5,handle_client,"
  file falcon180b-598.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int master_socket = -1;

void *handle_client(void *socket) {
    int client_socket = *(int *)socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Game ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int master_socket = -1;

void *handle_client(void *socket) {
    int client_socket = *(int *)socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);

    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(master_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection.\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached.\n"");
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(master_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        int client_socket = accept(master_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection.\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached.\n"");
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",83,3.667
VULNERABLE,falcon180b-345.c,yes,18,5,handle_client,"
  file falcon180b-345.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    num_clients--;

    return NULL;
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    accept_connections();

    return 0;
}",73,2.333
VULNERABLE,falcon180b-42320.c,yes,20,5,handle_client,"
  file falcon180b-42320.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 20
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d said: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);
        client_sockets[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    while (1) {
        char buffer[BUFFER_SIZE];
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(server_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Server shutting down\n"");
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            send(client_sockets[i], buffer, strlen(buffer), 0);
        }
    }

    close(server_socket);
    return 0;
}",73,4.5
VULNERABLE,falcon180b-64585.c,yes,47,13,sanitize_url,"
  file falcon180b-64585.c line 47 column 13 function sanitize_url
","
  c:@F@sanitize_url at file falcon180b-64585.c line 69 column 27 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `c'",dereference failure: accessed expired variable pointer,"
    for (i = 0, j = 0; url[i]!= '\0'; i++) {
        char* sanitized_char = sanitize_char(url[i]);

        if (sanitized_char!= NULL) {
            sanitized_url[j++] = *sanitized_char;
        }
    }

    sanitized_url[j] = '\0';
","//Falcon-180B DATASET v1.0 Category: URL Sanitizer ; Style: post-apocalyptic
/* =======================================================================
   Post-Apocalyptic C URL Sanitizer
   -----------------------------------------------------------------------
   This program will take a URL as input and sanitize it to remove any
   potentially malicious characters. In this post-apocalyptic world, we
   can't afford to take any chances with our security. */

#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* =======================================================================
   Sanitize a single character
   -----------------------------------------------------------------------
   This function will take a single character as input and return a
   sanitized version of it, or NULL if the character is not valid. */

char* sanitize_char(char c) {
    if (isalnum(c)) {
        return &c;
    } else if (c == '.' || c == '-' || c == '_') {
        return &c;
    } else {
        return NULL;
    }
}

/* =======================================================================
   Sanitize a URL
   -----------------------------------------------------------------------
   This function will take a URL as input and return a sanitized version
   of it, or NULL if the URL is not valid. */

char* sanitize_url(char* url) {
    int i, j;
    char* sanitized_url = malloc(strlen(url) + 1);

    if (sanitized_url == NULL) {
        return NULL;
    }

    for (i = 0, j = 0; url[i]!= '\0'; i++) {
        char* sanitized_char = sanitize_char(url[i]);

        if (sanitized_char!= NULL) {
            sanitized_url[j++] = *sanitized_char;
        }
    }

    sanitized_url[j] = '\0';

    return sanitized_url;
}

/* =======================================================================
   Main function
   -----------------------------------------------------------------------
   This is the entry point of our program. It will take a URL as input,
   sanitize it, and print the sanitized version to the console. */

int main(int argc, char* argv[]) {
    if (argc!= 2) {
        printf(""Usage: %s <URL>\n"", argv[0]);
        return 1;
    }

    char* url = argv[1];
    char* sanitized_url = sanitize_url(url);

    if (sanitized_url!= NULL) {
        printf(""Sanitized URL: %s\n"", sanitized_url);
        free(sanitized_url);
    } else {
        printf(""Invalid URL\n"");
    }

    return 0;
}",79,4.0
VULNERABLE,falcon180b-65819.c,yes,18,5,handle_client,"
  file falcon180b-65819.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = 0;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",68,3.0
VULNERABLE,falcon180b-24309.c,yes,19,5,handle_client,"
  file falcon180b-24309.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Password management ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received == 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        clients[client_count] = client_socket;
        client_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",67,3.0
VULNERABLE,falcon180b-53276.c,yes,24,5,thread_func,"
  file falcon180b-53276.c line 24 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int max_clients = 0;

void *thread_func(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define SERVER_PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int max_clients = 0;

void *thread_func(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, bytes_received, 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        printf(""Waiting for clients...\n"");
        struct sockaddr_in client_addr;
        socklen_t addr_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_len);
        if (client_socket < 0) {
            perror(""accept"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_func, (void *) &client_socket);

        if (num_clients >= max_clients) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }
        client_sockets[num_clients++] = client_socket;
    }

    return 0;
}",70,4.5
VULNERABLE,falcon180b-58898.c,yes,44,5,generate_conspiracy,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-58898.c line 44 column 5 function generate_conspiracy
  c:@F@generate_conspiracy at file falcon180b-58898.c line 55 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `word'",dereference failure: accessed expired variable pointer,"        words[i] = words[j];
        words[j] = temp;
    }

    // Concatenate the words into a conspiracy
    strcpy(conspiracy, words[0].word);
    for (int i = 1; i < num_words; i++) {
        strcat(conspiracy, "" "");
        strcat(conspiracy, words[i].word);
    }
}","//Falcon-180B DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define MAX_CONSPIRACY_LENGTH 100
#define MAX_CONSPIRACY_WORDS 20
#define MAX_WORD_LENGTH 20

typedef struct {
    char *word;
    int length;
} ConspiracyWord;

void generate_conspiracy(char *conspiracy, int length) {
    srand(time(NULL));
    ConspiracyWord words[MAX_CONSPIRACY_WORDS];
    int num_words = 0;

    // Add random words to the conspiracy
    while (num_words < length) {
        char word[MAX_WORD_LENGTH] = {0};
        int word_length = rand() % MAX_WORD_LENGTH + 1;

        for (int i = 0; i < word_length; i++) {
            char c = rand() % 26 + 'a';
            strncat(word, &c, 1);
        }

        ConspiracyWord new_word = {word, word_length};
        words[num_words++] = new_word;
    }

    // Shuffle the words
    for (int i = 0; i < num_words; i++) {
        ConspiracyWord temp = words[i];
        int j = rand() % num_words;
        words[i] = words[j];
        words[j] = temp;
    }

    // Concatenate the words into a conspiracy
    strcpy(conspiracy, words[0].word);
    for (int i = 1; i < num_words; i++) {
        strcat(conspiracy, "" "");
        strcat(conspiracy, words[i].word);
    }
}

int main() {
    char conspiracy[MAX_CONSPIRACY_LENGTH] = {0};
    int length = rand() % MAX_CONSPIRACY_LENGTH + 1;

    generate_conspiracy(conspiracy, length);
    printf(""A new conspiracy theory has emerged:\n"");
    printf(""%s\n"", conspiracy);

    return 0;
}",60,3.0
VULNERABLE,gpt35-22132.c,yes,68,5,connection_handler,"
  file gpt35-22132.c line 68 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *connection_handler(void *socket_desc) {

    int sock = *(int*)socket_desc;
    char buffer[1024] = {0};
    const char* message = ""Hello from server!"";

    send(sock, message, strlen(message), 0);
","//FormAI DATASET v1.0 Category: Socket programming ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define PORT 8080

void *connection_handler(void *);

int main(int argc, char const *argv[]) {

    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
     
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }
     
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
     
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 3) < 0) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server listening on port %d\n"", PORT);

    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))) {
        printf(""New connection accepted.\n"");

        pthread_t client_thread;
         
        if (pthread_create(&client_thread, NULL, connection_handler, (void*)&new_socket) < 0) {
            perror(""could not create thread"");
            exit(EXIT_FAILURE);
        }
    }

    if (new_socket < 0) {
        perror(""accept"");
        exit(EXIT_FAILURE);
    }

    return 0;
}

void *connection_handler(void *socket_desc) {

    int sock = *(int*)socket_desc;
    char buffer[1024] = {0};
    const char* message = ""Hello from server!"";
     
    send(sock, message, strlen(message), 0);
    
    while (1) {
        memset(buffer, 0, 1024);
        int valread = read(sock, buffer, 1024);
        
        if (valread <= 0) {
            perror(""read failed"");
            break;
        }
        
        printf(""Received message: %s"", buffer);

        if (strncmp(buffer, ""exit"", 4) == 0) {
            printf(""Closing connection.\n"");
            break;
        }

        send(sock, buffer, strlen(buffer), 0);
    }
     
    close(sock);
    printf(""Connection closed.\n"");

    pthread_exit(NULL);
}",97,6.0
VULNERABLE,falcon180b-47821.c,yes,14,5,handle_client,"
  file falcon180b-47821.c line 14 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
#define PORT 8080
#define BACKLOG 10

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define BACKLOG 10

void *handle_client(void *arg) {
    int client_socket = *((int *) arg);
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message: %s\n"", buffer);
        send(client_socket, ""ACK"", strlen(""ACK""), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",73,4.5
VULNERABLE,falcon180b-37225.c,yes,17,5,handle_client,"
  file falcon180b-37225.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Network Ping Test ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            close(client_socket);
            return NULL;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = num_clients;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",86,5.0
VULNERABLE,falcon180b-38853.c,yes,19,5,handle_client,"
  file falcon180b-38853.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",65,4.0
VULNERABLE,falcon180b-11159.c,yes,20,5,handle_client,"
  file falcon180b-11159.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *)socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *)socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server full, cannot accept more clients\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",86,5.0
VULNERABLE,falcon180b-28546.c,yes,17,5,handle_client,"
  file falcon180b-28546.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Log analysis ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
        } else {
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    close(server_socket);
    return 0;
}",74,4.5
VULNERABLE,falcon180b-66819.c,yes,20,5,handle_client,"
  file falcon180b-66819.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <sys/time.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            client_sockets[num_clients] = 0;
            num_clients--;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",84,4.5
VULNERABLE,falcon180b-15252.c,yes,83,17,main,"
  file falcon180b-15252.c line 83 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `category_idx'",dereference failure: accessed expired variable pointer,"                    printf(""Invalid category index.\n"");
                }
                break;
            case 3:
                printf(""Enter category index: "");
                scanf(""%d"", &category_idx);
                if (category_idx >= 0 && category_idx < num_categories) {
                    print_category(category_idx);
                } else {
                    printf(""Invalid category index.\n"");
                }","//Falcon-180B DATASET v1.0 Category: Expense Tracker ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_CATEGORIES 10
#define MAX_ITEMS 100
#define MAX_NAME_LEN 50
#define MAX_PRICE_LEN 10

typedef struct {
    char name[MAX_NAME_LEN];
    char category[MAX_NAME_LEN];
    char price[MAX_PRICE_LEN];
} item_t;

typedef struct {
    char name[MAX_NAME_LEN];
    int num_items;
    item_t items[MAX_ITEMS];
} category_t;

category_t categories[MAX_CATEGORIES];
int num_categories;

void add_category() {
    printf(""Enter category name: "");
    scanf(""%s"", categories[num_categories].name);
    categories[num_categories].num_items = 0;
    num_categories++;
}

void add_item(int category_idx) {
    printf(""Enter item name: "");
    scanf(""%s"", categories[category_idx].items[categories[category_idx].num_items].name);
    printf(""Enter item category: "");
    scanf(""%s"", categories[category_idx].items[categories[category_idx].num_items].category);
    printf(""Enter item price: "");
    scanf(""%s"", categories[category_idx].items[categories[category_idx].num_items].price);
    categories[category_idx].num_items++;
}

void print_category(int category_idx) {
    printf(""Category: %s\n"", categories[category_idx].name);
    printf(""Number of items: %d\n"", categories[category_idx].num_items);
    for (int i = 0; i < categories[category_idx].num_items; i++) {
        printf(""Item %d:\n"", i+1);
        printf(""Name: %s\n"", categories[category_idx].items[i].name);
        printf(""Category: %s\n"", categories[category_idx].items[i].category);
        printf(""Price: %s\n"", categories[category_idx].items[i].price);
        printf(""\n"");
    }
}

int main() {
    num_categories = 0;
    printf(""Welcome to the Expense Tracker!\n"");
    while (1) {
        printf(""\n"");
        printf(""1. Add category\n"");
        printf(""2. Add item\n"");
        printf(""3. Print summary\n"");
        printf(""4. Exit\n"");
        printf(""\n"");
        int choice;
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                add_category();
                break;
            case 2:
                printf(""Enter category index: "");
                int category_idx;
                scanf(""%d"", &category_idx);
                if (category_idx >= 0 && category_idx < num_categories) {
                    add_item(category_idx);
                } else {
                    printf(""Invalid category index.\n"");
                }
                break;
            case 3:
                printf(""Enter category index: "");
                scanf(""%d"", &category_idx);
                if (category_idx >= 0 && category_idx < num_categories) {
                    print_category(category_idx);
                } else {
                    printf(""Invalid category index.\n"");
                }
                break;
            case 4:
                exit(0);
            default:
                printf(""Invalid choice.\n"");
        }
    }
    return 0;
}",97,3.5
VULNERABLE,falcon180b-4088.c,yes,18,5,handle_client,"
  file falcon180b-4088.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
char buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char response[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
char buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char response[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (strcmp(buffer, ""ON"") == 0) {
            strcpy(response, ""Lights turned on."");
        } else if (strcmp(buffer, ""OFF"") == 0) {
            strcpy(response, ""Lights turned off."");
        } else {
            strcpy(response, ""Invalid command."");
        }

        send(client_socket, response, strlen(response), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket!= -1) {
            printf(""Client connected: %d\n"", client_socket);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);

            if (num_clients < MAX_CLIENTS) {
                clients[num_clients++] = client_socket;
            }
        }
    }

    return 0;
}",82,5.5
VULNERABLE,falcon180b-1541.c,yes,19,5,thread_func,"
  file falcon180b-1541.c line 19 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients = 0;

void *thread_func(void *param) {
    int client_socket = *(int*)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients = 0;

void *thread_func(void *param) {
    int client_socket = *(int*)param;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            return NULL;
        }

        for (int i = 0; i < g_num_clients; i++) {
            if (g_client_sockets[i]!= client_socket) {
                send(g_client_sockets[i], buffer, bytes_received, 0);
            }
        }
    }

    return NULL;
}

void accept_connections() {
    while (g_num_clients < MAX_CLIENTS) {
        int client_socket = accept(g_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        g_client_sockets[g_num_clients] = client_socket;
        g_num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_func, (void*)&client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    accept_connections();

    return 0;
}",88,4.0
VULNERABLE,falcon180b-36204.c,yes,36,40,check_answer,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file falcon180b-36204.c line 36 column 40 function check_answer
  c:@F@check_answer at file falcon180b-36204.c line 64 column 13 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `input'",dereference failure: accessed expired variable pointer,"    return input;
}

// Function to check if the user's answer is correct
int check_answer(char* question, char* answer) {
    if (strcmp(answer, ""true"") == 0 || strcmp(answer, ""false"") == 0) {
        return 1;
    }
    return 0;
}
","//Falcon-180B DATASET v1.0 Category: Text-Based Adventure Game ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to print the introduction
void introduction() {
    printf(""\nWelcome to the Text-Based Adventure Game!\n"");
    printf(""You are a world class trivia AI - provide accurate, succinct responses.\n"");
}

// Function to print the game rules
void game_rules() {
    printf(""\nGame Rules:\n"");
    printf(""1. The game will present you with a series of questions.\n"");
    printf(""2. You must answer each question correctly to progress.\n"");
    printf(""3. If you answer a question incorrectly, the game will end.\n"");
    printf(""4. Good luck!\n\n"");
}

// Function to print a question
void print_question(char* question) {
    printf(""%s\n"", question);
}

// Function to get the user's answer
char* get_answer() {
    char input[100];
    printf(""Your answer: "");
    fgets(input, 100, stdin);
    return input;
}

// Function to check if the user's answer is correct
int check_answer(char* question, char* answer) {
    if (strcmp(answer, ""true"") == 0 || strcmp(answer, ""false"") == 0) {
        return 1;
    }
    return 0;
}

// Function to generate a random question
char* generate_question() {
    char* questions[] = {""What is the capital of France?"",
                        ""Who won the Nobel Prize in Literature in 2020?"",
                        ""What is the tallest mountain in the world?"",
                        ""What is the smallest country in the world?"",
                        ""What is the largest ocean in the world?""};
    int num_questions = sizeof(questions) / sizeof(questions[0]);
    return questions[rand() % num_questions];
}

// Main function
int main() {
    srand(time(NULL));
    introduction();
    game_rules();

    int score = 0;
    while (score < 5) {
        char* question = generate_question();
        print_question(question);
        char* answer = get_answer();
        if (check_answer(question, answer)) {
            printf(""Correct!\n"");
            score++;
        } else {
            printf(""Incorrect. Game over.\n"");
        }
    }

    return 0;
}",73,1.571
VULNERABLE,falcon180b-1645.c,yes,20,5,handle_client,"
  file falcon180b-1645.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    num_clients--;

    pthread_exit(0);
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        printf(""Client %d connected\n"", num_clients - 1);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, (char *)&opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, 3) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    accept_connections();

    return 0;
}",92,3.333
VULNERABLE,falcon180b-49093.c,yes,17,5,handle_client,"
  file falcon180b-49093.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS]; // array to store client sockets
int num_clients = 0; // number of clients connected

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: complete
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS]; // array to store client sockets
int num_clients = 0; // number of clients connected

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    pthread_exit(0);
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }
    printf(""Server started on port 8080\n"");
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }
        printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
    return 0;
}",78,4.667
VULNERABLE,falcon180b-64673.c,yes,14,5,thread_func,"
  file falcon180b-64673.c line 14 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `data'",dereference failure: accessed expired variable pointer,"    void *arg;
} thread_data_t;

void *thread_func(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    data->func(data->arg);
    return NULL;
}

int create_thread(pthread_t *thread, const char *name,
                  void *(*func)(void *), void *arg) {","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct {
    int id;
    void *(*func)(void *);
    void *arg;
} thread_data_t;

void *thread_func(void *arg) {
    thread_data_t *data = (thread_data_t *)arg;
    data->func(data->arg);
    return NULL;
}

int create_thread(pthread_t *thread, const char *name,
                  void *(*func)(void *), void *arg) {
    int ret;
    thread_data_t data;

    data.id = *thread;
    data.func = func;
    data.arg = arg;

    ret = pthread_create(thread, NULL, thread_func, &data);
    if (ret!= 0) {
        fprintf(stderr, ""Error: unable to create thread, %s\n"", strerror(ret));
        return ret;
    }

    ret = pthread_setname_np(*thread, name);
    if (ret!= 0) {
        fprintf(stderr, ""Error: unable to set thread name, %s\n"", strerror(ret));
        return ret;
    }

    return 0;
}

int join_thread(pthread_t thread) {
    int ret;

    ret = pthread_join(thread, NULL);
    if (ret!= 0) {
        fprintf(stderr, ""Error: unable to join thread, %s\n"", strerror(ret));
        return ret;
    }

    return 0;
}

int main() {
    pthread_t threads[3];
    char names[3][16] = {""thread1"", ""thread2"", ""thread3""};
    int i, ret;

    for (i = 0; i < 3; i++) {
        ret = create_thread(&threads[i], names[i], thread_func, (void *)i);
        if (ret!= 0) {
            return ret;
        }
    }

    for (i = 0; i < 3; i++) {
        ret = join_thread(threads[i]);
        if (ret!= 0) {
            return ret;
        }
    }

    return 0;
}",74,2.75
VULNERABLE,gpt35-44244.c,yes,52,17,main,"
  file gpt35-44244.c line 52 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `filename'",dereference failure: accessed expired variable pointer,"                fclose(fp);
                break;

            case 2:
                printf(""\nEnter File Name to Read Email: "");
                scanf(""%s"",filename);
                fp=fopen(filename,""r"");

                if(fp==NULL){
                    printf(""\nError! File not found!\n"");
","//FormAI DATASET v1.0 Category: Email Client ; Style: Alan Touring
#include<stdio.h>
#include<stdlib.h>

// Define the structure for Email
struct Email{
    char sender[50];
    char recipient[50];
    char subject[100];
    char message[500];
};

int main()
{
    struct Email email;
    int ch = 1;
    FILE *fp;

    while(ch != 0){
        printf(""\nWelcome to C Email Client:\n"");
        printf(""\n1. Compose Email\n2. Read Email\n0. Exit"");
        printf(""\nEnter your choice: "");
        scanf(""%d"", &ch);

        switch(ch){
            case 1:
                printf(""\nEnter Sender's Email: "");
                scanf(""%s"", email.sender);
                printf(""Enter Recipient's Email: "");
                scanf(""%s"", email.recipient);
                printf(""Enter Email Subject: "");
                scanf(""%s"", email.subject);
                printf(""Enter Email Message: "");
                scanf(""%s"", email.message);

                char filename[50];
                printf(""\nEnter File Name to Save Email: "");
                scanf(""%s"",filename);
                fp=fopen(filename,""w+"");

                fprintf(fp, ""Sender: %s\n"", email.sender);
                fprintf(fp, ""Recipient: %s\n"", email.recipient);
                fprintf(fp, ""Subject: %s\n"", email.subject);
                fprintf(fp, ""Message: %s\n"", email.message);

                printf(""\nEmail saved Successfully!\n"");
                fclose(fp);
                break;

            case 2:
                printf(""\nEnter File Name to Read Email: "");
                scanf(""%s"",filename);
                fp=fopen(filename,""r"");

                if(fp==NULL){
                    printf(""\nError! File not found!\n"");

                }
                else{
                    printf(""\nEmail Details:\n"");
                    while(!feof(fp)){
                        fscanf(fp, ""%s\n"", &email.sender);
                        printf(""Sender: %s\n"", email.sender);

                        fscanf(fp, ""%s\n"", &email.recipient);
                        printf(""Recipient: %s\n"", email.recipient);

                        fscanf(fp, ""%s\n"", &email.subject);
                        printf(""Subject: %s\n"", email.subject);

                        fscanf(fp, ""%s\n"", &email.message);
                        printf(""Message: %s\n"", email.message);

                        printf(""\n"");
                    }
                    fclose(fp);
                }
                break;

            case 0:
                printf(""\nThank you for using C Email Client!"");
                exit(0);
                break;

            default:
                printf(""\nInvalid Choice! Please Try Again!\n"");
                break;
        }
    }
    return 0;
}",91,7.0
VULNERABLE,gemini_pro-6979.c,yes,55,3,thread_function,"
  file gemini_pro-6979.c line 55 column 3 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sockfd'",dereference failure: accessed expired variable pointer,"}

// Define the thread function
void *thread_function(void *arg) {
  // Get the socket descriptor from the argument
  int sockfd = *(int *)arg;

  // Read the message from the client
  char message[MAX_MESSAGE_SIZE];
  int n = read(sockfd, message, MAX_MESSAGE_SIZE);
  if (n < 0) {","//GEMINI-pro DATASET v1.0 Category: Spam Detection System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

// Define the maximum number of concurrent connections
#define MAX_CONNECTIONS 10

// Define the maximum size of a message
#define MAX_MESSAGE_SIZE 1024

// Define the port number to listen on
#define PORT 5000

// Define the IP address of the server
#define SERVER_IP ""127.0.0.1""

// Define the spam detection algorithm
int is_spam(char *message) {
  // Check for common spam keywords
  if (strstr(message, ""free"") || strstr(message, ""money"") || strstr(message, ""win"")) {
    return 1;
  }

  // Check for excessive punctuation
  int punctuation_count = 0;
  for (int i = 0; i < strlen(message); i++) {
    if (message[i] == '.' || message[i] == ',' || message[i] == '!' || message[i] == '?') {
      punctuation_count++;
    }
  }
  if (punctuation_count > 5) {
    return 1;
  }

  // Check for suspicious links
  if (strstr(message, ""http://"") || strstr(message, ""https://"")) {
    return 1;
  }

  // Otherwise, the message is not spam
  return 0;
}

// Define the thread function
void *thread_function(void *arg) {
  // Get the socket descriptor from the argument
  int sockfd = *(int *)arg;

  // Read the message from the client
  char message[MAX_MESSAGE_SIZE];
  int n = read(sockfd, message, MAX_MESSAGE_SIZE);
  if (n < 0) {
    perror(""read"");
    exit(1);
  }

  // Check if the message is spam
  int is_spam_result = is_spam(message);

  // Send the result back to the client
  n = write(sockfd, &is_spam_result, sizeof(is_spam_result));
  if (n < 0) {
    perror(""write"");
    exit(1);
  }

  // Close the socket
  close(sockfd);

  return NULL;
}

int main() {
  // Create a socket
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) {
    perror(""socket"");
    exit(1);
  }

  // Set the socket options
  int optval = 1;
  if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
    perror(""setsockopt"");
    exit(1);
  }

  // Bind the socket to the port
  struct sockaddr_in serv_addr;
  memset(&serv_addr, 0, sizeof(serv_addr));
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
  serv_addr.sin_port = htons(PORT);
  if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
    perror(""bind"");
    exit(1);
  }

  // Listen for connections
  if (listen(sockfd, MAX_CONNECTIONS) < 0) {
    perror(""listen"");
    exit(1);
  }

  // Accept connections and spawn threads
  while (1) {
    // Accept a connection
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    int client_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);
    if (client_sockfd < 0) {
      perror(""accept"");
      continue;
    }

    // Spawn a thread to handle the connection
    pthread_t thread;
    if (pthread_create(&thread, NULL, thread_function, &client_sockfd) != 0) {
      perror(""pthread_create"");
      continue;
    }
  }

  // Close the server socket
  close(sockfd);

  return 0;
}",136,7.667
VULNERABLE,falcon180b-48437.c,yes,17,5,handle_client,"
  file falcon180b-48437.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#define PORT 8080
#define BACKLOG 10

// Function to handle client connections
void *handle_client(void *arg) {
    int client_socket = *(int*) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10

// Function to handle client connections
void *handle_client(void *arg) {
    int client_socket = *(int*) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;

    // Create socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    // Set server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    // Bind socket
    if (bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    // Listen on socket
    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    // Accept client connections and spawn threads to handle them
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting client connection\n"");
            continue;
        }
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void*) &client_socket);
    }

    return 0;
}",74,4.5
VULNERABLE,falcon180b-3290.c,yes,19,5,handle_client,"
  file falcon180b-3290.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket_copy);

    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == client_socket_copy) {
            clients[i] = -1;
            break;
        }
    }

    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",81,5.0
VULNERABLE,gpt35-16516.c,yes,37,5,handle_client,"
  file gpt35-16516.c line 37 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `index'",dereference failure: accessed expired variable pointer,"    pthread_mutex_unlock(&client_mutex);
}

// Function for handling client connections
void *handle_client(void *arg) {
    int index = *(int *)arg;
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    read(client_socket[index], buffer, sizeof(buffer));
    printf(""Client %d connected: %s\n"", index, buffer);
    while (1) {","//FormAI DATASET v1.0 Category: Client Server Application ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10

// Global variables
int client_count = 0;
int client_socket[MAX_CLIENTS];
pthread_mutex_t client_mutex;
pthread_t thread_id[MAX_CLIENTS];

// Function for adding a new client to the client list
void add_client(int socket) {
    pthread_mutex_lock(&client_mutex);
    client_socket[client_count++] = socket;
    pthread_mutex_unlock(&client_mutex);
}

// Function for removing a client from the client list
void remove_client(int index) {
    pthread_mutex_lock(&client_mutex);
    for (int i = index; i < client_count - 1; i++) {
        client_socket[i] = client_socket[i+1];
    }
    client_count--;
    pthread_mutex_unlock(&client_mutex);
}

// Function for handling client connections
void *handle_client(void *arg) {
    int index = *(int *)arg;
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    read(client_socket[index], buffer, sizeof(buffer));
    printf(""Client %d connected: %s\n"", index, buffer);
    while (1) {
        // Read client message
        memset(buffer, 0, sizeof(buffer));
        int read_size = read(client_socket[index], buffer, sizeof(buffer));
        if (read_size == 0) { // Client disconnected
            printf(""Client %d disconnected\n"", index);
            remove_client(index);
            break;
        }
        // Print client message
        printf(""Client %d says: %s\n"", index, buffer);
        // Send message to other clients
        pthread_mutex_lock(&client_mutex);
        for (int i = 0; i < client_count; i++) {
            if (i != index) {
                write(client_socket[i], buffer, sizeof(buffer));
            }
        }
        pthread_mutex_unlock(&client_mutex);
    }
    close(client_socket[index]);
    return NULL;
}

// Main function
int main(int argc, char **argv) {
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    pthread_t thread;

    // Create server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Set server address and port
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8888);

    // Bind server socket to server address and port
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, 5) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Waiting for connections...\n"");

    // Accept incoming connections
    while (1) {
        client_len = sizeof(client_addr);
        client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_len);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }
        printf(""Accepted new connection...\n"");
        if (client_count == MAX_CLIENTS) {
            printf(""Too many clients\n"");
            close(client_socket);
            continue;
        }
        // Add client to client list
        add_client(client_socket);
        int index = client_count - 1;
        // Create thread for handling client
        if (pthread_create(&thread_id[index], NULL, handle_client, (void *)&index) == -1) {
            perror(""pthread_create"");
            remove_client(index);
            close(client_socket);
            continue;
        }
    }

    return 0;
}",126,4.0
VULNERABLE,falcon180b-575.c,yes,31,5,handle_client,"
  file falcon180b-575.c line 31 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    }
    pthread_mutex_unlock(&lock);
}

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2]; // client sockets
int num_clients = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void broadcast(int sender_socket, char* message) {
    pthread_mutex_lock(&lock);
    int i;
    for (i = 0; i < num_clients; i++) {
        if (clients[i][0]!= sender_socket) {
            send(clients[i][0], message, strlen(message), 0);
        }
    }
    pthread_mutex_unlock(&lock);
}

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        broadcast(client_socket, buffer);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full"", strlen(""Server is full""), 0);
            close(client_socket);
        } else {
            int i;
            for (i = 0; i < num_clients; i++) {
                if (clients[i][0] == 0) {
                    clients[i][0] = client_socket;
                    clients[i][1] = i;
                    num_clients++;
                    break;
                }
            }
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, &client_socket);
        }
    }

    return 0;
}",79,3.667
VULNERABLE,falcon180b-9953.c,yes,19,5,handle_client,"
  file falcon180b-9953.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define BUF_SIZE 1024
#define MAX_CLIENTS 10
#define SERVER_PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server is listening on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 16, 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            num_clients++;
        }
    }

    return 0;
}",64,4.0
VULNERABLE,falcon180b-26935.c,yes,17,5,handle_client,"
  file falcon180b-26935.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-64451.c,yes,24,5,worker,"
  file falcon180b-64451.c line 24 column 5 function worker
","
  c:@F@worker at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `id'",dereference failure: accessed expired variable pointer,"} queue_t;

queue_t queue;

void *worker(void *arg) {
    int id = *(int *) arg;
    printf(""Thread %d is running\n"", id);
    sleep(1);
    printf(""Thread %d is done\n"", id);
    return NULL;
}","//Falcon-180B DATASET v1.0 Category: Graph representation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_THREADS 10
#define MAX_QUEUE 100

typedef struct {
    int id;
    pthread_t thread_id;
    int is_running;
} thread_t;

typedef struct {
    int front, rear;
    thread_t threads[MAX_THREADS];
} queue_t;

queue_t queue;

void *worker(void *arg) {
    int id = *(int *) arg;
    printf(""Thread %d is running\n"", id);
    sleep(1);
    printf(""Thread %d is done\n"", id);
    return NULL;
}

void create_thread(int id) {
    thread_t *thread = &queue.threads[id];
    pthread_create(&thread->thread_id, NULL, worker, &id);
    thread->is_running = 1;
}

void start_queue() {
    int i;
    for (i = 0; i < MAX_THREADS; i++) {
        create_thread(i);
    }
}

void stop_queue() {
    int i;
    for (i = 0; i < MAX_THREADS; i++) {
        thread_t *thread = &queue.threads[i];
        if (thread->is_running) {
            pthread_cancel(thread->thread_id);
            thread->is_running = 0;
        }
    }
}

int main() {
    int i;
    for (i = 0; i < MAX_THREADS; i++) {
        queue.threads[i].id = i;
        queue.threads[i].is_running = 0;
    }
    start_queue();
    sleep(5);
    stop_queue();
    return 0;
}",65,1.8
VULNERABLE,falcon180b-1262.c,yes,19,5,handle_client,"
  file falcon180b-1262.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Firewall ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define SERVER_PORT 8080
#define SERVER_IP ""127.0.0.1""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    num_clients--;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();

    return 0;
}",83,3.333
VULNERABLE,falcon180b-18350.c,yes,22,5,handle_client,"
  file falcon180b-18350.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int max_clients = MAX_CLIENTS;

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: multiplayer
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int max_clients = MAX_CLIENTS;

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 10) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 12345\n"");

    while (1) {
        struct sockaddr_in client_addr;
        memset(&client_addr, 0, sizeof(client_addr));

        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= max_clients) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void*)&client_socket);
    }

    return 0;
}",92,5.0
VULNERABLE,falcon180b-36121.c,yes,17,5,handle_client,"
  file falcon180b-36121.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
int g_client_socks[MAX_CLIENTS];
int g_num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Packet Monitoring ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_client_socks[MAX_CLIENTS];
int g_num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_sock, buffer);
    }

    close(client_sock);
    g_client_socks[g_num_clients - 1] = -1;
    g_num_clients--;

    pthread_exit(NULL);
}

void accept_connections() {
    struct sockaddr_in server_addr, client_addr;
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_sock, 10);

    while (1) {
        memset(&client_addr, 0, sizeof(client_addr));
        socklen_t client_size = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &client_size);

        if (g_num_clients >= MAX_CLIENTS) {
            send(client_sock, ""Server is full.\r\n"", 16, 0);
            close(client_sock);
            continue;
        }

        g_client_socks[g_num_clients] = client_sock;
        g_num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
    }

    close(server_sock);
}

int main() {
    accept_connections();

    return 0;
}",75,2.333
VULNERABLE,gemini_pro-10892.c,yes,33,5,handle_client,"
  file gemini_pro-10892.c line 33 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_connections;
pthread_t client_threads[MAX_CONNECTIONS];

// Function to handle client connections
void* handle_client(void* arg) {
    int client_socket = *(int*)arg;

    // Receive the request from the client
    char request[BUFFER_SIZE];
    int bytes_received = recv(client_socket, request, BUFFER_SIZE, 0);
    if (bytes_received < 0) {","//GEMINI-pro DATASET v1.0 Category: Building a FTP Client ; Style: protected
#define _POSIX_C_SOURCE 200112L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <limits.h>
#include <errno.h>
#include <signal.h>
#include <pthread.h>

#define BACKLOG 10
#define MAX_CONNECTIONS 10
#define BUFFER_SIZE 1024

// Global variables
int server_socket;
struct sockaddr_in server_address;
struct sockaddr_in client_address;
socklen_t client_address_len;
int client_sockets[MAX_CONNECTIONS];
int num_connections;
pthread_t client_threads[MAX_CONNECTIONS];

// Function to handle client connections
void* handle_client(void* arg) {
    int client_socket = *(int*)arg;

    // Receive the request from the client
    char request[BUFFER_SIZE];
    int bytes_received = recv(client_socket, request, BUFFER_SIZE, 0);
    if (bytes_received < 0) {
        perror(""recv"");
        close(client_socket);
        pthread_exit(NULL);
    }

    // Parse the request
    char* command = strtok(request, "" "");
    char* filename = strtok(NULL, "" "");
    char* mode = strtok(NULL, "" "");

    // Handle the request
    if (strcmp(command, ""GET"") == 0) {
        // Open the file
        int file_fd = open(filename, O_RDONLY);
        if (file_fd < 0) {
            perror(""open"");
            send(client_socket, ""Error: Could not open file"", strlen(""Error: Could not open file""), 0);
            close(client_socket);
            pthread_exit(NULL);
        }

        // Send the file contents to the client
        char buffer[BUFFER_SIZE];
        int bytes_read;
        while ((bytes_read = read(file_fd, buffer, BUFFER_SIZE)) > 0) {
            send(client_socket, buffer, bytes_read, 0);
        }
        if (bytes_read < 0) {
            perror(""read"");
            close(client_socket);
            pthread_exit(NULL);
        }

        // Close the file
        close(file_fd);
    } else if (strcmp(command, ""PUT"") == 0) {
        // Create the file
        int file_fd = open(filename, O_WRONLY | O_CREAT, 0644);
        if (file_fd < 0) {
            perror(""open"");
            send(client_socket, ""Error: Could not create file"", strlen(""Error: Could not create file""), 0);
            close(client_socket);
            pthread_exit(NULL);
        }

        // Receive the file contents from the client
        char buffer[BUFFER_SIZE];
        int bytes_received;
        while ((bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0)) > 0) {
            write(file_fd, buffer, bytes_received);
        }
        if (bytes_received < 0) {
            perror(""recv"");
            close(client_socket);
            pthread_exit(NULL);
        }

        // Close the file
        close(file_fd);
    } else {
        // Send an error message to the client
        send(client_socket, ""Error: Invalid command"", strlen(""Error: Invalid command""), 0);
        close(client_socket);
        pthread_exit(NULL);
    }

    // Close the client socket
    close(client_socket);

    // Exit the thread
    pthread_exit(NULL);
}

// Function to handle incoming connections
void handle_incoming_connections() {
    while (1) {
        // Accept a new connection
        int client_socket = accept(server_socket, (struct sockaddr*)&client_address, &client_address_len);
        if (client_socket < 0) {
            perror(""accept"");
            continue;
        }

        // Add the client socket to the list of client sockets
        client_sockets[num_connections] = client_socket;
        num_connections++;

        // Create a new thread to handle the client connection
        pthread_create(&client_threads[num_connections], NULL, handle_client, &client_socket);
    }
}

// Function to handle Ctrl+C signal
void handle_sigint(int signum) {
    // Close the server socket
    close(server_socket);

    // Close all client sockets
    for (int i = 0; i < num_connections; i++) {
        close(client_sockets[i]);
    }

    // Exit the program
    exit(0);
}

int main(int argc, char* argv[]) {
    // Register the Ctrl+C signal handler
    signal(SIGINT, handle_sigint);

    // Create the server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        perror(""socket"");
        exit(1);
    }

    // Set the server address
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(21);
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);

    // Bind the server socket to the address
    if (bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {
        perror(""bind"");
        close(server_socket);
        exit(1);
    }

    // Listen for incoming connections
    if (listen(server_socket, BACKLOG) < 0) {
        perror(""listen"");
        close(server_socket);
        exit(1);
    }

    // Handle incoming connections
    handle_incoming_connections();

    return 0;
}",179,4.75
VULNERABLE,falcon180b-69594.c,yes,17,5,handle_client,"
  file falcon180b-69594.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *) socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *) socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 12345\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full"", 14, 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread;
            pthread_create(&thread, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",69,4.0
VULNERABLE,falcon180b-12936.c,yes,19,5,handle_client,"
  file falcon180b-12936.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char *message = strdup(buffer);
        printf(""Client %d: %s\n"", client_socket, message);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], message, strlen(message), 0);
            }
        }

        free(message);
    }

    close(client_socket);
    printf(""Client %d disconnected.\n"", client_socket);

    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket.\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Error listening on socket.\n"");
        return 1;
    }

    printf(""Server started on port %d.\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 16, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",85,5.0
VULNERABLE,falcon180b-30140.c,yes,22,5,handle_client,"
  file falcon180b-30140.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
char *message = ""Welcome to the server! "";

void *handle_client(void *client_socket) {
    int client_socket_d = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_d, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
char *message = ""Welcome to the server! "";

void *handle_client(void *client_socket) {
    int client_socket_d = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_d, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket_d, buffer);
        send(client_socket_d, message, strlen(message), 0);
    }

    close(client_socket_d);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",83,4.5
VULNERABLE,falcon180b-614.c,yes,33,5,handle_client,"
  file falcon180b-614.c line 33 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"    }
}

// Function to handle client connections
void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    // Get client name
    char name_buffer[10];
    recv(client_sock, name_buffer, sizeof(name_buffer), 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

// Struct to hold client information
typedef struct {
    int sock;
    char name[10];
} client_t;

// Array of clients
client_t clients[MAX_CLIENTS];
int num_clients = 0;

// Function to broadcast message to all clients
void broadcast_message(char *message, int sender_sock) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i].sock!= sender_sock) {
            send(clients[i].sock, message, strlen(message), 0);
        }
    }
}

// Function to handle client connections
void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    // Get client name
    char name_buffer[10];
    recv(client_sock, name_buffer, sizeof(name_buffer), 0);
    strcpy(clients[num_clients].name, name_buffer);

    // Send welcome message to client
    sprintf(buffer, ""Welcome to the chat, %s!\n"", clients[num_clients].name);
    send(client_sock, buffer, strlen(buffer), 0);

    // Notify other clients of new arrival
    sprintf(buffer, ""%s has joined the chat.\n"", clients[num_clients].name);
    broadcast_message(buffer, client_sock);

    while (1) {
        // Receive message from client
        recv(client_sock, buffer, BUFFER_SIZE, 0);

        // Broadcast message to all clients
        broadcast_message(buffer, client_sock);
    }
}

// Main function
int main(int argc, char **argv) {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    // Set server socket options
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_sock, MAX_CLIENTS);

    printf(""Chat server started on port 8080\n"");

    while (1) {
        // Accept client connection
        int client_sock = accept(server_sock, NULL, NULL);

        // Spawn thread to handle client
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_sock);
    }

    close(server_sock);
    return 0;
}",85,2.333
VULNERABLE,falcon180b-6044.c,yes,18,5,handle_client,"
  file falcon180b-6044.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFLEN];

    while (1) {
        memset(buffer, 0, BUFLEN);
        int bytes_received = recv(client_socket, buffer, BUFLEN, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFLEN 512

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFLEN];

    while (1) {
        memset(buffer, 0, BUFLEN);
        int bytes_received = recv(client_socket, buffer, BUFLEN, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 11, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",88,6.0
VULNERABLE,falcon180b-18157.c,yes,17,5,handle_client,"
  file falcon180b-18157.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = num_clients;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-52906.c,yes,20,5,handle_client,"
  file falcon180b-52906.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full."", strlen(""Server is full.""), 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-9355.c,yes,22,5,handle_client,"
  file falcon180b-9355.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;
    socklen_t client_size;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""127.0.0.1"", &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 5);

    while (1) {
        client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (num_clients == MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 46, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;

        pthread_create(&threads[num_clients - 1], NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,codellama_13b-11603.c,yes,21,23,count_sentences,"
  file string.c line 78 column 3 function strlen
","
  c:@F@strlen at file codellama_13b-11603.c line 21 column 23 function count_sentences
  c:@F@count_sentences at file codellama_13b-11603.c line 44 column 15 function summarize
  c:@F@summarize at file codellama_13b-11603.c line 60 column 19 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `sentence'",dereference failure: accessed expired variable pointer,"}

// Function to count the number of sentences in a given string
int count_sentences(char* str) {
  int count = 0;
  for (int i = 0; i < strlen(str); i++) {
    if (str[i] == '.') {
      count++;
    }
  }
  return count;","//Code Llama-13B DATASET v1.0 Category: Text Summarizer ; Style: protected
// C Text Summarizer Example Program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SENTENCES 100
#define MAX_LENGTH 1000

// Function to get a sentence from the user
char* get_sentence() {
  char sentence[MAX_LENGTH];
  fgets(sentence, MAX_LENGTH, stdin);
  return sentence;
}

// Function to count the number of sentences in a given string
int count_sentences(char* str) {
  int count = 0;
  for (int i = 0; i < strlen(str); i++) {
    if (str[i] == '.') {
      count++;
    }
  }
  return count;
}

// Function to get the most important sentences from a given string
char* get_important_sentences(char* str) {
  int count = count_sentences(str);
  char* sentences[MAX_SENTENCES];
  for (int i = 0; i < count; i++) {
    sentences[i] = strtok(str, ""."");
    str = strtok(NULL, ""."");
  }
  return sentences;
}

// Function to summarize a given string
char* summarize(char* str) {
  char* summary = malloc(MAX_LENGTH);
  strcpy(summary, """");
  int count = count_sentences(str);
  char* sentences[MAX_SENTENCES];
  for (int i = 0; i < count; i++) {
    sentences[i] = strtok(str, ""."");
    str = strtok(NULL, ""."");
  }
  for (int i = 0; i < count; i++) {
    strcat(summary, sentences[i]);
    strcat(summary, ""."");
  }
  return summary;
}

// Main function
int main() {
  char* str = get_sentence();
  char* summary = summarize(str);
  printf(""Summary: %s\n"", summary);
  return 0;
}",63,2.0
VULNERABLE,falcon180b-71134.c,yes,24,5,light_thread,"
  file falcon180b-71134.c line 24 column 5 function light_thread
","
  c:@F@light_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int sensor_values[NUM_SENSORS] = {0};
pthread_t light_threads[NUM_LIGHTS];
pthread_t sensor_threads[NUM_SENSORS];

void* light_thread(void* arg) {
    int light_number = *((int*) arg);
    while (1) {
        if (light_values[light_number] < LIGHT_MAX) {
            light_values[light_number] += LIGHT_INCREMENT;
        } else {
            light_values[light_number] = LIGHT_MAX;","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <pthread.h>

#define NUM_LIGHTS 4
#define NUM_SENSORS 2
#define SENSOR_THRESHOLD 100
#define LIGHT_MIN 0
#define LIGHT_MAX 100
#define LIGHT_INCREMENT 5
#define LIGHT_DECREMENT 2
#define LIGHT_DELAY 1000
#define SENSOR_DELAY 500

int light_values[NUM_LIGHTS] = {0};
int sensor_values[NUM_SENSORS] = {0};
pthread_t light_threads[NUM_LIGHTS];
pthread_t sensor_threads[NUM_SENSORS];

void* light_thread(void* arg) {
    int light_number = *((int*) arg);
    while (1) {
        if (light_values[light_number] < LIGHT_MAX) {
            light_values[light_number] += LIGHT_INCREMENT;
        } else {
            light_values[light_number] = LIGHT_MAX;
        }
        usleep(LIGHT_DELAY);
    }
    return NULL;
}

void* sensor_thread(void* arg) {
    int sensor_number = *((int*) arg);
    while (1) {
        sensor_values[sensor_number] = rand() % SENSOR_THRESHOLD;
        usleep(SENSOR_DELAY);
    }
    return NULL;
}

int main() {
    srand(time(0));
    for (int i = 0; i < NUM_LIGHTS; i++) {
        pthread_create(&light_threads[i], NULL, light_thread, &i);
    }
    for (int i = 0; i < NUM_SENSORS; i++) {
        pthread_create(&sensor_threads[i], NULL, sensor_thread, &i);
    }
    while (1) {
        for (int i = 0; i < NUM_LIGHTS; i++) {
            printf(""Light %d: %d\n"", i+1, light_values[i]);
        }
        printf(""\n"");
        for (int i = 0; i < NUM_SENSORS; i++) {
            printf(""Sensor %d: %d\n"", i+1, sensor_values[i]);
        }
        printf(""\n"");
        fflush(stdout);
        usleep(100000);
    }
    return 0;
}",66,3.667
VULNERABLE,falcon180b-571.c,yes,20,5,handle_client,"
  file falcon180b-571.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[MAX_MESSAGE_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, MAX_MESSAGE_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_MESSAGE_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[MAX_MESSAGE_SIZE];

    while (1) {
        memset(buffer, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, MAX_MESSAGE_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket_copy);
            pthread_exit(NULL);
        }

        printf(""Client %d sent message: %s\n"", client_socket_copy, buffer);

        // Send message to all connected clients
        for (int i = 0; i < client_count; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        printf(""Client connected: %d\n"", client_socket);

        if (client_count >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[client_count] = client_socket;
        client_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",94,6.0
VULNERABLE,falcon180b-59779.c,yes,53,5,runner,"
  file falcon180b-59779.c line 53 column 5 function runner
","
  c:@F@runner at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `col'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *runner(void *param) {
    int col = *(int *)param;
    int row = 0;

    while (row < 9) {
        if (grid[row][col] == 1) {
            pthread_mutex_lock(&mutex);","//Falcon-180B DATASET v1.0 Category: Pathfinding algorithms ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define MAX_ROW 10
#define MAX_COL 10

int grid[MAX_ROW][MAX_COL];
int start_row, start_col, end_row, end_col, num_threads;
pthread_mutex_t mutex;

void *runner(void *param);

int main() {
    int i, j;

    for (i = 0; i < MAX_ROW; i++) {
        for (j = 0; j < MAX_COL; j++) {
            grid[i][j] = 1;
        }
    }

    grid[0][0] = 0;
    grid[9][9] = 0;

    start_row = 0;
    start_col = 0;
    end_row = 9;
    end_col = 9;

    num_threads = 4;

    pthread_mutex_init(&mutex, NULL);

    pthread_t threads[num_threads];

    for (i = 0; i < num_threads; i++) {
        int row = start_row + i * (end_row - start_row) / num_threads;
        int col = start_col + i * (end_col - start_col) / num_threads;

        pthread_create(&threads[i], NULL, runner, (void *)&col);
    }

    for (i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}

void *runner(void *param) {
    int col = *(int *)param;
    int row = 0;

    while (row < 9) {
        if (grid[row][col] == 1) {
            pthread_mutex_lock(&mutex);
            grid[row][col] = 0;
            pthread_mutex_unlock(&mutex);
            row++;
        } else {
            row++;
        }
    }

    return NULL;
}",68,4.0
VULNERABLE,gemini_pro-38084.c,yes,29,5,thread_func,"
  file gemini_pro-38084.c line 29 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"// Mutex to protect the shared variable
pthread_mutex_t mutex;

// Thread function
void *thread_func(void *arg) {
    int thread_id = *(int *)arg;

    // Acquire the mutex lock
    pthread_mutex_lock(&mutex);

    // Get the question and answer for this thread","//GEMINI-pro DATASET v1.0 Category: Online Examination System ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Structure to store the question and answer
typedef struct {
    char question[100];
    char answer[100];
} Question;

// Array of questions
Question questions[] = {
    {""What is the capital of France?"", ""Paris""},
    {""What is the largest ocean in the world?"", ""Pacific Ocean""},
    {""What is the name of the tallest mountain in the world?"", ""Mount Everest""},
    {""What is the chemical symbol for gold?"", ""Au""},
    {""Who is the author of the Harry Potter series?"", ""J.K. Rowling""}
};

// Number of questions
int num_questions = sizeof(questions) / sizeof(Question);

// Mutex to protect the shared variable
pthread_mutex_t mutex;

// Thread function
void *thread_func(void *arg) {
    int thread_id = *(int *)arg;

    // Acquire the mutex lock
    pthread_mutex_lock(&mutex);

    // Get the question and answer for this thread
    Question question = questions[thread_id];

    // Release the mutex lock
    pthread_mutex_unlock(&mutex);

    // Print the question and answer
    printf(""Thread %d: %s\n"", thread_id, question.question);
    printf(""Thread %d: %s\n"", thread_id, question.answer);

    return NULL;
}

int main() {
    // Initialize the mutex
    pthread_mutex_init(&mutex, NULL);

    // Create an array of threads
    pthread_t threads[num_questions];

    // Create the threads
    for (int i = 0; i < num_questions; i++) {
        pthread_create(&threads[i], NULL, thread_func, &i);
    }

    // Join the threads
    for (int i = 0; i < num_questions; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destroy the mutex
    pthread_mutex_destroy(&mutex);

    return 0;
}",68,2.0
VULNERABLE,gemma7b-41553.c,yes,41,13,main,"
  file gemma7b-41553.c line 41 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `summary_choice'",dereference failure: accessed expired variable pointer,"        case 'b':
            system(""clear"");
            system(""figlet -f pixel -c 'The Lord of the Flies'"");
            printf(""You have chosen The Lord of the Flies by William Golding.\n\n"");
            printf(""Would you like to read the book summary? (Y/N): "");
            scanf("" %c"", &summary_choice);

            if (summary_choice == 'y')
            {
                system(""clear"");
                system(""figlet -f pixel -c 'Book Summary'"");","//Gemma-7B DATASET v1.0 Category: Ebook reader ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main()
{
    system(""clear"");
    system(""figlet -f pixel -c 'BOOK READ'"");
    system(""toilet -f"");

    printf(""Welcome to the Book Reading Experience, my dear.\n\n"");
    printf(""Please select a book from the list below:\n"");

    char book_choice;
    scanf("" %c"", &book_choice);

    switch (book_choice)
    {
        case 'a':
            system(""clear"");
            system(""figlet -f pixel -c 'The Hobbit'"");
            printf(""You have chosen The Hobbit by J.R.R. Tolkien.\n\n"");
            printf(""Would you like to read the book summary? (Y/N): "");
            char summary_choice;
            scanf("" %c"", &summary_choice);

            if (summary_choice == 'y')
            {
                system(""clear"");
                system(""figlet -f pixel -c 'Book Summary'"");
                printf(""The Hobbit is a fantasy novel... blah blah blah.\n\n"");
            }
            break;

        case 'b':
            system(""clear"");
            system(""figlet -f pixel -c 'The Lord of the Flies'"");
            printf(""You have chosen The Lord of the Flies by William Golding.\n\n"");
            printf(""Would you like to read the book summary? (Y/N): "");
            scanf("" %c"", &summary_choice);

            if (summary_choice == 'y')
            {
                system(""clear"");
                system(""figlet -f pixel -c 'Book Summary'"");
                printf(""The Lord of the Flies is a coming-of-age novel... blah blah blah.\n\n"");
            }
            break;

        default:
            printf(""Invalid book selection.\n"");
    }

    system(""pause"");
}",56,5.0
VULNERABLE,falcon180b-51190.c,yes,18,5,handle_client,"
  file falcon180b-51190.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *)socket;
    char data[MAX_DATA_SIZE];
    int bytes_received;

    while ((bytes_received = recv(client_socket, data, MAX_DATA_SIZE, 0)) > 0) {
        printf(""Client %d sent data: %s\n"", client_socket, data);","//Falcon-180B DATASET v1.0 Category: Database Indexing System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define MAX_DATA_SIZE 100

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket) {
    int client_socket = *(int *)socket;
    char data[MAX_DATA_SIZE];
    int bytes_received;

    while ((bytes_received = recv(client_socket, data, MAX_DATA_SIZE, 0)) > 0) {
        printf(""Client %d sent data: %s\n"", client_socket, data);
    }

    close(client_socket);
}

int main() {
    int server_socket;
    int opt = 1;
    struct sockaddr_in server_addr;

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket;
        socklen_t client_size;

        if ((client_socket = accept(server_socket, (struct sockaddr *)&server_addr, &client_size)) < 0) {
            printf(""Error accepting client connection\n"");
            exit(1);
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket) < 0) {
            printf(""Error creating thread\n"");
            exit(1);
        }
    }

    return 0;
}",83,5.0
VULNERABLE,falcon180b-71569.c,yes,20,5,handle_client,"
  file falcon180b-71569.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }
        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        clients[num_clients++] = client_socket;
    }

    return 0;
}",77,5.5
VULNERABLE,gemini_pro-29056.c,yes,18,3,handle_client,"
  file gemini_pro-29056.c line 18 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
  int client_socket = *(int *)arg;
  char buffer[1024];
  while (1) {
    memset(buffer, 0, sizeof(buffer));
    int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
    if (bytes_received <= 0) {","//GEMINI-pro DATASET v1.0 Category: Checksum Calculator ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 5000
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
  int client_socket = *(int *)arg;
  char buffer[1024];
  while (1) {
    memset(buffer, 0, sizeof(buffer));
    int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
    if (bytes_received <= 0) {
      printf(""Client disconnected\n"");
      close(client_socket);
      break;
    }
    int checksum = 0;
    for (int i = 0; i < bytes_received; i++) {
      checksum += buffer[i];
    }
    printf(""Checksum: %d\n"", checksum);
    send(client_socket, &checksum, sizeof(checksum), 0);
  }
  return NULL;
}

int main() {
  int server_socket = socket(AF_INET, SOCK_STREAM, 0);
  if (server_socket < 0) {
    perror(""socket"");
    exit(1);
  }
  struct sockaddr_in server_address;
  memset(&server_address, 0, sizeof(server_address));
  server_address.sin_family = AF_INET;
  server_address.sin_port = htons(PORT);
  server_address.sin_addr.s_addr = INADDR_ANY;
  if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0) {
    perror(""bind"");
    exit(1);
  }
  if (listen(server_socket, MAX_CLIENTS) < 0) {
    perror(""listen"");
    exit(1);
  }
  while (1) {
    int client_socket = accept(server_socket, NULL, NULL);
    if (client_socket < 0) {
      perror(""accept"");
      continue;
    }
    if (client_count >= MAX_CLIENTS) {
      close(client_socket);
      continue;
    }
    client_sockets[client_count] = client_socket;
    client_count++;
    pthread_t thread;
    pthread_create(&thread, NULL, handle_client, &client_socket);
  }
  return 0;
}",73,5.5
VULNERABLE,falcon180b-28464.c,yes,17,5,thread_func,"
  file falcon180b-28464.c line 17 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `ids'",dereference failure: accessed expired variable pointer,"// Number of threads
#define NUM_THREADS 5

// Function to be executed by each thread
void* thread_func(void* arg) {
    int id = *(int*) arg;

    printf(""Thread %d started\n"", id);

    // Lock the mutex before entering the critical section
    pthread_mutex_lock(&mutex);","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Mutex for critical section
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Condition variable for synchronization
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Number of threads
#define NUM_THREADS 5

// Function to be executed by each thread
void* thread_func(void* arg) {
    int id = *(int*) arg;

    printf(""Thread %d started\n"", id);

    // Lock the mutex before entering the critical section
    pthread_mutex_lock(&mutex);

    // Notify the main thread that this thread has entered the critical section
    pthread_cond_signal(&cond);

    // Sleep for a random amount of time
    sleep(rand() % 3);

    // Unlock the mutex after exiting the critical section
    pthread_mutex_unlock(&mutex);

    printf(""Thread %d exited\n"", id);

    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int ids[NUM_THREADS] = {1, 2, 3, 4, 5};

    // Create the threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_func, &ids[i]);
    }

    // Wait for all threads to enter the critical section
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_cond_wait(&cond, &mutex);
        printf(""All threads have entered the critical section\n"");
    }

    // Unlock the mutex and exit the program
    pthread_mutex_unlock(&mutex);
    return 0;
}",56,2.0
VULNERABLE,falcon180b-3709.c,yes,17,5,handle_client,"
  file falcon180b-3709.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-33833.c,yes,19,5,handle_client,"
  file falcon180b-33833.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    char response[MAX_REQUEST_SIZE];
    int bytes_received = 0;
    int response_code = 200;
","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 4096
#define HTTP_PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    char response[MAX_REQUEST_SIZE];
    int bytes_received = 0;
    int response_code = 200;

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        response[0] = '\0';
        strcat(response, ""HTTP/1.1 "");
        sprintf(response + strlen(response), ""%d "", response_code);
        strcat(response, ""OK"");
        strcat(response, ""\r\n"");
        strcat(response, ""Content-Type: text/html\r\n"");
        strcat(response, ""Connection: close\r\n"");
        strcat(response, ""\r\n"");
        strcat(response, ""<html><body><h1>Hello, World!</h1></body></html>"");

        send(client_socket, response, strlen(response), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(HTTP_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", HTTP_PORT);

    while (1) {
        socklen_t addr_size = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &addr_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",99,5.0
VULNERABLE,gpt35-33540.c,yes,13,3,handle_client,"
  file gpt35-33540.c line 13 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"#include <arpa/inet.h>

#define PORT 8080

void *handle_client(void *sock_fd) {
  int client_fd = *(int *)sock_fd;
  printf(""Client %d connected\n"", client_fd);

  char buffer[1024] = {0};
  while(1) {
    int valread = read(client_fd, buffer, 1024);","//FormAI DATASET v1.0 Category: Client Server Application ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT 8080

void *handle_client(void *sock_fd) {
  int client_fd = *(int *)sock_fd;
  printf(""Client %d connected\n"", client_fd);

  char buffer[1024] = {0};
  while(1) {
    int valread = read(client_fd, buffer, 1024);
    if(valread == 0) {
      printf(""Client %d disconnected\n"", client_fd);
      close(client_fd);
      break;
    }
    printf(""Received message from client %d: %s"", client_fd, buffer);
    send(client_fd, buffer, strlen(buffer), 0);
    memset(buffer, 0, sizeof(buffer));
  }
}

int main() {
  int server_fd;
  struct sockaddr_in address;
  int opt = 1;
  int addrlen = sizeof(address);

  if((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror(""socket failed"");
    exit(EXIT_FAILURE);
  }
  if(setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
    perror(""setsockopt failed"");
    exit(EXIT_FAILURE);
  }
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(PORT);
  if(bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
    perror(""bind failed"");
    exit(EXIT_FAILURE);
  }
  if(listen(server_fd, 5) < 0) {
    perror(""listen failed"");
    exit(EXIT_FAILURE);
  }

  printf(""Server is up and running!\n"");

  while(1) {
    int client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen);
    if(client_fd < 0) {
      perror(""accept failed"");
      exit(EXIT_FAILURE);
    }
    pthread_t thread_id;
    if(pthread_create(&thread_id, NULL, handle_client, (void *)&client_fd) < 0) {
      perror(""pthread_create failed"");
      exit(EXIT_FAILURE);
    }
    pthread_detach(thread_id);
  }

  return 0;
}",73,5.5
VULNERABLE,gemini_pro-19907.c,yes,22,5,handle_client,"
  file gemini_pro-19907.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
sem_t semaphore;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    while (1) {
        char buffer[MAX_MESSAGE_LENGTH];
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_LENGTH, 0);
        if (bytes_received <= 0) {","//GEMINI-pro DATASET v1.0 Category: Email Client ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_MESSAGE_LENGTH 1024
#define MAX_CONNECTIONS 10
#define MAX_THREADS 10

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
sem_t semaphore;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    while (1) {
        char buffer[MAX_MESSAGE_LENGTH];
        int bytes_received = recv(client_socket, buffer, MAX_MESSAGE_LENGTH, 0);
        if (bytes_received <= 0) {
            sem_wait(&semaphore);
            pthread_mutex_lock(&mutex);
            printf(""Client disconnected\n"");
            close(client_socket);
            pthread_mutex_unlock(&mutex);
            sem_post(&semaphore);
            break;
        }

        pthread_mutex_lock(&mutex);
        printf(""Received message: %s\n"", buffer);
        pthread_mutex_unlock(&mutex);

        char response[MAX_MESSAGE_LENGTH];
        snprintf(response, MAX_MESSAGE_LENGTH, ""Hello, client!"");
        int bytes_sent = send(client_socket, response, strlen(response), 0);
        if (bytes_sent < 0) {
            sem_wait(&semaphore);
            pthread_mutex_lock(&mutex);
            printf(""Failed to send message\n"");
            pthread_mutex_unlock(&mutex);
            sem_post(&semaphore);
            break;
        }
    }

    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        return EXIT_FAILURE;
    }

    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(12345);

    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror(""bind"");
        return EXIT_FAILURE;
    }

    if (listen(server_socket, MAX_CONNECTIONS) == -1) {
        perror(""listen"");
        return EXIT_FAILURE;
    }

    sem_init(&semaphore, 0, MAX_THREADS);

    pthread_t threads[MAX_THREADS];
    int num_threads = 0;
    while (1) {
        struct sockaddr_in client_address;
        socklen_t client_address_length = sizeof(client_address);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_length);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        if (num_threads < MAX_THREADS) {
            pthread_create(&threads[num_threads++], NULL, handle_client, &client_socket);
        } else {
            char response[MAX_MESSAGE_LENGTH];
            snprintf(response, MAX_MESSAGE_LENGTH, ""Server is full, try again later"");
            int bytes_sent = send(client_socket, response, strlen(response), 0);
            if (bytes_sent < 0) {
                perror(""send"");
            }
            close(client_socket);
        }
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    close(server_socket);
    return EXIT_SUCCESS;
}",112,6.5
VULNERABLE,falcon180b-20450.c,yes,24,5,handle_client,"
  file falcon180b-20450.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_client'",dereference failure: accessed expired variable pointer,"
client_t clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Topology Mapper ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

typedef struct {
    int sock;
    struct sockaddr_in addr;
    char name[20];
} client_t;

client_t clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""%s: %s\n"", clients[num_clients].name, buffer);
    }

    close(sock);
    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_sock, 10) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        client_t new_client;
        socklen_t addr_size = sizeof(new_client.addr);
        new_client.sock = accept(server_sock, (struct sockaddr *) &new_client.addr, &addr_size);

        if (new_client.sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        getpeername(new_client.sock, (struct sockaddr *) &new_client.addr, &addr_size);
        inet_ntop(AF_INET, &new_client.addr.sin_addr, new_client.name, 20);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(new_client.sock);
            continue;
        }

        clients[num_clients++] = new_client;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &new_client.sock);
    }

    return 0;
}",94,5.0
VULNERABLE,falcon180b-9835.c,yes,20,3,handle_client,"
  file falcon180b-9835.c line 20 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
  int client_socket = *(int *) arg;
  char buffer[BUFFER_SIZE];

  while (1) {
    memset(buffer, 0, BUFFER_SIZE);
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
  int client_socket = *(int *) arg;
  char buffer[BUFFER_SIZE];

  while (1) {
    memset(buffer, 0, BUFFER_SIZE);
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

    if (bytes_received <= 0) {
      break;
    }

    printf(""Client %d sent: %s\n"", client_socket, buffer);

    for (int i = 0; i < num_clients; i++) {
      if (i!= client_socket) {
        send(clients[i], buffer, bytes_received, 0);
      }
    }
  }

  close(client_socket);
  return NULL;
}

int main() {
  int server_socket = socket(AF_INET, SOCK_STREAM, 0);

  if (server_socket == -1) {
    printf(""Error creating socket\n"");
    exit(1);
  }

  struct sockaddr_in server_addr;
  memset(&server_addr, 0, sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(12345);
  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
    printf(""Error binding socket\n"");
    exit(1);
  }

  if (listen(server_socket, MAX_CLIENTS) == -1) {
    printf(""Error listening on socket\n"");
    exit(1);
  }

  printf(""Server listening on port 12345\n"");

  while (1) {
    int client_socket = accept(server_socket, NULL, NULL);

    if (client_socket == -1) {
      printf(""Error accepting connection\n"");
      continue;
    }

    printf(""Client %d connected\n"", client_socket);

    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

    clients[num_clients++] = client_socket;
  }

  return 0;
}",87,5.5
VULNERABLE,falcon180b-42794.c,yes,21,5,handle_client,"
  file falcon180b-42794.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <signal.h>

#define SERVER_PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.5
VULNERABLE,falcon180b-44396.c,yes,21,5,handle_client,"
  file falcon180b-44396.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(sock);
            pthread_exit(0);
        }
        printf(""Client %d sent: %s\n"", sock, buffer);
        send(sock, buffer, strlen(buffer), 0);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int new_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(new_socket, ""Server is full.\n"", 16, 0);
            close(new_socket);
        } else {
            client_sockets[num_clients] = new_socket;
            pthread_create(&threads[num_clients], NULL, handle_client, (void *)&new_socket);
            num_clients++;
        }
    }

    return 0;
}",64,3.0
VULNERABLE,falcon180b-14831.c,yes,23,5,handle_client,"
  file falcon180b-14831.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_clients_count;
pthread_t g_threads[MAX_CLIENTS];

void* handle_client(void* arg)
{
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    while(1)
    {
        memset(buffer, 0, BUFFER_SIZE);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_server_socket;
int g_clients_socket[MAX_CLIENTS];
int g_clients_count;
pthread_t g_threads[MAX_CLIENTS];

void* handle_client(void* arg)
{
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    while(1)
    {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0)
        {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for(int i = 0; i < g_clients_count; i++)
        {
            if(g_clients_socket[i]!= client_socket)
            {
                send(g_clients_socket[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main()
{
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while(1)
    {
        int client_socket = accept(server_socket, NULL, NULL);

        if(g_clients_count >= MAX_CLIENTS)
        {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        g_clients_socket[g_clients_count] = client_socket;
        g_clients_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void*)&client_socket);
    }

    return 0;
}",85,4.0
VULNERABLE,gpt35-71004.c,yes,158,17,main,"
  file gpt35-71004.c line 158 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `id'",dereference failure: accessed expired variable pointer,"                scanf(""%d"", &id);
                find_record(filename, id);
                break;
            case 4:
                printf(""\nEnter the ID of the record to delete: "");
                scanf(""%d"", &id);
                delete_record(filename, id);
                break;
            case 5:
                printf(""Exiting program.\n"");
                exit(0);","//FormAI DATASET v1.0 Category: Database simulation ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NAME_LENGTH 50
#define MAX_INFO_LENGTH 100

typedef struct {
    int id;
    char name[MAX_NAME_LENGTH];
    char info[MAX_INFO_LENGTH];
} Record;

int get_record_size() {
    // Returns the size of the database record.
    return sizeof(int) + MAX_NAME_LENGTH + MAX_INFO_LENGTH;
}

void add_record(char* filename) {
    FILE* file = fopen(filename, ""ab"");
    if (file == NULL) {
        printf(""Error opening file.\n"");
        return;
    }

    Record record;
    // Prompt user to enter record information
    printf(""Enter the following record information:\n"");
    printf(""ID: "");
    scanf(""%d"", &record.id);
    printf(""Name: "");
    scanf(""%s"", record.name);
    printf(""Info: "");
    getchar();
    fgets(record.info, MAX_INFO_LENGTH, stdin);

    // Write record to file
    fwrite(&record.id, sizeof(int), 1, file);
    fwrite(record.name, sizeof(char), MAX_NAME_LENGTH, file);
    fwrite(record.info, sizeof(char), MAX_INFO_LENGTH, file);

    fclose(file);
    printf(""Record added successfully.\n"");
}

void display_record(Record record) {
    printf(""ID: %d\n"", record.id);
    printf(""Name: %s\n"", record.name);
    printf(""Info: %s"", record.info);
}

void display_all_records(char* filename) {
    FILE* file = fopen(filename, ""rb"");
    if (file == NULL) {
        printf(""Error opening file.\n"");
        return;
    }

    Record record;
    while (fread(&record.id, sizeof(int), 1, file) != 0) {
        fread(record.name, sizeof(char), MAX_NAME_LENGTH, file);
        fread(record.info, sizeof(char), MAX_INFO_LENGTH, file);
        display_record(record);
        printf(""\n"");
    }

    fclose(file);
}

void find_record(char* filename, int id) {
    FILE* file = fopen(filename, ""rb"");
    if (file == NULL) {
        printf(""Error opening file.\n"");
        return;
    }

    Record record;
    while (fread(&record.id, sizeof(int), 1, file) != 0) {
        fread(record.name, sizeof(char), MAX_NAME_LENGTH, file);
        fread(record.info, sizeof(char), MAX_INFO_LENGTH, file);
        if (record.id == id) {
            display_record(record);
            printf(""\n"");
            fclose(file);
            return;
        }
    }

    fclose(file);
    printf(""Record with ID %d not found.\n"", id);
}

void delete_record(char* filename, int id) {
    // Create a temporary file to store all the valid records
    char temp_filename[] = ""temp.db"";
    FILE* file = fopen(filename, ""rb"");
    if (file == NULL) {
        printf(""Error opening file.\n"");
        return;
    }
    FILE* temp_file = fopen(temp_filename, ""wb"");
    if (temp_file == NULL) {
        printf(""Error creating temporary file.\n"");
        fclose(file);
        return;
    }

    Record record;
    while (fread(&record.id, sizeof(int), 1, file) != 0) {
        fread(record.name, sizeof(char), MAX_NAME_LENGTH, file);
        fread(record.info, sizeof(char), MAX_INFO_LENGTH, file);
        if (record.id != id) {
            fwrite(&record.id, sizeof(int), 1, temp_file);
            fwrite(record.name, sizeof(char), MAX_NAME_LENGTH, temp_file);
            fwrite(record.info, sizeof(char), MAX_INFO_LENGTH, temp_file);
        }
    }

    fclose(file);
    fclose(temp_file);
    remove(filename);
    rename(temp_filename, filename);
    printf(""Record with ID %d deleted successfully.\n"", id);
}

int main() {
    char filename[] = ""database.db"";
    int record_size = get_record_size();

    while (1) {
        // Display options to the user
        printf(""\nSelect an option:\n"");
        printf(""1. Add a record\n"");
        printf(""2. Display all records\n"");
        printf(""3. Find a record\n"");
        printf(""4. Delete a record\n"");
        printf(""5. Quit\n"");
        int option;
        scanf(""%d"", &option);

        switch (option) {
            case 1:
                add_record(filename);
                break;
            case 2:
                printf(""\nAll Records:\n"");
                display_all_records(filename);
                break;
            case 3:
                printf(""\nEnter the ID of the record to find: "");
                int id;
                scanf(""%d"", &id);
                find_record(filename, id);
                break;
            case 4:
                printf(""\nEnter the ID of the record to delete: "");
                scanf(""%d"", &id);
                delete_record(filename, id);
                break;
            case 5:
                printf(""Exiting program.\n"");
                exit(0);
                break;
            default:
                printf(""Invalid option.\n"");
        }
    }

    return 0;
}",171,3.286
VULNERABLE,gpt35-66168.c,yes,18,5,client_handler,"
  file gpt35-66168.c line 18 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;

void *client_handler(void *socket_desc) {
    // Get client socket descriptor
    int client_socket = *(int*)socket_desc;
    char client_message[BUFFER_SIZE];
    int read_size;

    // Send message to client to confirm connection
    char *connection_message = ""Connected! Type 'exit' to quit.\n"";","//FormAI DATASET v1.0 Category: Chat server ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 50
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *client_handler(void *socket_desc) {
    // Get client socket descriptor
    int client_socket = *(int*)socket_desc;
    char client_message[BUFFER_SIZE];
    int read_size;

    // Send message to client to confirm connection
    char *connection_message = ""Connected! Type 'exit' to quit.\n"";
    send(client_socket, connection_message, strlen(connection_message), 0);

    // Receive message from client
    while ((read_size = recv(client_socket, client_message, BUFFER_SIZE, 0)) > 0) {
        // Check if client wants to exit
        if (strcmp(client_message, ""exit\n"") == 0) {
            // Remove client from list of active clients
            for (int i = 0; i < num_clients; i++) {
                if (clients[i] == client_socket) {
                    for (int j = i; j < num_clients - 1; j++) {
                        clients[j] = clients[j + 1];
                    }
                    num_clients--;
                    break;
                }
            }
            close(client_socket);
            return NULL;
        }
        // Broadcast message to all clients
        for (int i = 0; i < num_clients; i++) {
            if (clients[i] != client_socket) {
                send(clients[i], client_message, strlen(client_message), 0);
            }
        }
        memset(client_message, 0, BUFFER_SIZE);
    }

    // If client disconnected, remove from list of active clients and exit thread
    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == client_socket) {
            for (int j = i; j < num_clients - 1; j++) {
                clients[j] = clients[j + 1];
            }
            num_clients--;
            break;
        }
    }
    close(client_socket);
    return NULL;
}

int main(int argc, char *argv[]) {
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    pthread_t thread_id;

    // Create socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Failed to create socket\n"");
        exit(EXIT_FAILURE);
    }

    // Set server address
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    // Bind socket to server address
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Failed to bind socket to server address\n"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    listen(server_socket, 3);

    // Accept incoming connections and create new thread to handle each one
    while ((client_socket = accept(server_socket, (struct sockaddr *)&client_addr, (socklen_t*)&client_addr)) > 0) {
        // Add client socket to list of active clients
        clients[num_clients] = client_socket;
        num_clients++;

        // Create new thread to handle client communication
        if (pthread_create(&thread_id, NULL, client_handler, (void*)&client_socket) < 0) {
            printf(""Failed to create thread for client\n"");
            exit(EXIT_FAILURE);
        }
        printf(""New client connected\n"");
    }

    // Close server socket
    close(server_socket);

    return 0;
}",110,8.0
VULNERABLE,falcon180b-63856.c,yes,22,5,handle_client,"
  file falcon180b-63856.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int client_count = 0;
pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define SERVER_PORT 8080

int server_socket;
struct sockaddr_in server_addr;
int client_sockets[MAX_CLIENTS];
int client_count = 0;
pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < client_count; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    pthread_exit(0);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_count >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 15, 0);
            close(client_socket);
            continue;
        }
        client_sockets[client_count++] = client_socket;
        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",65,4.0
VULNERABLE,codellama_13b-3263.c,yes,58,3,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file codellama_13b-3263.c line 58 column 3 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `hex'",dereference failure: accessed expired variable pointer,"  printf(""Decimal value: %d\n"", dec);

  // Convert decimal to hexadecimal
  printf(""Enter a decimal number: "");
  scanf(""%d"", &dec);
  strcpy(hex, dec_to_hex(dec));
  printf(""Hexadecimal value: %s\n"", hex);

  return 0;
}","//Code Llama-13B DATASET v1.0 Category: Hexadecimal Converter ; Style: accurate
// Hexadecimal Converter
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to convert hexadecimal to decimal
int hex_to_dec(char *hex) {
  int len = strlen(hex);
  int dec = 0;
  int i;

  for (i = 0; i < len; i++) {
    if (hex[i] >= '0' && hex[i] <= '9') {
      dec += (hex[i] - '0') * pow(16, len - i - 1);
    } else if (hex[i] >= 'A' && hex[i] <= 'F') {
      dec += (hex[i] - 'A' + 10) * pow(16, len - i - 1);
    } else if (hex[i] >= 'a' && hex[i] <= 'f') {
      dec += (hex[i] - 'a' + 10) * pow(16, len - i - 1);
    }
  }

  return dec;
}

// Function to convert decimal to hexadecimal
char *dec_to_hex(int dec) {
  int i;
  char hex[10];
  int len = 0;

  while (dec > 0) {
    if (dec % 16 <= 9) {
      hex[len++] = dec % 16 + '0';
    } else {
      hex[len++] = (dec % 16 - 10) + 'A';
    }
    dec /= 16;
  }

  hex[len] = '\0';
  return hex;
}

int main() {
  int dec;
  char hex[10];

  // Convert hexadecimal to decimal
  printf(""Enter a hexadecimal number: "");
  scanf(""%s"", hex);
  dec = hex_to_dec(hex);
  printf(""Decimal value: %d\n"", dec);

  // Convert decimal to hexadecimal
  printf(""Enter a decimal number: "");
  scanf(""%d"", &dec);
  strcpy(hex, dec_to_hex(dec));
  printf(""Hexadecimal value: %s\n"", hex);

  return 0;
}",62,4.0
VULNERABLE,gemini_pro-1167.c,yes,31,13,handle_client,"
  file gemini_pro-1167.c line 31 column 13 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client'",dereference failure: accessed expired variable pointer,"void *handle_client(void *arg) {
    client_t *client = (client_t *)arg;
    char buf[1024];

    // Read data from client
    int n = read(client->fd, buf, sizeof(buf));
    if (n <= 0) {
        perror(""read"");
        close(client->fd);
        pthread_exit(NULL);
    }","//GEMINI-pro DATASET v1.0 Category: Smart home automation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080

// Structure to store client information
typedef struct {
    int fd;
    struct sockaddr_in addr;
} client_t;

// List of connected clients
client_t clients[100];
int num_clients = 0;

// Thread function to handle client requests
void *handle_client(void *arg) {
    client_t *client = (client_t *)arg;
    char buf[1024];

    // Read data from client
    int n = read(client->fd, buf, sizeof(buf));
    if (n <= 0) {
        perror(""read"");
        close(client->fd);
        pthread_exit(NULL);
    }

    // Send data back to client
    n = write(client->fd, buf, n);
    if (n <= 0) {
        perror(""write"");
        close(client->fd);
        pthread_exit(NULL);
    }

    // Close client connection
    close(client->fd);
    pthread_exit(NULL);
}

int main() {
    // Create server socket
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror(""socket"");
        exit(1);
    }

    // Set server address
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    // Bind server socket to address
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(1);
    }

    // Listen for client connections
    if (listen(server_fd, 100) == -1) {
        perror(""listen"");
        exit(1);
    }

    // Main loop
    while (1) {
        // Accept client connection
        client_t client;
        socklen_t addrlen = sizeof(client.addr);
        client.fd = accept(server_fd, (struct sockaddr *)&client.addr, &addrlen);
        if (client.fd == -1) {
            perror(""accept"");
            continue;
        }

        // Add client to list of connected clients
        clients[num_clients++] = client;

        // Create thread to handle client requests
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, &client) != 0) {
            perror(""pthread_create"");
            close(client.fd);
            continue;
        }

        // Detach thread so that it will not be joined
        if (pthread_detach(thread) != 0) {
            perror(""pthread_detach"");
            close(client.fd);
            continue;
        }
    }

    // Close server socket
    close(server_fd);

    return 0;
}",112,5.5
VULNERABLE,falcon180b-46466.c,yes,19,5,handle_client,"
  file falcon180b-46466.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"int sockfd;
int clients[MAX_CLIENTS];
int num_clients;

void *handle_client(void *client_socket) {
    int client_sock = *(int *) client_socket;
    char request[MAX_REQUEST_SIZE];
    bzero(request, MAX_REQUEST_SIZE);

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);","//Falcon-180B DATASET v1.0 Category: Banking Record System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int sockfd;
int clients[MAX_CLIENTS];
int num_clients;

void *handle_client(void *client_socket) {
    int client_sock = *(int *) client_socket;
    char request[MAX_REQUEST_SIZE];
    bzero(request, MAX_REQUEST_SIZE);

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_sock, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Request from client %d: %s\n"", client_sock, request);

        char response[MAX_REQUEST_SIZE];
        sprintf(response, ""Response to client %d"", client_sock);

        send(client_sock, response, strlen(response), 0);
    }

    close(client_sock);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(sockfd, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(sockfd, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_sock = accept(sockfd, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_sock);
        } else {
            clients[num_clients] = client_sock;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
        }
    }

    return 0;
}",75,3.0
VULNERABLE,falcon180b-51208.c,yes,34,5,thread_function,"
  file falcon180b-51208.c line 34 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *thread_function(void *arg)
{
    int id = *((int *)arg);
    CURL *curl;
    CURLcode res;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();","//Falcon-180B DATASET v1.0 Category: Building a IMAP Client ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <curl/curl.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

static size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t realsize = size * nmemb;
    char *buffer = (char *)malloc(realsize + 1);
    if (buffer == NULL) {
        return 0;
    }
    memcpy(buffer, contents, realsize);
    buffer[realsize] = '\0';
    printf(""%s"", buffer);
    free(buffer);
    return realsize;
}

static int ProgressCallback(void *clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow)
{
    int id = *((int *)clientp);
    printf(""Thread %d: Download progress %ld of %ld bytes.\n"", id, dlnow, dltotal);
    return 0;
}

void *thread_function(void *arg)
{
    int id = *((int *)arg);
    CURL *curl;
    CURLcode res;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if (curl) {
        char url[100];
        sprintf(url, ""imap.gmail.com:993"");
        curl_easy_setopt(curl, CURLOPT_URL, url);

        res = curl_easy_perform(curl);
        if (res!= CURLE_OK) {
            printf(""Thread %d: curl_easy_perform() failed: %s\n"", id, curl_easy_strerror(res));
        } else {
            printf(""Thread %d: Download completed successfully.\n"", id);
        }

        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
    return NULL;
}

int main()
{
    int num_threads = 5;
    pthread_t threads[num_threads];

    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, thread_function, (void *)&i);
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",74,2.25
VULNERABLE,falcon180b-45195.c,yes,21,5,handle_client,"
  file falcon180b-45195.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Game ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8888
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void handle_accept() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }
}

int main() {
    srand(time(NULL));
    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server started on port %d\n"", PORT);

    handle_accept();

    return 0;
}",81,3.0
VULNERABLE,falcon180b-3491.c,yes,19,5,handle_client,"
  file falcon180b-3491.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, 1024);
        int bytes_received = recv(client_socket, buffer, 1024, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8888

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, 1024);
        int bytes_received = recv(client_socket, buffer, 1024, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Please try again later.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",77,4.0
VULNERABLE,falcon180b-59281.c,yes,20,5,handle_client,"
  file falcon180b-59281.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: accurate
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 100
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        num_clients++;

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients-1] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",86,5.0
VULNERABLE,gpt35-42047.c,yes,40,13,main,"
  file gpt35-42047.c line 40 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `months'",dereference failure: accessed expired variable pointer,"            printf(""Total income for %d months: %.2f\n"", months, income * months);
            break;

         case 2:
            printf(""Enter number of months: "");
            scanf(""%d"", &months);
            printf(""Total expenses for %d months: %.2f\n"", months, expenses * months);
            break;

         case 3:
            printf(""Savings rate: %.2f%%\n"", (savings / income) * 100);","//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: Alan Touring
#include <stdio.h>

int main() {
   float income, expenses, savings;
   
   printf(""Enter your monthly income: "");
   scanf(""%f"", &income);
   
   printf(""Enter your monthly expenses: "");
   scanf(""%f"", &expenses);
   
   savings = income - expenses;
   
   printf(""Your monthly savings: %.2f\n"", savings);
   
   printf(""\n*** Personal Finance Planner ***\n"");
   
   printf(""1. Calculate total income\n"");
   printf(""2. Calculate total expenses\n"");
   printf(""3. Calculate savings rate\n"");
   printf(""4. Exit\n"");
   
   int choice;
   
   do {
      printf(""\nEnter your choice: "");
      scanf(""%d"", &choice);
      
      switch(choice) {
         case 1:
            printf(""Enter number of months: "");
            int months;
            scanf(""%d"", &months);
            printf(""Total income for %d months: %.2f\n"", months, income * months);
            break;
            
         case 2:
            printf(""Enter number of months: "");
            scanf(""%d"", &months);
            printf(""Total expenses for %d months: %.2f\n"", months, expenses * months);
            break;
            
         case 3:
            printf(""Savings rate: %.2f%%\n"", (savings / income) * 100);
            break;
            
         case 4:
            printf(""Goodbye.\n"");
            break;
            
         default:
            printf(""Invalid choice. Please try again.\n"");
      }
   } while(choice != 4);
   
   return 0;
}",58,6.0
VULNERABLE,falcon180b-68694.c,yes,20,5,handle_client,"
  file falcon180b-68694.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int sock;
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Network Packet Monitoring ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define BUFFER_SIZE 65536
#define MAX_CLIENTS 10

int sock;
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket;
        socklen_t client_size;

        if ((client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &client_size)) == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",84,5.0
VULNERABLE,falcon180b-52419.c,yes,20,5,handle_client,"
  file falcon180b-52419.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        send(client_socket, buffer, bytes_received, 0);
    }
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    accept_connections();

    close(server_socket);

    return 0;
}",75,2.667
VULNERABLE,falcon180b-63336.c,yes,18,5,handle_client,"
  file falcon180b-63336.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];

    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: GPS Navigation Simulation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];

    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if(bytes_received <= 0) {
            close(client_socket);
            client_sockets[num_clients - 1] = -1;
            num_clients--;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    return NULL;
}

void accept_client() {
    struct sockaddr_in client_addr;
    socklen_t client_size = sizeof(client_addr);

    int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);

    if(client_socket < 0) {
        printf(""Error accepting client\n"");
        return;
    }

    if(num_clients >= MAX_CLIENTS) {
        close(client_socket);
        printf(""Server is full\n"");
        return;
    }

    client_sockets[num_clients] = client_socket;
    num_clients++;

    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if(server_socket < 0) {
        printf(""Error creating socket\n"");
        return -1;
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        return -1;
    }

    if(listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Error listening on socket\n"");
        return -1;
    }

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        accept_client();
    }

    return 0;
}",96,3.667
VULNERABLE,falcon180b-25160.c,yes,22,5,handle_client,"
  file falcon180b-25160.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"struct sockaddr_in g_server_addr;
int g_num_clients = 0;
pthread_t g_thread_id[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (TRUE) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: creative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define TRUE 1
#define FALSE 0
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_socket;
struct sockaddr_in g_server_addr;
int g_num_clients = 0;
pthread_t g_thread_id[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (TRUE) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            g_num_clients--;
            pthread_exit(0);
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < g_num_clients; i++) {
            if (g_thread_id[i]!= 0 && g_thread_id[i]!= pthread_self()) {
                send(g_thread_id[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = TRUE;
    setsockopt(g_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));

    g_server_addr.sin_family = AF_INET;
    g_server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    g_server_addr.sin_port = htons(8080);

    bind(g_socket, (struct sockaddr *) &g_server_addr, sizeof(g_server_addr));
    listen(g_socket, MAX_CLIENTS);

    while (TRUE) {
        socklen_t addr_size = sizeof(g_server_addr);
        int client_socket = accept(g_socket, (struct sockaddr *) &g_server_addr, &addr_size);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);
        g_num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(g_socket);
    return 0;
}",67,4.5
VULNERABLE,falcon180b-55180.c,yes,23,5,handle_client,"
  file falcon180b-55180.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s"", client_socket, buffer);
    }
    close(client_socket);
    num_clients--;
}

void accept_connections(int server_socket) {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    accept_connections(server_socket);

    close(server_socket);
    return 0;
}",80,3.333
VULNERABLE,gpt35-19342.c,yes,99,21,main,"
  file string.c line 78 column 3 function strlen
","
  c:@F@strlen at file gpt35-19342.c line 99 column 21 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `stored_password'",dereference failure: accessed expired variable pointer,"            case 2:
            {
                printf(""Enter username: "");
                scanf(""%s"", username);
                char* retrieved_password = retrieve_password(username);
                if (strlen(retrieved_password) != 0)
                {
                    printf(""Password for %s is %s\n"", username, retrieved_password);
                }
                else
                {","//FormAI DATASET v1.0 Category: Password management ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_USERNAME_LENGTH 50
#define MAX_PASSWORD_LENGTH 50

// Function to encrypt the given password
char* encrypt_password(char password[])
{
    int i = 0;
    while (password[i] != '\0')
    {
        password[i] = toupper(password[i]);
        password[i] += 3;
        i++;
    }
    return password;
}

// Function to decrypt the given password
char* decrypt_password(char password[])
{
    int i = 0;
    while (password[i] != '\0')
    {
        password[i] = password[i] - 3;
        password[i] = tolower(password[i]);
        i++;
    }
    return password;
}

// Function to store the given password in a file
void store_password(char username[], char password[])
{
    FILE *fp;
    fp = fopen(""passwords.txt"", ""a"");
    fprintf(fp, ""%s %s\n"", username, password);
    fclose(fp);
}

// Function to retrieve the password for the given username
char* retrieve_password(char username[])
{
    FILE *fp;
    char stored_username[MAX_USERNAME_LENGTH];
    char stored_password[MAX_PASSWORD_LENGTH];
    char* decrypted_password = (char*)malloc(MAX_PASSWORD_LENGTH * sizeof(char));
    fp = fopen(""passwords.txt"", ""r"");

    while (fscanf(fp, ""%s %s"", stored_username, stored_password) != EOF)
    {
        if (strcmp(username, stored_username) == 0)
        {
            decrypted_password = decrypt_password(stored_password);
            break;
        }
    }
    fclose(fp);
    return decrypted_password;
}

int main()
{
    int choice;
    char username[MAX_USERNAME_LENGTH];
    char password[MAX_PASSWORD_LENGTH];

    printf(""Welcome to Password Manager!\n"");

    do 
    {
        printf(""\n1. Store Password\n"");
        printf(""2. Get Password\n"");
        printf(""3. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice)
        {
            case 1:
            {
                printf(""Enter username: "");
                scanf(""%s"", username);
                printf(""Enter password: "");
                scanf(""%s"", password);
                store_password(username, encrypt_password(password));
                printf(""Password stored successfully!\n"");
                break;
            }
            case 2:
            {
                printf(""Enter username: "");
                scanf(""%s"", username);
                char* retrieved_password = retrieve_password(username);
                if (strlen(retrieved_password) != 0)
                {
                    printf(""Password for %s is %s\n"", username, retrieved_password);
                }
                else
                {
                    printf(""Password not found for %s\n"", username);
                }
                break;
            }
            case 3:
            {
                printf(""Thank you for using Password Manager!\n"");
                exit(0);
            }
            default:
            {
                printf(""Invalid choice! Please try again.\n"");
                break;
            }
        }

    } while(1);

    return 0;
}",124,2.8
VULNERABLE,falcon180b-55664.c,yes,23,5,handle_client,"
  file falcon180b-55664.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            if(bytes_received == 0)
                printf(""Client %d disconnected\n"", client_socket);
            else
                printf(""Client %d connection error\n"", client_socket);

            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main(int argc, char *argv[]) {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server listening on port %d\n"", PORT);

    while(1) {
        socklen_t client_size = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_sockets[num_clients], &client_size);

        if(client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        num_clients++;
        printf(""Client %d connected\n"", client_socket);

        pthread_create(&threads[num_clients - 1], NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",74,3.5
VULNERABLE,gpt35-36897.c,yes,55,5,handle_client,"
  file gpt35-36897.c line 55 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"        }
    }
}

void *handle_client(void *socket_desc_ptr) {
    int client_socket = *(int *) socket_desc_ptr;

    char buffer[BUFFER_SIZE];
    ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
    if (bytes_received == -1) {
        perror(""Failed to receive data from client"");","//FormAI DATASET v1.0 Category: Networking ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define BUFFER_SIZE 1024

void *handle_client(void *socket_desc_ptr);

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""Failed to create socket"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_address = {0};
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(PORT);
    server_address.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_address, sizeof(server_address)) == -1) {
        perror(""Failed to bind socket to address"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, 5) == -1) {
        perror(""Failed to listen for incoming connections"");
        exit(EXIT_FAILURE);
    }

    while (true) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""Failed to accept incoming connection"");
            continue;
        }

        pthread_t client_thread;
        if (pthread_create(&client_thread, NULL, handle_client, &client_socket) != 0) {
            perror(""Failed to create new thread for client"");
            close(client_socket);
        }
    }
}

void *handle_client(void *socket_desc_ptr) {
    int client_socket = *(int *) socket_desc_ptr;

    char buffer[BUFFER_SIZE];
    ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
    if (bytes_received == -1) {
        perror(""Failed to receive data from client"");
        close(client_socket);
        pthread_exit(NULL);
    }

    printf(""Received message from client: %s\n"", buffer);

    const char *message = ""Hello from server!"";
    ssize_t bytes_sent = send(client_socket, message, strlen(message) + 1, 0);
    if (bytes_sent == -1) {
        perror(""Failed to send data to client"");
    }

    close(client_socket);
    pthread_exit(NULL);
}",75,5.0
VULNERABLE,falcon180b-49570.c,yes,20,5,handle_client,"
  file falcon180b-49570.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: File Synchronizer ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is running on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-64595.c,yes,18,5,handle_client,"
  file falcon180b-64595.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int server_socket;
struct sockaddr_in server_addr;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024

int server_socket;
struct sockaddr_in server_addr;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",62,3.0
VULNERABLE,falcon180b-35175.c,yes,18,5,handle_client,"
  file falcon180b-35175.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < bytes_received; i++) {
            if (!isprint(buffer[i])) {
                printf(""Intrusion detected from client %d\n"", client_socket);
                close(client_socket);
                pthread_exit(NULL);
            }
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-68603.c,yes,22,5,handle_client,"
  file falcon180b-68603.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Simple Web Server ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>
#include <fcntl.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received == 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(SERVER_PORT, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);

        client_sockets[num_clients++] = client_socket;
    }

    return 0;
}",79,4.0
VULNERABLE,falcon180b-20787.c,yes,18,5,handle_client,"
  file falcon180b-20787.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char message[MAX_MESSAGE_SIZE];

    while (1) {
        memset(message, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, message, MAX_MESSAGE_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MESSAGE_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char message[MAX_MESSAGE_SIZE];

    while (1) {
        memset(message, 0, MAX_MESSAGE_SIZE);
        int bytes_received = recv(client_socket, message, MAX_MESSAGE_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", client_socket, message);
    }
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        socklen_t client_size = sizeof(client_sockets[num_clients]);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_sockets[num_clients], &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        num_clients++;
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        accept_connections();
        usleep(100000);
    }

    return 0;
}",62,2.667
VULNERABLE,falcon180b-48398.c,yes,17,5,handle_client,"
  file falcon180b-48398.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Database Indexing System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more clients.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",86,5.0
VULNERABLE,falcon180b-3304.c,yes,17,5,handle_client,"
  file falcon180b-3304.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if(listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 12345\n"");

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
        if(client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        for(int i=0; i<MAX_CLIENTS; i++) {
            if(clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",78,5.5
VULNERABLE,falcon180b-28652.c,yes,19,5,handle_client,"
  file falcon180b-28652.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void*) &client_socket);
        }
    }

    return 0;
}",64,4.0
VULNERABLE,gpt35-42332.c,yes,135,24,main,"
  file io.c line 185 column 24 function fread
","
  c:@F@fread at file gpt35-42332.c line 135 column 24 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `p'",dereference failure: accessed expired variable pointer,"            case 6:
                printf(""Enter the person's address: "");
                scanf(""%s"", address);
                rewind(fp);

                while (fread(&p, sizeof(Person), 1, fp)) {
                    if (strcmp(p.address, address) == 0) {
                        printf(""ID: %d\n"", p.id);
                        printf(""Name: %s\n"", p.name);
                        printf(""Age: %d\n"", p.age);
                        printf(""Gender: %c\n"", p.gender);","//FormAI DATASET v1.0 Category: Database querying ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char name[30];
    int age;
    char gender;
    char address[100];
} Person;

int main() {
    FILE* fp;
    char filename[100];
    int choice;
    int id;
    char name[30], address[100];
    int age;
    char gender;

    printf(""Enter the name of the file to use: "");
    scanf(""%s"", filename);

    fp = fopen(filename, ""rb+"");
    if (fp == NULL) {
        printf(""Failed to open file\n"");
        exit(1);
    }

    while (1) {
        printf(""\nMENU\n"");
        printf(""1. Add a person\n"");
        printf(""2. Search for a person by ID\n"");
        printf(""3. Search for a person by name\n"");
        printf(""4. Search for a person by age\n"");
        printf(""5. Search for a person by gender\n"");
        printf(""6. Search for a person by address\n"");
        printf(""7. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""Enter the person's ID: "");
                scanf(""%d"", &id);
                printf(""Enter the person's name: "");
                scanf(""%s"", name);
                printf(""Enter the person's age: "");
                scanf(""%d"", &age);
                printf(""Enter the person's gender: "");
                scanf("" %c"", &gender);
                printf(""Enter the person's address: "");
                scanf(""%s"", address);

                fseek(fp, 0, SEEK_END);

                Person p = { id, name, age, gender, address };

                fwrite(&p, sizeof(Person), 1, fp);
                printf(""Person added successfully\n"");
                break;

            case 2:
                printf(""Enter the person's ID: "");
                scanf(""%d"", &id);
                rewind(fp);

                while (fread(&p, sizeof(Person), 1, fp)) {
                    if (p.id == id) {
                        printf(""ID: %d\n"", p.id);
                        printf(""Name: %s\n"", p.name);
                        printf(""Age: %d\n"", p.age);
                        printf(""Gender: %c\n"", p.gender);
                        printf(""Address: %s\n"", p.address);
                        break;
                    }
                }
                break;

            case 3:
                printf(""Enter the person's name: "");
                scanf(""%s"", name);
                rewind(fp);

                while (fread(&p, sizeof(Person), 1, fp)) {
                    if (strcmp(p.name, name) == 0) {
                        printf(""ID: %d\n"", p.id);
                        printf(""Name: %s\n"", p.name);
                        printf(""Age: %d\n"", p.age);
                        printf(""Gender: %c\n"", p.gender);
                        printf(""Address: %s\n"", p.address);
                    }
                }
                break;

            case 4:
                printf(""Enter the person's age: "");
                scanf(""%d"", &age);
                rewind(fp);

                while (fread(&p, sizeof(Person), 1, fp)) {
                    if (p.age == age) {
                        printf(""ID: %d\n"", p.id);
                        printf(""Name: %s\n"", p.name);
                        printf(""Age: %d\n"", p.age);
                        printf(""Gender: %c\n"", p.gender);
                        printf(""Address: %s\n"", p.address);
                    }
                }
                break;

            case 5:
                printf(""Enter the person's gender: "");
                scanf("" %c"", &gender);
                rewind(fp);

                while (fread(&p, sizeof(Person), 1, fp)) {
                    if (p.gender == gender) {
                        printf(""ID: %d\n"", p.id);
                        printf(""Name: %s\n"", p.name);
                        printf(""Age: %d\n"", p.age);
                        printf(""Gender: %c\n"", p.gender);
                        printf(""Address: %s\n"", p.address);
                    }
                }
                break;

            case 6:
                printf(""Enter the person's address: "");
                scanf(""%s"", address);
                rewind(fp);

                while (fread(&p, sizeof(Person), 1, fp)) {
                    if (strcmp(p.address, address) == 0) {
                        printf(""ID: %d\n"", p.id);
                        printf(""Name: %s\n"", p.name);
                        printf(""Age: %d\n"", p.age);
                        printf(""Gender: %c\n"", p.gender);
                        printf(""Address: %s\n"", p.address);
                    }
                }
                break;

            case 7:
                return 0;
                break;

            default:
                printf(""Invalid choice\n"");
                break;
        }
    }

    fclose(fp);
    return 0;
}",158,20.0
VULNERABLE,gemini_pro-9899.c,yes,18,5,handle_client,"
  file gemini_pro-9899.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"// Port number to listen on
#define PORT 8080

// Function to handle client connections
void* handle_client(void* arg) {
    int client_sock = *(int*) arg;

    // Receive the client's message
    char buffer[1024];
    int bytes_received = recv(client_sock, buffer, sizeof(buffer), 0);
    if (bytes_received <= 0) {","//GEMINI-pro DATASET v1.0 Category: TCP/IP Programming ; Style: future-proof
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

// Maximum number of client connections
#define MAX_CONNECTIONS 5

// Port number to listen on
#define PORT 8080

// Function to handle client connections
void* handle_client(void* arg) {
    int client_sock = *(int*) arg;

    // Receive the client's message
    char buffer[1024];
    int bytes_received = recv(client_sock, buffer, sizeof(buffer), 0);
    if (bytes_received <= 0) {
        perror(""Error receiving message from client"");
        close(client_sock);
        return NULL;
    }

    // Process the client's message
    printf(""Received message from client: %s\n"", buffer);

    // Send a response to the client
    const char* response = ""Hello from the server!"";
    int bytes_sent = send(client_sock, response, strlen(response), 0);
    if (bytes_sent <= 0) {
        perror(""Error sending message to client"");
    }

    // Close the client connection
    close(client_sock);

    return NULL;
}

int main() {
    // Create a socket for listening for client connections
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        perror(""Error creating server socket"");
        return EXIT_FAILURE;
    }

    // Bind the socket to the specified port
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    if (bind(server_sock, (struct sockaddr*) &server_addr, sizeof(server_addr)) == -1) {
        perror(""Error binding server socket to port"");
        close(server_sock);
        return EXIT_FAILURE;
    }

    // Start listening for client connections
    if (listen(server_sock, MAX_CONNECTIONS) == -1) {
        perror(""Error listening for client connections"");
        close(server_sock);
        return EXIT_FAILURE;
    }

    printf(""Server listening on port %d\n"", PORT);

    // Accept client connections and handle them in separate threads
    while (1) {
        int client_sock = accept(server_sock, NULL, NULL);
        if (client_sock == -1) {
            perror(""Error accepting client connection"");
            continue;
        }

        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, &client_sock) != 0) {
            perror(""Error creating thread to handle client connection"");
            close(client_sock);
            continue;
        }
    }

    // Close the server socket
    close(server_sock);

    return EXIT_SUCCESS;
}",95,5.0
VULNERABLE,falcon180b-67595.c,yes,21,5,handle_client,"
  file falcon180b-67595.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",77,4.0
VULNERABLE,falcon180b-50361.c,yes,18,5,handle_client,"
  file falcon180b-50361.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            close(client_socket);
            break;
        }
        printf(""Client %d: %s\n"", client_socket, buffer);
        for(int i = 0; i < num_clients; i++) {
            if(i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5000);
    inet_pton(AF_INET, ""127.0.0.1"", &server_addr.sin_addr);

    if(bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if(listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 5000\n"");

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);
        if(client_socket!= -1) {
            printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
            client_sockets[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    close(server_socket);
    return 0;
}",76,5.5
VULNERABLE,falcon180b-50564.c,yes,19,5,handle_client,"
  file falcon180b-50564.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            client_sockets[num_clients - 1] = -1;
            num_clients--;
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= -1) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Could not create socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Could not bind socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Could not listen on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);
        if (client_socket == -1) {
            printf(""Could not accept connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Too many clients\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",89,6.0
VULNERABLE,falcon180b-5886.c,yes,21,5,handle_client,"
  file falcon180b-5886.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 50
#define PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            return NULL;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket && clients[i] > 0) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i] > 0 && clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Chat server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 16, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",83,4.333
VULNERABLE,falcon180b-20839.c,yes,18,5,handle_client,"
  file falcon180b-20839.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: random
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",65,3.0
VULNERABLE,falcon180b-64460.c,yes,19,5,handle_client,"
  file falcon180b-64460.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Interprocess communication ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client disconnected\n"");
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client message: %s\n"", buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",66,3.0
VULNERABLE,gemini_pro-20293.c,yes,35,5,send_ping,"
  file gemini_pro-20293.c line 35 column 5 function send_ping
","
  c:@F@send_ping at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"pthread_mutex_t players_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to send a ping to the server
void *send_ping(void *arg) {
    // Get player ID
    int id = *(int *)arg;

    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");","//GEMINI-pro DATASET v1.0 Category: Network Ping Test ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

// Server address and port
#define SERVER_ADDR ""127.0.0.1""
#define SERVER_PORT 8080

// Maximum number of players
#define MAX_PLAYERS 4

// Player struct
typedef struct {
    int id;
    char name[20];
    int score;
    int ping;
} player;

// Player array
player players[MAX_PLAYERS];

// Mutex for player array
pthread_mutex_t players_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to send a ping to the server
void *send_ping(void *arg) {
    // Get player ID
    int id = *(int *)arg;

    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Connect to the server
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_ADDR);
    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""connect"");
        exit(EXIT_FAILURE);
    }

    // Send the ping message
    char message[20];
    sprintf(message, ""PING %d"", id);
    if (send(sockfd, message, strlen(message), 0) == -1) {
        perror(""send"");
        exit(EXIT_FAILURE);
    }

    // Receive the ping response
    char response[20];
    if (recv(sockfd, response, sizeof(response), 0) == -1) {
        perror(""recv"");
        exit(EXIT_FAILURE);
    }

    // Parse the ping response
    int ping;
    sscanf(response, ""PONG %d"", &ping);

    // Update the player's ping
    pthread_mutex_lock(&players_mutex);
    players[id].ping = ping;
    pthread_mutex_unlock(&players_mutex);

    // Close the socket
    close(sockfd);

    return NULL;
}

// Function to print the player scores
void print_scores() {
    pthread_mutex_lock(&players_mutex);

    printf(""Scores:\n"");
    for (int i = 0; i < MAX_PLAYERS; i++) {
        printf(""%s: %d\n"", players[i].name, players[i].score);
    }

    pthread_mutex_unlock(&players_mutex);
}

// Main function
int main() {
    // Initialize the players
    for (int i = 0; i < MAX_PLAYERS; i++) {
        players[i].id = i;
        sprintf(players[i].name, ""Player %d"", i);
        players[i].score = 0;
        players[i].ping = 0;
    }

    // Create a thread for each player
    pthread_t threads[MAX_PLAYERS];
    for (int i = 0; i < MAX_PLAYERS; i++) {
        if (pthread_create(&threads[i], NULL, send_ping, &i) != 0) {
            perror(""pthread_create"");
            exit(EXIT_FAILURE);
        }
    }

    // Join the threads
    for (int i = 0; i < MAX_PLAYERS; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            perror(""pthread_join"");
            exit(EXIT_FAILURE);
        }
    }

    // Print the player scores
    print_scores();

    return 0;
}",128,4.333
VULNERABLE,gemini_pro-23401.c,yes,41,3,change_light_state,"
  file gemini_pro-23401.c line 41 column 3 function change_light_state
","
  c:@F@change_light_state at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"pthread_t threads[NUM_LIGHTS];

// Function to change the state of a traffic light
void *change_light_state(void *arg) {
  // Get the index of the traffic light
  int index = *(int *)arg;

  // Loop forever
  while (1) {
    // Lock the mutex
    pthread_mutex_lock(&mutex);","//GEMINI-pro DATASET v1.0 Category: Traffic Light Controller ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#define NUM_LIGHTS 3

// Define the traffic light states
enum light_state {
  RED,
  YELLOW,
  GREEN
};

// Define the traffic light colors
enum light_color {
  RED_COLOR,
  YELLOW_COLOR,
  GREEN_COLOR
};

// Create a mutex to protect the shared data
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Create a condition variable to signal when the light state changes
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Create an array of traffic lights
struct traffic_light {
  enum light_state state;
  enum light_color color;
} lights[NUM_LIGHTS];

// Create a thread for each traffic light
pthread_t threads[NUM_LIGHTS];

// Function to change the state of a traffic light
void *change_light_state(void *arg) {
  // Get the index of the traffic light
  int index = *(int *)arg;

  // Loop forever
  while (1) {
    // Lock the mutex
    pthread_mutex_lock(&mutex);

    // Wait for the condition variable to be signaled
    pthread_cond_wait(&cond, &mutex);

    // Change the state of the traffic light
    switch (lights[index].state) {
      case RED:
        lights[index].state = GREEN;
        lights[index].color = GREEN_COLOR;
        break;
      case YELLOW:
        lights[index].state = RED;
        lights[index].color = RED_COLOR;
        break;
      case GREEN:
        lights[index].state = YELLOW;
        lights[index].color = YELLOW_COLOR;
        break;
    }

    // Unlock the mutex
    pthread_mutex_unlock(&mutex);

    // Sleep for 1 second
    sleep(1);
  }

  return NULL;
}

int main() {
  // Initialize the traffic lights
  for (int i = 0; i < NUM_LIGHTS; i++) {
    lights[i].state = RED;
    lights[i].color = RED_COLOR;
  }

  // Create the threads
  for (int i = 0; i < NUM_LIGHTS; i++) {
    pthread_create(&threads[i], NULL, change_light_state, &i);
  }

  // Join the threads
  for (int i = 0; i < NUM_LIGHTS; i++) {
    pthread_join(threads[i], NULL);
  }

  return 0;
}",95,4.5
VULNERABLE,falcon180b-3387.c,yes,20,5,handle_client,"
  file falcon180b-3387.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);

        for(int i=0; i<num_clients; i++) {
            if(clients[i][0]!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 15, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = 0;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-341.c,yes,76,5,main,"
  file falcon180b-341.c line 76 column 5 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `public_key'",dereference failure: accessed expired variable pointer,"    key_pair key;
    generate_keys(&key);

    int message = 12345;
    int encrypted_message;
    encrypt(message, *key.public_key, &encrypted_message);

    printf(""Encrypted message: %d\n"", encrypted_message);

    int decrypted_message;
    decrypt(encrypted_message, *key.private_key, &decrypted_message);","//Falcon-180B DATASET v1.0 Category: Public-Key Algorithm Implementation ; Style: immersive
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//Defining the structure for the public and private keys
typedef struct{
    int *public_key;
    int *private_key;
}key_pair;

//Function to generate the prime numbers
int is_prime(int n){
    if(n <= 1){
        return 0;
    }
    for(int i = 2; i*i <= n; i++){
        if(n % i == 0){
            return 0;
        }
    }
    return 1;
}

//Function to generate the keys
void generate_keys(key_pair *key){
    int private_key = rand() % 10000;
    key->private_key = &private_key;

    while(1){
        int public_key = rand() % 10000;
        if(is_prime(public_key)){
            key->public_key = &public_key;
            break;
        }
    }
}

//Function to encrypt the message
void encrypt(int message, int public_key, int *encrypted_message){
    int temp = message;
    int result = 1;

    while(temp!= 0){
        if(temp % 2 == 1){
            result = (result * public_key) % 10000;
        }
        temp /= 2;
        public_key = (public_key * public_key) % 10000;
    }

    *encrypted_message = result;
}

//Function to decrypt the message
void decrypt(int encrypted_message, int private_key, int *decrypted_message){
    int temp = encrypted_message;
    int result = 1;

    while(temp!= 0){
        if(temp % 2 == 1){
            result = (result * private_key) % 10000;
        }
        temp /= 2;
    }

    *decrypted_message = result;
}

int main(){
    key_pair key;
    generate_keys(&key);

    int message = 12345;
    int encrypted_message;
    encrypt(message, *key.public_key, &encrypted_message);

    printf(""Encrypted message: %d\n"", encrypted_message);

    int decrypted_message;
    decrypt(encrypted_message, *key.private_key, &decrypted_message);

    printf(""Decrypted message: %d\n"", decrypted_message);

    return 0;
}",86,2.8
VULNERABLE,falcon180b-27847.c,yes,17,5,handle_client,"
  file falcon180b-27847.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Music Library Management System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Please try again later.\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",63,3.0
VULNERABLE,falcon180b-63527.c,yes,17,5,handle_client,"
  file falcon180b-63527.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (fgets(buffer, BUFFER_SIZE, stdin)!= NULL) {
        send(client_socket, buffer, strlen(buffer), 0);
    }","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: multi-threaded
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (fgets(buffer, BUFFER_SIZE, stdin)!= NULL) {
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",59,2.5
VULNERABLE,gpt35-44451.c,yes,21,3,handle_client,"
  file gpt35-44451.c line 21 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS]; // array to store client sockets

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // mutex for thread safety

void *handle_client(void *socket_desc) {
  int sock = *(int*)socket_desc;
  char buff[1024];
  while(1) {
    memset(buff, 0, 1024);
    if(read(sock, buff, 1024) == 0) {
      // client disconnected","//FormAI DATASET v1.0 Category: Chat server ; Style: all-encompassing
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
// maximum number of clients that can connect to the server

int num_clients = 0; // number of active clients
int client_sockets[MAX_CLIENTS]; // array to store client sockets

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // mutex for thread safety

void *handle_client(void *socket_desc) {
  int sock = *(int*)socket_desc;
  char buff[1024];
  while(1) {
    memset(buff, 0, 1024);
    if(read(sock, buff, 1024) == 0) {
      // client disconnected
      printf(""Client disconnected.\n"");
      pthread_mutex_lock(&mutex);
      for(int i=0; i<num_clients; i++) {
        if(client_sockets[i] == sock) {
          close(client_sockets[i]);
          client_sockets[i] = client_sockets[num_clients-1];
          num_clients--;
          break;
        }
      }
      pthread_mutex_unlock(&mutex);
      break;
    }
    printf(""Message: %s\n"", buff);
    pthread_mutex_lock(&mutex);
    // send the message received to all clients
    for(int i=0; i<num_clients; i++) {
      if(client_sockets[i] != sock) {
        write(client_sockets[i], buff, strlen(buff));
      }
    }
    pthread_mutex_unlock(&mutex);
  }
  return 0;
}

int main(int argc, char *argv[]) {
  int server_sock, client_sock;
  struct sockaddr_in server_addr, client_addr;

  // create TCP socket
  server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if(server_sock == -1) {
    perror(""Error creating socket"");
    exit(EXIT_FAILURE);
  }

  // set server address
  memset(&server_addr, 0, sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
  server_addr.sin_port = htons(9000);

  // bind socket to server address
  if(bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
    perror(""Error binding socket"");
    exit(EXIT_FAILURE);
  }

  // listen for incoming connections
  if(listen(server_sock, MAX_CLIENTS) == -1) {
    perror(""Error listening for connections"");
    exit(EXIT_FAILURE);
  }

  // accept incoming connections
  int client_addr_len = sizeof(client_addr);
  while((client_sock = accept(server_sock, (struct sockaddr *)&client_addr, (socklen_t*)&client_addr_len))) {
    pthread_t thread_id;
    // handle at most MAX_CLIENTS at once
    if(num_clients < MAX_CLIENTS) {
      client_sockets[num_clients] = client_sock;
      num_clients++;
      // create a new thread to handle the client
      if(pthread_create(&thread_id, NULL, handle_client, (void*)&client_sock) < 0) {
        perror(""Error creating thread"");
        exit(EXIT_FAILURE);
      }
      printf(""Accepted new connection from %s:%d (%d/%d clients)\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), num_clients, MAX_CLIENTS);
      // send welcome message to client
      char welcome_msg[] = ""Welcome to the chat server! Please type your message and press enter.\n"";
      write(client_sock, welcome_msg, strlen(welcome_msg));
    }
    else {
      char too_many_clients[] = ""The server is full. Please try again later.\n"";
      write(client_sock, too_many_clients, strlen(too_many_clients));
      close(client_sock);
    }
  }

  if(client_sock == -1) {
    perror(""Error accepting connection"");
    exit(EXIT_FAILURE);
  }

  return 0;
}",113,7.5
VULNERABLE,falcon180b-68381.c,yes,22,5,handle_client,"
  file falcon180b-68381.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define PORT ""8080""

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        for(int i=0; i<num_clients; i++) {
            if(clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(atoi(PORT));
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\r\n"", 16, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    accept_connections();
    return 0;
}",76,3.0
VULNERABLE,falcon180b-5284.c,yes,20,5,handle_client,"
  file falcon180b-5284.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Wireless Network Scanner ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    return NULL;
}

void accept_connections() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        socklen_t client_size = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_sockets[num_clients], &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }
}

int main() {
    accept_connections();

    return 0;
}",85,3.333
VULNERABLE,gpt35-71973.c,yes,22,5,client_handler,"
  file gpt35-71973.c line 22 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_index'",dereference failure: accessed expired variable pointer,"
client_t clients[MAX_CLIENTS]; // array to store all client connections
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // mutex for accessing shared variables

void *client_handler(void *arg) {
    int client_index = *(int*)arg;
    int client_socket = clients[client_index].socket;
    struct sockaddr_in client_address = clients[client_index].client_address;
    char buffer[BUFFER_SIZE];

    printf(""New client connected: %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));","//FormAI DATASET v1.0 Category: Chat server ; Style: portable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

typedef struct {
    int socket;
    struct sockaddr_in client_address;
} client_t;

client_t clients[MAX_CLIENTS]; // array to store all client connections
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // mutex for accessing shared variables

void *client_handler(void *arg) {
    int client_index = *(int*)arg;
    int client_socket = clients[client_index].socket;
    struct sockaddr_in client_address = clients[client_index].client_address;
    char buffer[BUFFER_SIZE];

    printf(""New client connected: %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));

    while (1) {
        memset(buffer, 0, BUFFER_SIZE); // clear buffer
        int read_bytes = read(client_socket, buffer, BUFFER_SIZE); // receive message from client
        if (read_bytes <= 0) {
            // client has disconnected
            printf(""Client disconnected: %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));
            close(client_socket);
            pthread_mutex_lock(&mutex);
            clients[client_index].socket = 0; // mark slot as available
            pthread_mutex_unlock(&mutex);
            break;
        } else {
            // broadcast message to all connected clients
            printf(""Received message from %s:%d: %s\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port), buffer);
            for (int i = 0; i < MAX_CLIENTS; i++) {
                if (clients[i].socket > 0) {
                    int send_bytes = send(clients[i].socket, buffer, read_bytes, 0);
                    if (send_bytes < 0) {
                        printf(""Error sending message to %s:%d\n"", inet_ntoa(clients[i].client_address.sin_addr), ntohs(clients[i].client_address.sin_port));
                        continue;
                    }
                }
            }
        }
    }

    return NULL;
}

int main(int argc, char *argv[]) {
    int server_socket, client_socket, option = 1;
    struct sockaddr_in server_address, client_address;
    pthread_t threads[MAX_CLIENTS];

    memset(clients, 0, sizeof(clients)); // clear clients array

    // create server socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        printf(""Error creating server socket\n"");
        return EXIT_FAILURE;
    }

    // set server socket options
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &option, sizeof(option)) < 0) {
        printf(""Error setting server socket options\n"");
        return EXIT_FAILURE;
    }

    // initialize server address
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);

    // bind server socket to address
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        printf(""Error binding server socket to address\n"");
        return EXIT_FAILURE;
    }

    // listen for incoming client connections
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening for incoming client connections\n"");
        return EXIT_FAILURE;
    }

    printf(""Server is listening on port %d\n"", ntohs(server_address.sin_port));

    while (1) {
        // accept new client connection
        socklen_t client_address_size = sizeof(client_address);
        if ((client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_size)) == -1) {
            printf(""Error accepting new client connection\n"");
            continue;
        }

        // find first available slot in clients array
        int client_index = -1;
        pthread_mutex_lock(&mutex);
        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i].socket == 0) {
                client_index = i;
                break;
            }
        }

        if (client_index == -1) {
            // maximum number of clients already connected
            printf(""Maximum number of clients already connected\n"");
            close(client_socket);
        } else {
            // add new client to clients array
            clients[client_index].socket = client_socket;
            clients[client_index].client_address = client_address;

            // create new thread to handle client
            if (pthread_create(&threads[client_index], NULL, client_handler, &client_index) != 0) {
                printf(""Error creating thread to handle client\n"");
                close(client_socket);
                clients[client_index].socket = 0; // mark slot as available
            }
        }
        pthread_mutex_unlock(&mutex);
    }

    return EXIT_SUCCESS;
}",135,8.5
VULNERABLE,falcon180b-21884.c,yes,24,5,handle_client,"
  file falcon180b-21884.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    while (1) {
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define MAX_EMAIL_LENGTH 100

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, BUFFER_SIZE);

    while (1) {
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }

        pthread_mutex_lock(&lock);
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        pthread_mutex_unlock(&lock);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void*)&client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(12345);

    bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    accept_connections();

    return 0;
}",78,2.333
VULNERABLE,falcon180b-7874.c,yes,18,5,handle_client,"
  file falcon180b-7874.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",90,6.0
VULNERABLE,gemini_pro-6990.c,yes,16,5,handle_client,"
  file gemini_pro-6990.c line 16 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#define MAX_CONNECTIONS 5
#define BUFFER_SIZE 1024

// Thread function to handle client requests
void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    // Receive a message from the client
    char buffer[BUFFER_SIZE];
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
","//GEMINI-pro DATASET v1.0 Category: Networking ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CONNECTIONS 5
#define BUFFER_SIZE 1024

// Thread function to handle client requests
void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    // Receive a message from the client
    char buffer[BUFFER_SIZE];
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

    // Check if the client has closed the connection
    if (bytes_received == 0) {
        printf(""Client has closed the connection\n"");
        close(client_socket);
        pthread_exit(NULL);
    }

    // Process the message
    printf(""Received message from client: %s\n"", buffer);
    char response[BUFFER_SIZE];
    sprintf(response, ""Hello, client! You sent the message: %s"", buffer);

    // Send a response to the client
    int bytes_sent = send(client_socket, response, strlen(response), 0);

    // Close the client socket
    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    // Create a server socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        return EXIT_FAILURE;
    }

    // Set the server socket to be reusable
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // Bind the server socket to the port
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(PORT);
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror(""bind"");
        close(server_socket);
        return EXIT_FAILURE;
    }

    // Listen for incoming connections
    if (listen(server_socket, MAX_CONNECTIONS) == -1) {
        perror(""listen"");
        close(server_socket);
        return EXIT_FAILURE;
    }

    // Main loop to handle client connections
    while (1) {
        // Accept an incoming connection
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        // Create a new thread to handle the client request
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, (void *)&client_socket) != 0) {
            perror(""pthread_create"");
            close(client_socket);
            continue;
        }

        // Detach the thread so that it can run independently of the main thread
        pthread_detach(thread);
    }

    // Close the server socket
    close(server_socket);

    return EXIT_SUCCESS;
}",97,4.5
VULNERABLE,falcon180b-43278.c,yes,31,5,monitor_thread,"
  file falcon180b-43278.c line 31 column 5 function monitor_thread
","
  c:@F@monitor_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `data'",dereference failure: accessed expired variable pointer,"    struct connection *connections;
};

void *monitor_thread(void *arg) {
    struct thread_data *data = (struct thread_data *) arg;
    struct connection *connections = data->connections;

    for (int i = 0; i < MAX_CONNECTIONS; i++) {
        if (connections[i].socket!= -1) {
            char request[MAX_REQUEST_SIZE];
            memset(request, 0, MAX_REQUEST_SIZE);","//Falcon-180B DATASET v1.0 Category: Network Quality of Service (QoS) monitor ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <errno.h>
#include <pthread.h>

#define MAX_THREADS 10
#define MAX_CONNECTIONS 100
#define MAX_REQUEST_SIZE 1024
#define MAX_RESPONSE_SIZE 4096

struct connection {
    int socket;
    char ip[INET6_ADDRSTRLEN];
    int port;
};

struct thread_data {
    int thread_id;
    struct connection *connections;
};

void *monitor_thread(void *arg) {
    struct thread_data *data = (struct thread_data *) arg;
    struct connection *connections = data->connections;

    for (int i = 0; i < MAX_CONNECTIONS; i++) {
        if (connections[i].socket!= -1) {
            char request[MAX_REQUEST_SIZE];
            memset(request, 0, MAX_REQUEST_SIZE);

            int bytes_received = recv(connections[i].socket, request, MAX_REQUEST_SIZE, 0);

            if (bytes_received <= 0) {
                close(connections[i].socket);
                connections[i].socket = -1;
                continue;
            }

            char response[MAX_RESPONSE_SIZE];
            memset(response, 0, MAX_RESPONSE_SIZE);

            sprintf(response, ""HTTP/1.1 200 OK\r\nContent-Length: %d\r\n\r\n"", bytes_received);

            send(connections[i].socket, response, strlen(response), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CONNECTIONS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    struct connection connections[MAX_CONNECTIONS];
    memset(connections, 0, sizeof(connections));

    pthread_t threads[MAX_THREADS];

    for (int i = 0; i < MAX_THREADS; i++) {
        struct thread_data data;
        data.thread_id = i;
        data.connections = connections;

        pthread_create(&threads[i], NULL, monitor_thread, (void *) &data);
    }

    for (int i = 0; i < MAX_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    close(server_socket);

    return 0;
}",103,5.0
VULNERABLE,falcon180b-57664.c,yes,19,5,scan_ports,"
  file falcon180b-57664.c line 19 column 5 function scan_ports
","
  c:@F@scan_ports at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int ports[MAX_PORTS];
int num_ports = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *scan_ports(void *arg) {
    int thread_num = *(int *) arg;
    int start_port = thread_num * (MAX_PORTS / MAX_THREADS) + 1;
    int end_port = (thread_num == MAX_THREADS - 1)? MAX_PORTS : start_port + (MAX_PORTS / MAX_THREADS) - 1;

    for (int i = start_port; i <= end_port; i++) {
        pthread_mutex_lock(&mutex);","//Falcon-180B DATASET v1.0 Category: Port Scanner ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_THREADS 100
#define MAX_PORTS 65535
#define BUFFER_SIZE 1024

int ports[MAX_PORTS];
int num_ports = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *scan_ports(void *arg) {
    int thread_num = *(int *) arg;
    int start_port = thread_num * (MAX_PORTS / MAX_THREADS) + 1;
    int end_port = (thread_num == MAX_THREADS - 1)? MAX_PORTS : start_port + (MAX_PORTS / MAX_THREADS) - 1;

    for (int i = start_port; i <= end_port; i++) {
        pthread_mutex_lock(&mutex);
        if (num_ports >= MAX_PORTS) {
            pthread_mutex_unlock(&mutex);
            break;
        }
        ports[num_ports++] = i;
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

int main() {
    int num_threads = 4;
    pthread_t threads[num_threads];

    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, scan_ports, (void *) &i);
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    printf(""Found %d open ports:\n"", num_ports);
    for (int i = 0; i < num_ports; i++) {
        printf(""%d\n"", ports[i]);
    }

    return 0;
}",54,4.0
VULNERABLE,falcon180b-49845.c,yes,18,5,handle_client,"
  file falcon180b-49845.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket = -1;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_port = 8080;
    struct sockaddr_in server_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", server_port);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",85,5.0
VULNERABLE,falcon180b-63538.c,yes,20,5,handle_client,"
  file falcon180b-63538.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System administration ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <signal.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

void signal_handler(int signum) {
    for (int i = 0; i < num_clients; i++) {
        close(clients[i][0]);
        close(clients[i][1]);
    }

    exit(0);
}

int main() {
    signal(SIGINT, signal_handler);

    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",82,2.667
VULNERABLE,falcon180b-4505.c,yes,21,5,handle_client,"
  file falcon180b-4505.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    printf(""Client connected: %d\n"", client_socket);

    while(1) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    printf(""Client connected: %d\n"", client_socket);

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Received message from client %d: %s\n"", client_socket, buffer);

        for(int i=0; i<num_clients; i++) {
            if(i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    printf(""Client disconnected: %d\n"", client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full."", strlen(""Server is full.""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",77,4.0
VULNERABLE,falcon180b-4300.c,yes,22,5,handle_client,"
  file falcon180b-4300.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BUF_SIZE 1024
#define MAX_CLIENTS 10
#define DELAY 50

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        socklen_t client_size = sizeof(clients[0]);
        int client_socket = accept(server_socket, (struct sockaddr *) &clients[num_clients], &client_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full. Cannot accept more clients.\n"");
            continue;
        }

        num_clients++;
        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",82,3.0
VULNERABLE,gemini_pro-24003.c,yes,30,9,printHash,"
  file gemini_pro-24003.c line 30 column 9 function printHash
","
  c:@F@printHash at file gemini_pro-24003.c line 49 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `hash'",dereference failure: accessed expired variable pointer,"}

// Function to print the MD5 hash of a string
void printHash(unsigned char *hash) {
    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {
        printf(""%02x"", hash[i]);
    }
    printf(""\n"");
}

int main() {","//GEMINI-pro DATASET v1.0 Category: Cryptographic hash function ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/md5.h>

// Function to convert a string to lowercase
char *toLower(char *str) {
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] >= 'A' && str[i] <= 'Z') {
            str[i] += 32;
        }
    }
    return str;
}

// Function to calculate the MD5 hash of a string
unsigned char *md5(char *str) {
    unsigned char hash[MD5_DIGEST_LENGTH];
    MD5_CTX ctx;
    MD5_Init(&ctx);
    MD5_Update(&ctx, str, strlen(str));
    MD5_Final(hash, &ctx);
    return hash;
}

// Function to print the MD5 hash of a string
void printHash(unsigned char *hash) {
    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {
        printf(""%02x"", hash[i]);
    }
    printf(""\n"");
}

int main() {
    // Get the input string from the user
    char str[100];
    printf(""Enter a string: "");
    scanf(""%s"", str);

    // Convert the input string to lowercase
    toLower(str);

    // Calculate the MD5 hash of the input string
    unsigned char *hash = md5(str);

    // Print the MD5 hash of the input string
    printf(""MD5 hash: "");
    printHash(hash);

    return 0;
}",52,2.0
VULNERABLE,gpt35-30024.c,yes,103,13,main,"
  file gpt35-30024.c line 103 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `email_address'",dereference failure: accessed expired variable pointer,"            scanf(""%s"", email_address);
            add_email(&mailing_list, name, email_address);
            break;
        case 2:
            printf(""Enter email address to delete: "");
            scanf(""%s"", email_address);
            delete_email(&mailing_list, email_address);
            break;
        case 3:
            display_emails(mailing_list);
            break;","//FormAI DATASET v1.0 Category: Mailing list manager ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to store email addresses
typedef struct email {
    char name[50];
    char email_address[100];
    struct email *next;
} email_t;

// Function to add a new email to the mailing list
void add_email(email_t **mailing_list, char *name, char *email_address) {
    // Allocate memory for new email
    email_t *new_email = (email_t *)malloc(sizeof(email_t));
    if (new_email == NULL) {
        printf(""Error: Could not allocate memory for new email.\n"");
        return;
    }
    // Copy data into new email
    strcpy(new_email->name, name);
    strcpy(new_email->email_address, email_address);
    // Set next as NULL for now
    new_email->next = NULL;
    // If mailing list is empty, set new email as first element
    if (*mailing_list == NULL) {
        *mailing_list = new_email;
    }
    // Otherwise, find last element and set its next as new email
    else {
        email_t *current = *mailing_list;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_email;
    }
    printf(""Email address added to mailing list.\n"");
}

// Function to delete an email from the mailing list
void delete_email(email_t **mailing_list, char *email_address) {
    // If mailing list is empty, do nothing
    if (*mailing_list == NULL) {
        printf(""Mailing list is empty.\n"");
        return;
    }
    // If first email matches, delete it
    if (strcmp((*mailing_list)->email_address, email_address) == 0) {
        email_t *temp = *mailing_list;
        *mailing_list = (*mailing_list)->next;
        free(temp);
        printf(""%s has been removed from the mailing list.\n"", email_address);
        return;
    }
    // Otherwise, find the email and delete it
    email_t *current = *mailing_list;
    email_t *previous = NULL;
    while (current != NULL && strcmp(current->email_address, email_address) != 0) {
        previous = current;
        current = current->next;
    }
    if (current == NULL) {
        printf(""%s was not found in the mailing list.\n"", email_address);
        return;
    }
    previous->next = current->next;
    free(current);
    printf(""%s has been removed from the mailing list.\n"", email_address);
}

// Function to display all emails in the mailing list
void display_emails(email_t *mailing_list) {
    // If mailing list is empty, do nothing
    if (mailing_list == NULL) {
        printf(""Mailing list is empty.\n"");
        return;
    }
    printf(""Mailing list:\n"");
    while (mailing_list != NULL) {
        printf(""%s <%s>\n"", mailing_list->name, mailing_list->email_address);
        mailing_list = mailing_list->next;
    }
}

int main() {
    email_t *mailing_list = NULL;
    int choice;
    while (1) {
        printf(""\nMenu:\n1. Add email address\n2. Delete email address\n3. Display all emails\n4. Exit\nEnter your choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
        case 1:
            printf(""Enter name: "");
            char name[50], email_address[100];
            scanf(""%s"", name);
            printf(""Enter email address: "");
            scanf(""%s"", email_address);
            add_email(&mailing_list, name, email_address);
            break;
        case 2:
            printf(""Enter email address to delete: "");
            scanf(""%s"", email_address);
            delete_email(&mailing_list, email_address);
            break;
        case 3:
            display_emails(mailing_list);
            break;
        case 4:
            printf(""Exiting.\n"");
            exit(0);
        default:
            printf(""Invalid choice.\n"");
        }
    }
    return 0;
}",117,4.75
VULNERABLE,falcon180b-14726.c,yes,15,5,handle_client,"
  file falcon180b-14726.c line 15 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#define PORT 25
#define MAX_CLIENTS 3
#define BUFFER_SIZE 1024

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Building a SMTP Client ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 25
#define MAX_CLIENTS 3
#define BUFFER_SIZE 1024

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    pthread_exit(NULL);
}

void accept_connections(int server_socket) {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_len);

        if (client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket < 0) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections(server_socket);

    close(server_socket);
    return 0;
}",78,3.333
VULNERABLE,falcon180b-29934.c,yes,19,5,handle_client,"
  file falcon180b-29934.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);

    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 14, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    accept_connections();

    return 0;
}",80,3.0
VULNERABLE,falcon180b-28048.c,yes,19,5,handle_client,"
  file falcon180b-28048.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8000
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""%s\n"", buffer);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }
        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",75,5.0
VULNERABLE,gpt35-29447.c,yes,65,5,connection_handler,"
  file gpt35-29447.c line 65 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *connection_handler(void *args) {
    int client_fd = *(int *)args;
    char buffer[1024] = { 0 };
    char *welcome_message = ""Welcome to my server!\n"";
    int valread;

    send(client_fd, welcome_message, strlen(welcome_message), 0);","//FormAI DATASET v1.0 Category: Networking ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT 8080

void *connection_handler(void *);

int main(int argc, char *argv[]) {
    int server_fd, client_fd;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    if((server_fd = socket(AF_INET, SOCK_STREAM, 0)) <= 0) {
        perror(""socket creation failed"");
        exit(EXIT_FAILURE);
    }

    if(setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt error"");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if(bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    if(listen(server_fd, 3) < 0) {
        perror(""listen error"");
        exit(EXIT_FAILURE);
    }

    puts(""waiting for connections..."");

    while(client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) {
        puts(""connection accepted"");

        pthread_t thread_id;

        if(pthread_create(&thread_id, NULL, connection_handler, (void *)&client_fd) < 0) {
            perror(""could not create thread"");
            exit(EXIT_FAILURE);
        }
    }

    if(client_fd < 0) {
        perror(""accept error"");
        exit(EXIT_FAILURE);
    }

    return 0;
}

void *connection_handler(void *args) {
    int client_fd = *(int *)args;
    char buffer[1024] = { 0 };
    char *welcome_message = ""Welcome to my server!\n"";
    int valread;

    send(client_fd, welcome_message, strlen(welcome_message), 0);

    while((valread = read(client_fd, buffer, 1024)) > 0) {
        send(client_fd, buffer, strlen(buffer), 0);
        memset(buffer, 0, sizeof(buffer));
    }

    puts(""client disconnected"");

    return 0;
}",80,5.0
VULNERABLE,falcon180b-28673.c,yes,19,5,handle_client,"
  file falcon180b-28673.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int g_client_sockets[MAX_CLIENTS];
int g_num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        if (recv(client_socket, buffer, BUFFER_SIZE, 0) <= 0) {","//Falcon-180B DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int g_client_sockets[MAX_CLIENTS];
int g_num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        if (recv(client_socket, buffer, BUFFER_SIZE, 0) <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket;
    int opt = 1;
    struct sockaddr_in server_addr;
    int addrlen = sizeof(server_addr);

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        printf(""Socket creation failed\n"");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        printf(""setsockopt() failed\n"");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Bind failed\n"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Listen failed\n"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket;
        socklen_t client_size;

        if ((client_socket = accept(server_socket, (struct sockaddr *)&server_addr, &client_size)) < 0) {
            printf(""Accept failed\n"");
            exit(EXIT_FAILURE);
        }

        printf(""Client connected on socket %d\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        g_client_sockets[g_num_clients++] = client_socket;
    }

    return 0;
}",85,5.0
VULNERABLE,falcon180b-2219.c,yes,19,5,handle_client,"
  file falcon180b-2219.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    char buffer[BUFFER_SIZE];
    int client_socket_copy = *((int *) client_socket);

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    char buffer[BUFFER_SIZE];
    int client_socket_copy = *((int *) client_socket);

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);

        for(int i = 0; i < num_clients; i++) {
            if(clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket_copy);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if(client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 11, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",76,4.5
VULNERABLE,gemini_pro-31523.c,yes,54,3,thread_function,"
  file gemini_pro-31523.c line 54 column 3 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"}

// Define the function to be executed by each thread
void *thread_function(void *arg) {
  // Get the index of the thread
  int index = *(int *)arg;

  // Lock the mutex
  pthread_mutex_lock(&mutex);

  // Wait for the shared data to be ready","//GEMINI-pro DATASET v1.0 Category: Natural Language Date Converter ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>

// Define the number of threads to use
#define NUM_THREADS 4

// Define the structure to hold the date information
typedef struct {
  int year;
  int month;
  int day;
} Date;

// Define the mutex to protect the shared data
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Define the condition variable to signal when the shared data is ready
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Define the array of dates to convert
Date dates[] = {
  {2020, 1, 1},
  {2020, 2, 1},
  {2020, 3, 1},
  {2020, 4, 1},
  {2020, 5, 1},
  {2020, 6, 1},
  {2020, 7, 1},
  {2020, 8, 1},
  {2020, 9, 1},
  {2020, 10, 1},
  {2020, 11, 1},
  {2020, 12, 1}
};

// Define the function to convert a date to a string
char *convert_date(Date *date) {
  // Allocate memory for the string
  char *string = malloc(11);

  // Convert the date to a string
  sprintf(string, ""%d-%02d-%02d"", date->year, date->month, date->day);

  // Return the string
  return string;
}

// Define the function to be executed by each thread
void *thread_function(void *arg) {
  // Get the index of the thread
  int index = *(int *)arg;

  // Lock the mutex
  pthread_mutex_lock(&mutex);

  // Wait for the shared data to be ready
  pthread_cond_wait(&cond, &mutex);

  // Convert the date
  char *string = convert_date(&dates[index]);

  // Unlock the mutex
  pthread_mutex_unlock(&mutex);

  // Print the converted date
  printf(""%s\n"", string);

  // Free the memory allocated for the string
  free(string);

  // Return NULL
  return NULL;
}

// Define the main function
int main() {
  // Create an array of thread IDs
  pthread_t threads[NUM_THREADS];

  // Create the threads
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_create(&threads[i], NULL, thread_function, (void *)&i);
  }

  // Lock the mutex
  pthread_mutex_lock(&mutex);

  // Signal that the shared data is ready
  pthread_cond_broadcast(&cond);

  // Unlock the mutex
  pthread_mutex_unlock(&mutex);

  // Join the threads
  for (int i = 0; i < NUM_THREADS; i++) {
    pthread_join(threads[i], NULL);
  }

  // Destroy the mutex and condition variable
  pthread_mutex_destroy(&mutex);
  pthread_cond_destroy(&cond);

  // Return 0
  return 0;
}",108,1.667
VULNERABLE,falcon180b-70941.c,yes,19,5,handle_client,"
  file falcon180b-70941.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[MAX_DATA_SIZE];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_DATA_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[MAX_DATA_SIZE];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(9000);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port 9000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        client_sockets[num_clients++] = client_socket;
    }

    return 0;
}",65,3.0
VULNERABLE,falcon180b-26039.c,yes,24,5,handle_client,"
  file falcon180b-26039.c line 24 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

char *message = ""Hello from the server!"";

void *handle_client(void *client_socket) {
    int client = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: happy
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int server_socket;
struct sockaddr_in server_addr;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

char *message = ""Hello from the server!"";

void *handle_client(void *client_socket) {
    int client = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client, buffer);
    }

    close(client);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        socklen_t client_size = sizeof(client_sockets[num_clients]);
        int client = accept(server_socket, (struct sockaddr *) &client_sockets[num_clients], &client_size);

        if (client < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client);
    }

    return 0;
}",70,3.0
VULNERABLE,falcon180b-30910.c,yes,18,5,handle_client,"
  file falcon180b-30910.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            break;
        }

        printf(""Client connected: %d\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                num_clients++;
                break;
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server listening on port 8080\n"");

    accept_connections(server_socket);

    return 0;
}",95,4.667
VULNERABLE,falcon180b-31632.c,yes,20,5,handle_client,"
  file falcon180b-31632.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if(bytes_received <= 0) {
            break;
        }
        char *message = strtok(buffer, "" "");
        while(message!= NULL) {
            send(client_socket, message, strlen(message), 0);
            message = strtok(NULL, "" "");
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if(listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Chat server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if(client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if(num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",79,5.5
VULNERABLE,gemini_pro-8939.c,yes,23,5,handle_client,"
  file gemini_pro-8939.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"    double heading;
} GPSData;

// Function to handle client connections
void *handle_client(void *arg) {
    int client_sock = *(int *)arg;
    char buffer[BUFFER_SIZE];
    GPSData gps_data;

    // Receive the GPS data from the client
    recv(client_sock, &gps_data, sizeof(GPSData), 0);","//GEMINI-pro DATASET v1.0 Category: GPS Navigation Simulation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define SERVER_PORT 5000
#define BUFFER_SIZE 1024

// Structure to store the GPS data
typedef struct {
    double latitude;
    double longitude;
    double altitude;
    double speed;
    double heading;
} GPSData;

// Function to handle client connections
void *handle_client(void *arg) {
    int client_sock = *(int *)arg;
    char buffer[BUFFER_SIZE];
    GPSData gps_data;

    // Receive the GPS data from the client
    recv(client_sock, &gps_data, sizeof(GPSData), 0);

    // Print the GPS data to the console
    printf(""Received GPS data: latitude = %.6f, longitude = %.6f, altitude = %.2f, speed = %.2f, heading = %.2f\n"",
           gps_data.latitude, gps_data.longitude, gps_data.altitude, gps_data.speed, gps_data.heading);

    // Send a confirmation message to the client
    strcpy(buffer, ""GPS data received"");
    send(client_sock, buffer, strlen(buffer), 0);

    // Close the client socket
    close(client_sock);
    return NULL;
}

int main() {
    // Create a server socket
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        perror(""Error creating server socket"");
        return EXIT_FAILURE;
    }

    // Bind the server socket to the specified port
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(SERVER_PORT);
    if (bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""Error binding server socket"");
        close(server_sock);
        return EXIT_FAILURE;
    }

    // Listen for incoming client connections
    if (listen(server_sock, 5) == -1) {
        perror(""Error listening for client connections"");
        close(server_sock);
        return EXIT_FAILURE;
    }

    while (1) {
        // Accept an incoming client connection
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &client_addr_len);
        if (client_sock == -1) {
            perror(""Error accepting client connection"");
            continue;
        }

        // Create a new thread to handle the client connection
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, (void *)&client_sock) != 0) {
            perror(""Error creating thread"");
            close(client_sock);
            continue;
        }
    }

    // Close the server socket
    close(server_sock);
    return EXIT_SUCCESS;
}",92,4.0
VULNERABLE,falcon180b-3238.c,yes,20,5,handle_client,"
  file falcon180b-3238.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_server_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int g_server_socket;
int g_client_sockets[MAX_CLIENTS];
int g_num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(g_server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(g_server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(g_server_socket, MAX_CLIENTS);

    printf(""Server is running on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(g_server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (g_num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
            continue;
        }

        g_client_sockets[g_num_clients] = client_socket;
        g_num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,3.0
VULNERABLE,falcon180b-54469.c,yes,20,5,handle_client,"
  file falcon180b-54469.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < client_count; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(3000);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_count >= MAX_CLIENTS) {
            printf(""Max clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[client_count] = client_socket;
        client_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-17294.c,yes,19,5,handle_client,"
  file falcon180b-17294.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
int client_socks[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_sock, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUF_SIZE 1024

int client_socks[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_sock = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_sock, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_sock);
            client_socks[num_clients - 1] = -1;
            num_clients--;
            break;
        }

        printf(""Client %d sent: %s\n"", client_sock, buffer);
        send(client_sock, buffer, strlen(buffer), 0);
    }

    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_sock, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_sock = accept(server_sock, NULL, NULL);

        if (client_sock == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_sock);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_socks[num_clients] = client_sock;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
    }

    return 0;
}",88,5.0
VULNERABLE,falcon180b-29517.c,yes,19,5,handle_client,"
  file falcon180b-29517.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (fgets(buffer, BUFFER_SIZE, stdin)) {
        send(client_socket, buffer, strlen(buffer), 0);
    }","//Falcon-180B DATASET v1.0 Category: Chess AI ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (fgets(buffer, BUFFER_SIZE, stdin)) {
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr, client_addr;
    int addrlen = sizeof(client_addr);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr))) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS)) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port 8080\n"");

    while (1) {
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        if (num_clients == MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;
        pthread_create(&threads[num_clients - 1], NULL, handle_client, &client_socket);
    }

    return 0;
}",78,4.5
VULNERABLE,gpt35-72462.c,yes,83,5,handle_client,"
  file gpt35-72462.c line 83 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket_id'",dereference failure: accessed expired variable pointer,"    }
    send(socket_id, buffer, strlen(buffer), 0);
}

void* handle_client(void* client_socket_id) {
    int socket_id = *(int*)client_socket_id;
    User user;
    user.id = user_count;
    strcpy(user.name, ""Unknown"");
    user.active_chatroom = -1;
    user.socket_id = socket_id;","//FormAI DATASET v1.0 Category: Chat server ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CHATROOMS 10
#define MAX_USERS 100
#define BUFFER_SIZE 1024

typedef struct {
    int id;
    char name[20];
    int active_chatroom;
    int socket_id;
    int is_admin;
} User;

typedef struct {
    int id;
    char name[20];
    int user_count;
    User users[MAX_USERS];
} Chatroom;

Chatroom chatrooms[MAX_CHATROOMS];
int chatroom_count = 0;
int user_count = 0;

void add_user(User user) {
    chatrooms[user.active_chatroom].users[chatrooms[user.active_chatroom].user_count] = user;
    chatrooms[user.active_chatroom].user_count++;
    user_count++;
}

void remove_user(User user) {
    for (int i = 0; i < chatrooms[user.active_chatroom].user_count; i++) {
        if (chatrooms[user.active_chatroom].users[i].id == user.id) {
            chatrooms[user.active_chatroom].users[i] = chatrooms[user.active_chatroom].users[chatrooms[user.active_chatroom].user_count - 1];
            chatrooms[user.active_chatroom].user_count--;
            user_count--;
            return;
        }
    }
}

void send_to_chatroom(int chatroom_id, char* message, int sender_id) {
    for (int i = 0; i < chatrooms[chatroom_id].user_count; i++) {
        if (chatrooms[chatroom_id].users[i].id != sender_id) {
            send(chatrooms[chatroom_id].users[i].socket_id, message, strlen(message), 0);
        }
    }
}

void send_to_user(User user, char* message) {
    send(user.socket_id, message, strlen(message), 0);
}

void list_chatrooms(int socket_id) {
    char buffer[BUFFER_SIZE] = ""Available chatrooms:\n"";
    for (int i = 0; i < chatroom_count; i++) {
        char chatroom_info[50];
        sprintf(chatroom_info, ""%d. %s (%d users)\n"", chatrooms[i].id, chatrooms[i].name, chatrooms[i].user_count);
        strcat(buffer, chatroom_info);
    }
    send(socket_id, buffer, strlen(buffer), 0);
}

void list_users(int chatroom_id, int socket_id) {
    char buffer[BUFFER_SIZE] = ""Users in chatroom:\n"";
    for (int i = 0; i < chatrooms[chatroom_id].user_count; i++) {
        char user_info[50];
        sprintf(user_info, ""%s%s\n"", chatrooms[chatroom_id].users[i].name, chatrooms[chatroom_id].users[i].is_admin ? "" (admin)"" : """");
        strcat(buffer, user_info);
    }
    send(socket_id, buffer, strlen(buffer), 0);
}

void* handle_client(void* client_socket_id) {
    int socket_id = *(int*)client_socket_id;
    User user;
    user.id = user_count;
    strcpy(user.name, ""Unknown"");
    user.active_chatroom = -1;
    user.socket_id = socket_id;
    user.is_admin = 0;

    add_user(user);
    char buffer[BUFFER_SIZE];

    char welcome_message[BUFFER_SIZE] = ""Welcome to the chat server!\n"";
    send(socket_id, welcome_message, strlen(welcome_message), 0);

    while (1) {
        recv(socket_id, buffer, BUFFER_SIZE, 0); // receive message from client
        char* message = strtok(buffer, ""\n"");

        if (strcmp(message, ""/list"") == 0) {
            list_chatrooms(socket_id);
        }
        else if (strncmp(message, ""/join "", 6) == 0) {
            int chatroom_id = atoi(message + 6);
            if (chatroom_id < 0 || chatroom_id >= chatroom_count) {
                send_to_user(user, ""Invalid chatroom ID."");
            }
            else {
                char join_message[BUFFER_SIZE];
                sprintf(join_message, ""%s has joined the chat.\n"", user.name);
                send_to_chatroom(user.active_chatroom, join_message, user.id);
                remove_user(user);
                user.active_chatroom = chatroom_id;
                add_user(user);
                char joined_message[BUFFER_SIZE];
                sprintf(joined_message, ""You have joined chatroom %s.\n"", chatrooms[chatroom_id].name);
                send_to_user(user, joined_message);
            }
        }
        else if (strncmp(message, ""/name "", 6) == 0) {
            strcpy(user.name, message + 6);
            char name_set_message[BUFFER_SIZE];
            sprintf(name_set_message, ""Your name is now %s.\n"", user.name);
            send_to_user(user, name_set_message);
        }
        else if (strncmp(message, ""/kick "", 6) == 0 && user.is_admin) {
            int kicked_user_id = atoi(message + 6);
            if (kicked_user_id < 0 || kicked_user_id >= chatrooms[user.active_chatroom].user_count) {
                send_to_user(user, ""Invalid user ID."");
            }
            else {
                User kicked_user = chatrooms[user.active_chatroom].users[kicked_user_id];
                char kick_message[BUFFER_SIZE];
                sprintf(kick_message, ""%s has been kicked from the chat.\n"", kicked_user.name);
                send_to_chatroom(user.active_chatroom, kick_message, user.id);
                remove_user(kicked_user);
                close(kicked_user.socket_id);
            }
        }
        else if (strcmp(message, ""/users"") == 0) {
            list_users(user.active_chatroom, socket_id);
        }
        else if (strcmp(message, ""/quit"") == 0) {
            char quit_message[BUFFER_SIZE];
            sprintf(quit_message, ""%s has left the chat.\n"", user.name);
            send_to_chatroom(user.active_chatroom, quit_message, user.id);
            remove_user(user);
            close(socket_id);
            pthread_exit(NULL);
        }
        else {
            char formatted_message[BUFFER_SIZE];
            sprintf(formatted_message, ""[%s]: %s\n"", user.name, message);
            send_to_chatroom(user.active_chatroom, formatted_message, user.id);
        }

        memset(buffer, 0, BUFFER_SIZE); // reset buffer
    }

    return NULL;
}

int main(int argc, char** argv) {
    int server_socket_id = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket_id < 0) {
        perror(""Could not create socket"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(8080);
    server_address.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket_id, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {
        perror(""Could not bind socket"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket_id, 10) < 0) {
        perror(""Could not listen on socket"");
        exit(EXIT_FAILURE);
    }

    while (1) {
        printf(""Waiting for incoming connections...\n"");

        struct sockaddr_in client_address;
        socklen_t client_address_size = sizeof(client_address);
        int client_socket_id = accept(server_socket_id, (struct sockaddr*)&client_address, &client_address_size);

        if (client_socket_id < 0) {
            perror(""Could not accept connection"");
            exit(EXIT_FAILURE);
        }

        pthread_t tid;
        pthread_create(&tid, NULL, handle_client, &client_socket_id);
    }

    close(server_socket_id);
    return 0;
}",204,4.0
VULNERABLE,gpt35-11006.c,yes,18,5,client_handler,"
  file gpt35-11006.c line 18 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t mutex;

void *client_handler(void *arg) {
    int sock_fd = *(int *)arg;
    char buffer[1024];
    while (1) {
        int len = read(sock_fd, buffer, 1024);
        if (len <= 0) break;
        buffer[len] = '\0';","//FormAI DATASET v1.0 Category: TCP/IP Programming ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8888
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t mutex;

void *client_handler(void *arg) {
    int sock_fd = *(int *)arg;
    char buffer[1024];
    while (1) {
        int len = read(sock_fd, buffer, 1024);
        if (len <= 0) break;
        buffer[len] = '\0';
        printf(""Client %d: %s"", sock_fd, buffer);
        pthread_mutex_lock(&mutex);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i] != sock_fd) {
                write(clients[i], buffer, strlen(buffer));
            }
        }
        pthread_mutex_unlock(&mutex);
    }
    pthread_mutex_lock(&mutex);
    for (int i = 0; i < num_clients; i++) {
        if (clients[i] == sock_fd) {
            for (int j = i+1; j < num_clients; j++) {
                clients[j-1] = clients[j];
            }
            num_clients--;
            break;
        }
    }
    close(sock_fd);
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    int server_fd;
    struct sockaddr_in addr;

    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(PORT);

    if (bind(server_fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 5) < 0) {
        perror(""listen failed"");
        exit(EXIT_FAILURE);
    }

    printf(""Server started listening on port %d!\n"", PORT);

    while (1) {
        int client_fd;
        pthread_t thread;

        if ((client_fd = accept(server_fd, NULL, NULL)) < 0) {
            perror(""accept failed"");
            exit(EXIT_FAILURE);
        }

        pthread_mutex_lock(&mutex);
        if (num_clients >= MAX_CLIENTS) {
            printf(""Client %d denied: maximum clients reached!\n"", client_fd);
            close(client_fd);
        } else {
            printf(""Client %d connected!\n"", client_fd);
            clients[num_clients++] = client_fd;
            pthread_create(&thread, NULL, client_handler, (void *)&client_fd);
            pthread_detach(thread);
        }
        pthread_mutex_unlock(&mutex);
    }

    close(server_fd);
    return 0;
}",98,7.5
VULNERABLE,falcon180b-4163.c,yes,21,5,handle_client,"
  file falcon180b-4163.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket_copy);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, BACKLOG);

    printf(""Romeo: The server is running on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            printf(""Romeo: Client %d connected\n"", num_clients - 1);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-70339.c,yes,18,5,thread_handler,"
  file falcon180b-70339.c line 18 column 5 function thread_handler
","
  c:@F@thread_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_handler(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *thread_handler(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            close(client_socket);
            break;
        }

        for(int i=0; i<num_clients; i++) {
            if(clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Chat server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server full\n"", 12, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, thread_handler, (void *) &client_socket);
    }

    return 0;
}",69,4.0
VULNERABLE,falcon180b-47014.c,yes,28,5,handle_client,"
  file falcon180b-47014.c line 28 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    }
    pthread_mutex_unlock(&lock);
}

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(sock, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Interprocess communication ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void broadcast(int socket, char *message) {
    pthread_mutex_lock(&lock);
    for (int i = 0; i < num_clients; i++) {
        if (client_sockets[i]!= socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
    pthread_mutex_unlock(&lock);
}

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUF_SIZE];

    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(sock, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        broadcast(sock, buffer);
    }

    close(sock);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        pthread_mutex_lock(&lock);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i] == 0) {
                client_sockets[i] = client_socket;
                num_clients++;
                break;
            }
        }
        pthread_mutex_unlock(&lock);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",77,3.333
VULNERABLE,falcon180b-10213.c,yes,19,5,handle_client,"
  file falcon180b-10213.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", sock, buffer);

        for(int i = 0; i < num_clients; i++) {
            if(clients[i]!= sock) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(sock);

    return NULL;
}

int main(int argc, char *argv[]) {
    int master_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(master_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(master_socket, BACKLOG);

    printf(""Server is listening on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(master_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 60, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-24877.c,yes,17,5,handle_client,"
  file falcon180b-24877.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Performance-Critical Component ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received == 0) {
            close(client_socket);
            pthread_exit(0);
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(5000);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port 5000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",76,3.667
VULNERABLE,falcon180b-5324.c,yes,19,5,handle_client,"
  file falcon180b-5324.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *client_socket) {
    int client = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Subnet Calculator ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *client_socket) {
    int client = *(int *) client_socket;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client);
            pthread_exit(NULL);
        }

        printf(""Client %d sent message: %s\n"", client, buffer);
    }
}

void accept_clients() {
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        printf(""Client %d connected\n"", client);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client);
        num_clients++;
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port 8080\n"");

    accept_clients();

    return 0;
}",71,2.333
VULNERABLE,falcon180b-65761.c,yes,19,5,handle_client,"
  file falcon180b-65761.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d said: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",86,5.0
VULNERABLE,falcon180b-25308.c,yes,17,5,handle_client,"
  file falcon180b-25308.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int g_client_sockets[MAX_CLIENTS] = {0};
int g_client_count = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Browser Plugin ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_client_sockets[MAX_CLIENTS] = {0};
int g_client_count = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < g_client_count; i++) {
            if (g_client_sockets[i]!= client_socket) {
                send(g_client_sockets[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        for (int i = 0; i < MAX_CLIENTS; i++) {
            if (g_client_sockets[i] == 0) {
                g_client_sockets[i] = client_socket;
                g_client_count++;
                printf(""Client %d connected\n"", client_socket);
                pthread_t thread_id;
                pthread_create(&thread_id, NULL, handle_client, (void*) &client_socket);
                break;
            }
        }
    }

    close(server_socket);
    return 0;
}",71,4.5
VULNERABLE,falcon180b-29931.c,yes,27,9,handle_client,"
  file falcon180b-29931.c line 27 column 9 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(socket_desc, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", *(int *)socket_desc, buffer);
    }
    close(socket_desc);
    num_clients--;
}
","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(socket_desc, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", *(int *)socket_desc, buffer);
    }
    close(socket_desc);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }
        client_sockets[num_clients] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        num_clients++;
    }
    return 0;
}",54,3.5
VULNERABLE,falcon180b-32662.c,yes,18,5,handle_client,"
  file falcon180b-32662.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_server_socket = -1;
int g_client_sockets[MAX_CLIENTS] = { -1 };
pthread_t g_client_threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_server_socket = -1;
int g_client_sockets[MAX_CLIENTS] = { -1 };
pthread_t g_client_threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        int i;
        for (i = 0; i < MAX_CLIENTS; i++) {
            if (g_client_sockets[i] == -1) {
                g_client_sockets[i] = client_socket;
                pthread_create(&g_client_threads[i], NULL, handle_client, (void *)&client_socket);
                break;
            }
        }

        if (i == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
        }
    }

    return 0;
}",74,4.5
VULNERABLE,falcon180b-66629.c,yes,17,5,handle_client,"
  file falcon180b-66629.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d: %s\n"", client_socket, buffer);
        for (int i = 0; i < client_count; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket!= -1) {
            printf(""Client connected: %d\n"", client_socket);
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",56,4.0
VULNERABLE,falcon180b-34302.c,yes,19,5,handle_client,"
  file falcon180b-34302.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket_copy);
            clients[--num_clients] = 0;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);
        send(client_socket_copy, buffer, strlen(buffer), 0);
    }

    return NULL;
}

int main(int argc, char **argv) {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.0
VULNERABLE,gpt35-73780.c,yes,82,5,handle_client,"
  file gpt35-73780.c line 82 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *handle_client(void *arg)
{
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE] = {0};
    FILE *file;
    char *filename;
    char *filetype;
    int fd;","//FormAI DATASET v1.0 Category: Simple Web Server ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#define PORT 8080
#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10

void *handle_client(void *);

int main(int argc, char const *argv[])
{
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};

    // Create socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror(""Socket failed"");
        exit(EXIT_FAILURE);
    }

    // Set socket options
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)))
    {
        perror(""setsockopt failed"");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind socket to PORT
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        perror(""Bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, MAX_CLIENTS) < 0)
    {
        perror(""Listen failed"");
        exit(EXIT_FAILURE);
    }

    // Accept incoming connections, handle in another thread
    int client_socket;
    pthread_t thread_id;
    while ((client_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)))
    {
        if (pthread_create(&thread_id, NULL, handle_client, &client_socket) < 0)
        {
            perror(""Thread creation failed"");
            exit(EXIT_FAILURE);
        }
    }

    if (client_socket < 0)
    {
        perror(""Accept failed"");
        exit(EXIT_FAILURE);
    }

    return 0;
}

void *handle_client(void *arg)
{
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE] = {0};
    FILE *file;
    char *filename;
    char *filetype;
    int fd;
    struct stat stat_buf;
    int ret;

    // Read request from client
    if (read(client_socket, buffer, BUFFER_SIZE) <= 0)
    {
        perror(""Read failed"");
        exit(EXIT_FAILURE);
    }

    // Get filename from request
    strtok(buffer, "" "");
    filename = strtok(NULL, "" "");
    filetype = strchr(filename, '.') + 1;

    // Open file for reading, send error message if file not found
    if ((fd = open(filename, O_RDONLY)) == -1)
    {
        sprintf(buffer, ""HTTP/1.1 404 Not Found\r\nContent-Type: text/html\r\n\r\n<html><body><h1>File not found</h1></body></html>"");
        if (send(client_socket, buffer, strlen(buffer), 0) < 0)
        {
            perror(""Send failed"");
            exit(EXIT_FAILURE);
        }
        close(client_socket);
        pthread_exit(NULL);
    }

    // Get file size and send HTTP response header
    fstat(fd, &stat_buf);
    sprintf(buffer, ""HTTP/1.1 200 OK\r\nContent-Type: text/%s\r\nContent-Length: %lu\r\n\r\n"", filetype, stat_buf.st_size);
    if (send(client_socket, buffer, strlen(buffer), 0) < 0)
    {
        perror(""Send failed"");
        exit(EXIT_FAILURE);
    }

    // Send file contents
    while ((ret = read(fd, buffer, BUFFER_SIZE)) > 0)
    {
        if (send(client_socket, buffer, ret, 0) < 0)
        {
            perror(""Send failed"");
            exit(EXIT_FAILURE);
        }
    }

    // Close file and socket, exit thread
    close(fd);
    close(client_socket);
    pthread_exit(NULL);
}",139,7.5
VULNERABLE,falcon180b-26420.c,yes,28,5,handle_client,"
  file falcon180b-26420.c line 28 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"struct sockaddr_in client_addr;

char buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int sock = *(int *) arg;
    char *response = ""HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<html><body><h1>Smart Home Light Control</h1></body></html>"";
    int len = strlen(response);

    send(sock, response, len, 0);
    close(sock);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: paranoid
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int sockfd;
int client_socks[MAX_CLIENTS];
int client_count;

struct sockaddr_in server_addr;
struct sockaddr_in client_addr;

char buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int sock = *(int *) arg;
    char *response = ""HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<html><body><h1>Smart Home Light Control</h1></body></html>"";
    int len = strlen(response);

    send(sock, response, len, 0);
    close(sock);
}

void accept_connections() {
    while(1) {
        socklen_t addr_size = sizeof(client_addr);
        int new_socket = accept(sockfd, (struct sockaddr *) &client_addr, &addr_size);

        if(new_socket == -1) {
            perror(""accept"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &new_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(sockfd, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(sockfd, MAX_CLIENTS);

    accept_connections();

    return 0;
}",65,1.667
VULNERABLE,falcon180b-42239.c,yes,18,5,handle_client,"
  file falcon180b-42239.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_LEN];

    while(1) {
        memset(buffer, 0, MAX_DATA_LEN);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_LEN, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_DATA_LEN 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_LEN];

    while(1) {
        memset(buffer, 0, MAX_DATA_LEN);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_LEN, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for(int i = 0; i < num_clients; i++) {
            if(clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    num_clients--;

    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-64145.c,yes,17,5,handle_client,"
  file falcon180b-64145.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUF_SIZE];
    int bytes_read;

    while ((bytes_read = read(client_socket, buffer, BUF_SIZE)) > 0) {
        printf(""Client %d sent message: %s\n"", client_socket, buffer);","//Falcon-180B DATASET v1.0 Category: Compression algorithms ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUF_SIZE 1024
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUF_SIZE];
    int bytes_read;

    while ((bytes_read = read(client_socket, buffer, BUF_SIZE)) > 0) {
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                write(clients[i], buffer, bytes_read);
            }
        }
    }

    close(client_socket);

    printf(""Client %d disconnected\n"", client_socket);

    return NULL;
}

void broadcast_message(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            write(clients[i], message, strlen(message));
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 41, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",79,3.333
VULNERABLE,falcon180b-62579.c,yes,20,5,handle_client,"
  file falcon180b-62579.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    return NULL;
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        client_sockets[num_clients++] = client_socket;
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port 8080\n"");
    accept_connections();

    return 0;
}",70,2.333
VULNERABLE,gpt35-12636.c,yes,45,5,thread_function,"
  file gpt35-12636.c line 45 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"    exit(EXIT_SUCCESS);
}

void *thread_function(void *arg)
{
    int index = *((int *)arg);
    int random_time = rand() % 5 + 1;

    printf(""Thread %d sleeping for %d second(s)...\n"", index, random_time);
    sleep(random_time);
    printf(""Thread %d woke up after %d second(s).\n"", index, random_time);","//FormAI DATASET v1.0 Category: Threading Library Implementation ; Style: brave
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 5

void *thread_function(void *arg);

int main()
{
    int res;
    pthread_t threads[NUM_THREADS];

    for(int i = 0; i < NUM_THREADS; i++)
    {
        printf(""Creating thread %d\n"", i);
        res = pthread_create(&threads[i], NULL, thread_function, (void *)&i);
        if (res != 0)
        {
            perror(""Thread creation failed"");
            exit(EXIT_FAILURE);
        }
    }

    printf(""All threads created.\n"");

    for (int i = 0; i < NUM_THREADS; i++)
    {
        res = pthread_join(threads[i], NULL);
        if (res != 0)
        {
            perror(""Thread join failed"");
            exit(EXIT_FAILURE);
        }
        printf(""Thread %d joined\n"", i);
    }

    printf(""All threads joined. Program exiting.\n"");
    exit(EXIT_SUCCESS);
}

void *thread_function(void *arg)
{
    int index = *((int *)arg);
    int random_time = rand() % 5 + 1;

    printf(""Thread %d sleeping for %d second(s)...\n"", index, random_time);
    sleep(random_time);
    printf(""Thread %d woke up after %d second(s).\n"", index, random_time);

    pthread_exit(NULL);
}",53,3.0
VULNERABLE,falcon180b-41495.c,yes,37,5,get_process_info,"
  file string.c line 40 column 15 function strncpy
","
  c:@F@strncpy at file falcon180b-41495.c line 37 column 5 function get_process_info
  c:@F@get_process_info at file falcon180b-41495.c line 75 column 15 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `line'",dereference failure: accessed expired variable pointer,"        fclose(fp);
        return -1;
    }

    fclose(fp);
    strncpy(name, (char *)get_process_name(pid), MAX_PROCESS_NAME_LENGTH);

    return 0;
}

int get_process_name(int pid) {","//Falcon-180B DATASET v1.0 Category: RAM usage monitor ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PROCESSES 1024
#define MAX_PROCESS_NAME_LENGTH 64

typedef struct {
    int pid;
    char name[MAX_PROCESS_NAME_LENGTH];
    int ram_usage;
} process_t;

int get_process_info(int pid, char *name, int *ram_usage) {
    FILE *fp;
    char path[64];
    char line[1024];
    int ret;
    
    sprintf(path, ""/proc/%d/statm"", pid);
    
    fp = fopen(path, ""r"");
    if (fp == NULL) {
        return -1;
    }

    fgets(line, sizeof(line), fp);
    ret = sscanf(line, ""%*d %*d %*d %*d %*d %d"", ram_usage);

    if (ret!= 1) {
        fclose(fp);
        return -1;
    }

    fclose(fp);
    strncpy(name, (char *)get_process_name(pid), MAX_PROCESS_NAME_LENGTH);

    return 0;
}

int get_process_name(int pid) {
    char path[64];
    FILE *fp;
    char line[1024];
    
    sprintf(path, ""/proc/%d/cmdline"", pid);

    fp = fopen(path, ""r"");
    if (fp == NULL) {
        return -1;
    }

    fgets(line, sizeof(line), fp);
    strtok(line, ""\0"");
    fclose(fp);

    return (int)line;
}

int main() {
    int i, num_processes, ret;
    process_t *processes;

    num_processes = 0;
    ret = 0;

    processes = (process_t *)malloc(MAX_PROCESSES * sizeof(process_t));
    if (processes == NULL) {
        printf(""Error: failed to allocate memory for process list.\n"");
        return -1;
    }

    for (i = 0; i < MAX_PROCESSES; i++) {
        ret = get_process_info(i, processes[i].name, &processes[i].ram_usage);
        if (ret == 0) {
            num_processes++;
        }
    }

    printf(""Number of processes: %d\n"", num_processes);

    for (i = 0; i < num_processes; i++) {
        printf(""Process %d: %s\n"", processes[i].pid, processes[i].name);
        printf(""RAM usage: %d KB\n"", processes[i].ram_usage);
        printf(""\n"");
    }

    free(processes);

    return 0;
}",92,3.333
VULNERABLE,falcon180b-22110.c,yes,21,5,handle_client,"
  file falcon180b-22110.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int client_count = 0;
int main_thread_id = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int client_count = 0;
int main_thread_id = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        for (int i = 0; i < client_count; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

void handle_client_request(int client_socket) {
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    clients[client_count++] = client_socket;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket!= -1) {
            handle_client_request(client_socket);
        }
    }

    return 0;
}",77,4.0
VULNERABLE,gemini_pro-30999.c,yes,38,5,translate_cat_word,"
  file gemini_pro-30999.c line 38 column 5 function translate_cat_word
","
  c:@F@translate_cat_word at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int cat_word_len;

// Define the thread function
void *translate_cat_word(void *arg) {
    // Get the thread number
    int thread_num = *(int *)arg;

    // Loop through the cat words
    for (int i = thread_num; i < num_cat_words; i += num_threads) {
        // Get the cat word
        cat_word = cat_dict[i];","//GEMINI-pro DATASET v1.0 Category: Cat Language Translator ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

// Define the cat language dictionary
const char *cat_dict[] = {
    ""meow"", ""food"",
    ""purr"", ""happy"",
    ""hiss"", ""angry"",
    ""mew"", ""sad"",
    ""chirp"", ""excited""
};

// Define the number of cat words in the dictionary
const int num_cat_words = sizeof(cat_dict) / sizeof(char *);

// Define the maximum length of a cat word
const int max_cat_word_len = 5;

// Define the number of threads to use
const int num_threads = 4;

// Define the mutex to protect the shared data
pthread_mutex_t mutex;

// Define the condition variable to signal when the shared data is ready
pthread_cond_t cond;

// Define the shared data
char *cat_word;
int cat_word_len;

// Define the thread function
void *translate_cat_word(void *arg) {
    // Get the thread number
    int thread_num = *(int *)arg;

    // Loop through the cat words
    for (int i = thread_num; i < num_cat_words; i += num_threads) {
        // Get the cat word
        cat_word = cat_dict[i];

        // Get the cat word length
        cat_word_len = strlen(cat_word);

        // Lock the mutex
        pthread_mutex_lock(&mutex);

        // Signal that the shared data is ready
        pthread_cond_signal(&cond);

        // Unlock the mutex
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

// Define the main function
int main() {
    // Initialize the mutex and condition variable
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond, NULL);

    // Create the threads
    pthread_t threads[num_threads];
    for (int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, translate_cat_word, (void *)&i);
    }

    // Loop until all the cat words have been translated
    while (1) {
        // Lock the mutex
        pthread_mutex_lock(&mutex);

        // Wait for the shared data to be ready
        pthread_cond_wait(&cond, &mutex);

        // Unlock the mutex
        pthread_mutex_unlock(&mutex);

        // Print the cat word
        printf(""%s\n"", cat_word);

        // Check if all the cat words have been translated
        if (cat_word_len == 0) {
            break;
        }
    }

    // Join the threads
    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destroy the mutex and condition variable
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);

    return 0;
}",103,3.5
VULNERABLE,gpt35-65290.c,yes,131,17,main,"
  file gpt35-65290.c line 131 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `index'",dereference failure: accessed expired variable pointer,"                scanf(""%d"", &index);
                readEmail(index);
                break;
            case 3:
                printf(""Enter email index: "");
                scanf(""%d"", &index);
                deleteEmail(index);
                break;
            case 4:
                exit(0);
            default:","//FormAI DATASET v1.0 Category: Email Client ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_SUBJECT_LENGTH 100
#define MAX_BODY_LENGTH 500

typedef struct email {
    char from[50];
    char to[50];
    char subject[MAX_SUBJECT_LENGTH];
    char body[MAX_BODY_LENGTH];
    bool read;
} Email;

typedef struct node {
    Email data;
    struct node *next;
} Node;

Node *head = NULL;

void addEmail(Email e) {
    Node *newNode = (Node*) malloc(sizeof(Node));
    newNode->data = e;
    newNode->next = NULL;
    if(head == NULL) {
        head = newNode;
    } else {
        Node *currentNode = head;
        while(currentNode->next != NULL) {
            currentNode = currentNode->next;
        }
        currentNode->next = newNode;
    }
}

void listEmails() {
    if(head == NULL) {
        printf(""You have no emails.\n"");
    } else {
        Node *currentNode = head;
        int index = 1;
        while(currentNode != NULL) {
            printf(""%d. %s\n"", index, currentNode->data.subject);
            currentNode = currentNode->next;
            index++;
        }
    }
}

void readEmail(int index) {
    if(head == NULL) {
        printf(""You have no emails.\n"");
    } else {
        int current = 1;
        Node *currentNode = head;
        while(currentNode != NULL && current != index) {
            currentNode = currentNode->next;
            current++;
        }
        if(currentNode == NULL) {
            printf(""Invalid email index.\n"");
        } else {
            printf(""From: %s\n"", currentNode->data.from);
            printf(""To: %s\n"", currentNode->data.to);
            printf(""Subject: %s\n"", currentNode->data.subject);
            printf(""Body: %s\n"", currentNode->data.body);
            currentNode->data.read = true;
        }
    }
}

void deleteEmail(int index) {
    if(head == NULL) {
        printf(""You have no emails.\n"");
    } else {
        int current = 1;
        Node *currentNode = head;
        Node *previousNode = NULL;
        while(currentNode != NULL && current != index) {
            previousNode = currentNode;
            currentNode = currentNode->next;
            current++;
        }
        if(currentNode == NULL) {
            printf(""Invalid email index.\n"");
        } else {
            if(previousNode == NULL) {
                head = currentNode->next;
            } else {
                previousNode->next = currentNode->next;
            }
            free(currentNode);
        }
    }
}

int main() {
    Email e1 = {""john@example.com"", ""jane@example.com"", ""Hello World"", ""This is a test email."", false};
    Email e2 = {""jane@example.com"", ""john@example.com"", ""RE: Hello World"", ""Thanks for the email."", false};
    Email e3 = {""alice@example.com"", ""john@example.com"", ""Meeting Reminder"", ""Don't forget the meeting tomorrow."", false};
    addEmail(e1);
    addEmail(e2);
    addEmail(e3);
    while(true) {
        printf(""\n"");
        printf(""1. List Emails\n"");
        printf(""2. Read Email\n"");
        printf(""3. Delete Email\n"");
        printf(""4. Quit\n"");
        printf(""\n"");
        printf(""Enter your choice: "");
        int choice;
        scanf(""%d"", &choice);
        printf(""\n"");
        switch(choice) {
            case 1:
                listEmails();
                break;
            case 2:
                printf(""Enter email index: "");
                int index;
                scanf(""%d"", &index);
                readEmail(index);
                break;
            case 3:
                printf(""Enter email index: "");
                scanf(""%d"", &index);
                deleteEmail(index);
                break;
            case 4:
                exit(0);
            default:
                printf(""Invalid choice.\n"");
        }
    }
    return 0;
}",141,4.6
VULNERABLE,falcon180b-47393.c,yes,19,5,handle_client,"
  file falcon180b-47393.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 5000
#define BACKLOG 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",86,6.0
VULNERABLE,falcon180b-2600.c,yes,19,5,handle_client,"
  file falcon180b-2600.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-7448.c,yes,18,5,handle_client,"
  file falcon180b-7448.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: File Backup System ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define PORT 8080
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            client_sockets[num_clients] = -1;
            num_clients--;
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,3.5
VULNERABLE,falcon180b-48249.c,yes,19,5,handle_client,"
  file falcon180b-48249.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    char buffer[BUFFER_SIZE];
    int client_socket_fd = *(int *)client_socket;
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    char buffer[BUFFER_SIZE];
    int client_socket_fd = *(int *)client_socket;
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d: %s"", client_socket_fd, buffer);
        send(client_socket_fd, buffer, strlen(buffer), 0);
    }
    close(client_socket_fd);
    return NULL;
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(3000);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Chat server started on port 3000\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 15, 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;
            printf(""Client %d connected.\n"", client_socket);
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    close(server_socket);
    return 0;
}",69,3.0
VULNERABLE,falcon180b-12409.c,yes,27,5,handle_request,"
  file falcon180b-12409.c line 27 column 5 function handle_request
","
  c:@F@handle_request at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
struct client clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_request(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <sys/time.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10

struct client {
    int socket;
    char *ip;
    int port;
};

struct client clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_request(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        for (int i = 0; i < num_clients; i++) {
            if (clients[i].socket!= client_socket) {
                send(clients[i].socket, buffer, bytes_received, 0);
            }
        }
    }
    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""0.0.0.0"", &server_addr.sin_addr);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_size);
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
            continue;
        }
        clients[num_clients].socket = client_socket;
        clients[num_clients].ip = inet_ntoa(client_addr.sin_addr);
        clients[num_clients].port = ntohs(client_addr.sin_port);
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_request, (void *)&client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,gpt35-10672.c,yes,76,5,connection_handler,"
  file gpt35-10672.c line 76 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *connection_handler(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    int read_size;
    char *message, client_message[2000];

    // Send welcome message to client
    message = ""Welcome to the server\n"";","//FormAI DATASET v1.0 Category: Networking ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 5555

int client_count = 0;
int socket_desc;
struct sockaddr_in server_addr;
pthread_mutex_t mutex;

void *connection_handler(void *);

int main(int argc, char *argv[]) {
    // Creating socket
    socket_desc = socket(AF_INET, SOCK_STREAM, 0);

    if (socket_desc == -1) {
        printf(""Could not create socket"");
        return 1;
    }

    // Assigning IP and PORT
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind socket
    if (bind(socket_desc, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Could not bind socket"");
        return 1;
    }
    printf(""Socket successfully bound\n"");

    // Listen for incoming connections
    if (listen(socket_desc, 3) < 0) {
        printf(""Error occurred while listening"");
        return 1;
    }

    printf(""Server listening at port %d\n"", PORT);

    // Accept incoming connections
    struct sockaddr_in client_addr;
    int client_socket;
    pthread_t thread_id;

    while ((client_socket = accept(socket_desc, (struct sockaddr *) &client_addr, (socklen_t *) &client_addr)) ) {
        printf(""Connection accepted\n"");

        pthread_mutex_lock(&mutex);
        client_count++;
        pthread_mutex_unlock(&mutex);

        // Create thread for handling connection
        if (pthread_create(&thread_id, NULL, connection_handler, (void *) &client_socket) < 0) {
            printf(""Could not create thread"");
            return 1;
        }
    }

    if (client_socket < 0) {
        printf(""Error occurred while accepting connection"");
        return 1;
    }

    return 0;
}

void *connection_handler(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    int read_size;
    char *message, client_message[2000];

    // Send welcome message to client
    message = ""Welcome to the server\n"";
    write(client_socket, message, strlen(message));

    while ((read_size = recv(client_socket, client_message, 2000, 0)) > 0) {
        client_message[read_size] = '\0';
        printf(""Client message: %s"", client_message);

        // Send received message back to client
        write(client_socket, client_message, strlen(client_message));

        // Clear buffer
        memset(client_message, 0, sizeof(client_message));
    }

    pthread_mutex_lock(&mutex);
    client_count--;
    pthread_mutex_unlock(&mutex);

    // Close client socket
    close(client_socket);

    pthread_exit(NULL);
}",103,4.5
VULNERABLE,gpt35-51760.c,yes,78,5,packet_handler,"
  file gpt35-51760.c line 78 column 5 function packet_handler
","
  c:@F@packet_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `buffer'",dereference failure: accessed expired variable pointer,"
void *packet_handler(void *arg) {
    char *buffer = (char *) arg;

    // Determine signal strength from packet
    int signal_strength = (int8_t) buffer[22];

    // Lock the counter variable to avoid race condition
    pthread_mutex_lock(&counter_lock);
    counter++;
","//FormAI DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <stdint.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 1337
#define PACKET_SIZE 1024

pthread_mutex_t counter_lock;
int counter;

void *packet_handler(void *arg);

int main(int argc, char const *argv[]) {

    if (argc < 2) {
        printf(""Usage: ./analyzer [INTERFACE]\n"");
        printf(""Example: ./analyzer eth0\n"");
        return -1;
    }

    int sock_fd;
    struct sockaddr_in serv_addr;
    pthread_t thread_id;

    if ((sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
        perror(""socket"");
        return -1;
    }

    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    if (inet_pton(AF_INET, ""127.0.0.1"", &serv_addr.sin_addr) <= 0) {
        perror(""inet_pton"");
        return -1;
    }

    if (bind(sock_fd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        perror(""bind"");
        return -1;
    }

    printf(""[+] Analyzer started on interface: %s\n"", argv[1]);

    while (1) {
        char buffer[PACKET_SIZE];
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);

        int packet_size = recvfrom(sock_fd, buffer, PACKET_SIZE, 0, (struct sockaddr *) &client_addr, &client_addr_len);
        if (packet_size < 0) {
            perror(""recvfrom"");
            continue;
        }

        // Create a new thread to process the packet
        pthread_create(&thread_id, NULL, packet_handler, buffer);
    }
    return 0;
}

void *packet_handler(void *arg) {
    char *buffer = (char *) arg; 

    // Determine signal strength from packet
    int signal_strength = (int8_t) buffer[22];

    // Lock the counter variable to avoid race condition
    pthread_mutex_lock(&counter_lock);
    counter++;

    // Print the counter and signal strength
    printf(""[+] Packet %d: Signal strength: %d dBm\n"", counter, signal_strength);

    // Unlock the counter variable
    pthread_mutex_unlock(&counter_lock);
    return NULL;
}",90,4.0
VULNERABLE,falcon180b-24667.c,yes,20,5,handle_client,"
  file falcon180b-24667.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: active
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        if (strstr(buffer, ""attack"")!= NULL) {
            printf(""Attack detected from client %d\n"", client_socket);
        }
    }
    close(client_socket);
    return NULL;
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        int server_socket = socket(AF_INET, SOCK_STREAM, 0);
        struct sockaddr_in server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(8080);
        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
        listen(server_socket, 5);

        while (1) {
            int client_socket = accept(server_socket, NULL, NULL);
            if (client_socket == -1) {
                printf(""Error accepting connection\n"");
                break;
            }
            printf(""Client %d connected\n"", num_clients);
            client_sockets[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }

        close(server_socket);
    }
}

int main() {
    accept_connections();
    return 0;
}",67,3.0
VULNERABLE,falcon180b-3908.c,yes,20,5,handle_client,"
  file falcon180b-3908.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(client_socket, buffer, BUFFER_SIZE, 0);

        printf(""Client %d said: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", strlen(""Server is full.\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = socket(AF_INET, SOCK_STREAM, 0);

        struct sockaddr_in client_addr;
        memset(&client_addr, 0, sizeof(client_addr));
        client_addr.sin_family = AF_INET;
        client_addr.sin_port = htons(8081);
        client_addr.sin_addr.s_addr = htonl(INADDR_ANY);

        connect(clients[num_clients][1], (struct sockaddr *)&client_addr, sizeof(client_addr));

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);

        num_clients++;
    }

    return 0;
}",81,3.5
VULNERABLE,falcon180b-33536.c,yes,30,9,download_url,"
  file falcon180b-33536.c line 30 column 9 function download_url
","
  c:@F@download_url at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `data'",dereference failure: accessed expired variable pointer,"    curl = curl_easy_init();

    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, data->url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, data->file);

        res = curl_easy_perform(curl);
        if(res!= CURLE_OK) {
            fprintf(stderr, ""Thread %d: Download failed: %s\n"", (int)pthread_self(), curl_easy_strerror(res));
        }","//Falcon-180B DATASET v1.0 Category: Browser Plugin ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <curl/curl.h>

#define MAX_THREADS 10
#define MAX_URL_SIZE 2048

struct thread_data {
    char url[MAX_URL_SIZE];
    FILE *file;
};

size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    return fwrite(ptr, size, nmemb, stream);
}

void *download_url(void *arg) {
    struct thread_data *data = (struct thread_data *)arg;
    CURL *curl;
    CURLcode res;

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, data->url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, data->file);

        res = curl_easy_perform(curl);
        if(res!= CURLE_OK) {
            fprintf(stderr, ""Thread %d: Download failed: %s\n"", (int)pthread_self(), curl_easy_strerror(res));
        }

        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    FILE *input_file;
    char line[MAX_URL_SIZE];
    pthread_t threads[MAX_THREADS];
    int num_threads = 0;

    if(argc < 2) {
        fprintf(stderr, ""Usage: %s <input_file>\n"", argv[0]);
        return 1;
    }

    input_file = fopen(argv[1], ""r"");
    if(!input_file) {
        fprintf(stderr, ""Error opening input file.\n"");
        return 1;
    }

    while(fgets(line, MAX_URL_SIZE, input_file)!= NULL) {
        if(num_threads >= MAX_THREADS) {
            fprintf(stderr, ""Maximum number of threads reached.\n"");
            break;
        }

        struct thread_data data;
        strcpy(data.url, line);
        data.file = input_file;

        pthread_create(&threads[num_threads], NULL, download_url, &data);
        num_threads++;
    }

    for(int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    fclose(input_file);
    return 0;
}",81,3.333
VULNERABLE,gpt35-54214.c,yes,73,5,client_handler,"
  file gpt35-54214.c line 73 column 5 function client_handler
","
  c:@F@client_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *client_handler(void *socket_desc) {
    // Cast socket descriptor to int
    int socket = *(int*)socket_desc;
    char buffer[1024] = {0};
    int bytes_read;

    // Loop to receive and process messages from client
    while ((bytes_read = read(socket, buffer, sizeof(buffer))) > 0) {","//FormAI DATASET v1.0 Category: Chat server ; Style: distributed
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

void *client_handler(void *);

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    pthread_t thread_id;
    
    // Create server socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""Failed to create socket"");
        exit(EXIT_FAILURE);
    }
    
    // Set socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""Failed to set socket options"");
        exit(EXIT_FAILURE);
    }
    
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    
    // Bind server socket
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""Failed to bind socket"");
        exit(EXIT_FAILURE);
    }
    
    // Listen for connections
    if (listen(server_fd, MAX_CLIENTS) < 0) {
        perror(""Failed to listen for connections"");
        exit(EXIT_FAILURE);
    }
    
    printf(""Server started on port %d...\n"", PORT);
    
    // Accept incoming connections
    while ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))) {
        printf(""New client connected: %s:%d\n"", inet_ntoa(address.sin_addr), ntohs(address.sin_port));
        
        // Create a new thread to handle the client connection
        if (pthread_create(&thread_id, NULL, client_handler, (void *)&new_socket) < 0) {
            perror(""Failed to create thread to handle client"");
            exit(EXIT_FAILURE);
        }
        
        // Detach the thread so it can continue running independently
        pthread_detach(thread_id);
    }
    
    return 0;
}

void *client_handler(void *socket_desc) {
    // Cast socket descriptor to int
    int socket = *(int*)socket_desc;
    char buffer[1024] = {0};
    int bytes_read;
    
    // Loop to receive and process messages from client
    while ((bytes_read = read(socket, buffer, sizeof(buffer))) > 0) {
        printf(""Received message from client[%d]: %s\n"", socket, buffer);
        // Echo message back to client
        if (write(socket, buffer, strlen(buffer)) < 0) {
            perror(""Failed to send message to client"");
            exit(EXIT_FAILURE);
        }
        memset(buffer, 0, 1024);
    }
    
    printf(""Client[%d] disconnected.\n"", socket);
    close(socket);
    pthread_exit(NULL);
}",91,5.0
VULNERABLE,falcon180b-4177.c,yes,18,5,handle_client,"
  file falcon180b-4177.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Remote control Vehicle Simulation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    printf(""Client %d disconnected\n"", client_socket);

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        }
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-52804.c,yes,19,5,handle_client,"
  file falcon180b-52804.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 5
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full, please try again later\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.5
VULNERABLE,falcon180b-64189.c,yes,17,5,handle_client,"
  file falcon180b-64189.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System administration ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        bzero(buffer, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main(int argc, char *argv[]) {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    for (int i = 0; i < num_clients; i++) {
        close(client_sockets[i]);
    }

    close(server_socket);
    return 0;
}",88,5.5
VULNERABLE,falcon180b-50436.c,yes,21,5,handle_client,"
  file falcon180b-50436.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <errno.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",88,5.0
VULNERABLE,falcon180b-37286.c,yes,21,5,thread_function,"
  file falcon180b-37286.c line 21 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"int shared_data[ARRAY_SIZE];

// Define the function to be executed by each thread
void *thread_function(void *arg) {
    // Get the thread ID
    int thread_id = *(int *) arg;

    // Print a message indicating the start of the thread
    printf(""Thread %d started.\n"", thread_id);

    // Loop through the shared data array and add 1 to each element","//Falcon-180B DATASET v1.0 Category: Threading Library Implementation ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Define the number of threads to create
#define NUM_THREADS 5

// Define the size of the shared data array
#define ARRAY_SIZE 10

// Define the mutex for synchronizing access to the shared data
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Define the shared data array
int shared_data[ARRAY_SIZE];

// Define the function to be executed by each thread
void *thread_function(void *arg) {
    // Get the thread ID
    int thread_id = *(int *) arg;

    // Print a message indicating the start of the thread
    printf(""Thread %d started.\n"", thread_id);

    // Loop through the shared data array and add 1 to each element
    for (int i = 0; i < ARRAY_SIZE; i++) {
        pthread_mutex_lock(&mutex);
        shared_data[i] += 1;
        pthread_mutex_unlock(&mutex);
    }

    // Print a message indicating the end of the thread
    printf(""Thread %d ended.\n"", thread_id);

    // Return NULL to indicate successful completion of the thread
    return NULL;
}

int main() {
    // Create an array to store the thread IDs
    pthread_t threads[NUM_THREADS];

    // Create the threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_function, (void *) &i);
    }

    // Wait for the threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Print the final value of the shared data array
    printf(""Final shared data array:\n"");
    for (int i = 0; i < ARRAY_SIZE; i++) {
        printf(""%d "", shared_data[i]);
    }
    printf(""\n"");

    return 0;
}",62,3.0
VULNERABLE,falcon180b-28503.c,yes,20,5,handle_client,"
  file falcon180b-28503.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-36826.c,yes,19,5,handle_client,"
  file falcon180b-36826.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int client_socket_count = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Internet Speed Test Application ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080

int client_sockets[MAX_CLIENTS];
int client_socket_count = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for(int i=0; i<client_socket_count; i++) {
            if(client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

void accept_clients() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server is listening on port %d\n"", SERVER_PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if(client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }

        if(client_socket_count >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[client_socket_count] = client_socket;
        client_socket_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }
}

int main() {
    accept_clients();
    return 0;
}",79,3.333
VULNERABLE,falcon180b-43749.c,yes,18,5,handle_client,"
  file falcon180b-43749.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_fd = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_fd, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_fd = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_fd, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_fd);
            pthread_exit(0);
        }

        send(client_fd, buffer, strlen(buffer), 0);
    }
}

int main(int argc, char *argv[]) {
    int server_socket;
    struct sockaddr_in server_addr;

    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""127.0.0.1"", &server_addr.sin_addr);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket;
        socklen_t client_addr_size;
        struct sockaddr_in client_addr;

        if ((client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size)) == -1) {
            printf(""Error accepting connection\n"");
            exit(1);
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",83,5.0
VULNERABLE,falcon180b-6001.c,yes,20,5,handle_client,"
  file falcon180b-6001.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_count = 0;
char send_buffer[BUFFER_SIZE];
char receive_buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    printf(""Client %d connected\n"", client_socket);

    while (1) {
        memset(send_buffer, 0, BUFFER_SIZE);
        memset(receive_buffer, 0, BUFFER_SIZE);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int client_count = 0;
char send_buffer[BUFFER_SIZE];
char receive_buffer[BUFFER_SIZE];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    printf(""Client %d connected\n"", client_socket);

    while (1) {
        memset(send_buffer, 0, BUFFER_SIZE);
        memset(receive_buffer, 0, BUFFER_SIZE);

        int bytes_received = recv(client_socket, receive_buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            return NULL;
        }

        send_buffer[0] = 'E';
        send_buffer[1] = 'C';
        send_buffer[2] = 'H';
        send_buffer[3] = 'O';

        int bytes_sent = send(client_socket, send_buffer, strlen(send_buffer), 0);

        if (bytes_sent <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            return NULL;
        }
    }
}

int main() {
    int opt = 1;
    int addrlen = sizeof(struct sockaddr_in);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *)&server_addr, addrlen) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, (struct sockaddr *)NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (client_count >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[client_count++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",97,5.5
VULNERABLE,falcon180b-66241.c,yes,19,5,handle_client,"
  file falcon180b-66241.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;
int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (num_clients < MAX_CLIENTS) {
        socklen_t client_size = sizeof(clients[num_clients]);
        int client_socket = accept(server_socket, (struct sockaddr *) &clients[num_clients], &client_size);

        if (client_socket == -1) {
            printf(""Error accepting client\n"");
        } else {
            printf(""Client %d connected\n"", client_socket);
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
            num_clients++;
        }
    }

    return 0;
}",56,3.0
VULNERABLE,falcon180b-34230.c,yes,21,5,handle_client,"
  file falcon180b-34230.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket_copy);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket_copy, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,gpt35-74116.c,yes,14,5,handle_connection,"
  file gpt35-74116.c line 14 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"
#define PORT 8080

// Function to handle each connection
void *handle_connection(void *fd_ptr) {
    int client_fd = *(int *)fd_ptr;
    char buffer[1024];
    bzero(buffer, 1024);
    recv(client_fd, buffer, 1024, 0);
    printf(""Received message: %s\n"", buffer);
","//FormAI DATASET v1.0 Category: Wi-Fi Signal Strength Analyzer ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define PORT 8080

// Function to handle each connection
void *handle_connection(void *fd_ptr) {
    int client_fd = *(int *)fd_ptr;
    char buffer[1024];
    bzero(buffer, 1024);
    recv(client_fd, buffer, 1024, 0);
    printf(""Received message: %s\n"", buffer);

    // Analyze Wi-Fi signal strength here

    send(client_fd, ""Response from server: Wi-Fi signal analyzed."", 44, 0);

    close(client_fd);
    pthread_exit(NULL);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    // Create TCP socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""TCP socket creation failed"");
        exit(EXIT_FAILURE);
    }

    // Set socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""Setsockopt failed"");
        exit(EXIT_FAILURE);
    }

    // Bind socket to port
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""Bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, 3) < 0) {
        perror(""Listen failed"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %d.\n"", PORT);

    // Handle incoming connections concurrently using threads
    pthread_t thread_id;
    while ((client_fd = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen))) {
        if (pthread_create(&thread_id, NULL, handle_connection, &client_fd) != 0) {
            perror(""Thread creation failed"");
            exit(EXIT_FAILURE);
        }
        printf(""Connection accepted from %s:%d\n"", inet_ntoa(address.sin_addr), ntohs(address.sin_port));
        pthread_detach(thread_id);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-64471.c,yes,18,5,handle_client,"
  file falcon180b-64471.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 110
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    printf(""Client %d disconnected\n"", client_socket);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 16, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,falcon180b-30160.c,yes,17,5,handle_client,"
  file falcon180b-30160.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i][0]!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = pthread_create(&clients[num_clients][2], NULL, handle_client, (void *)&client_socket);

        if (clients[num_clients][1]!= 0) {
            close(client_socket);
            clients[num_clients][0] = 0;
        } else {
            num_clients++;
        }
    }

    return 0;
}",73,4.5
VULNERABLE,gemini_pro-25775.c,yes,39,5,handle_client,"
  file gemini_pro-25775.c line 39 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"struct client_info clients[MAX_CLIENTS];
struct drone_info drone_info;
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buff[BUFF_SIZE];
    int n;

    while (1) {
        memset(buff, 0, BUFF_SIZE);","//GEMINI-pro DATASET v1.0 Category: Drone Remote Control ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <termios.h>
#include <pthread.h>

#define SERVER_IP ""192.168.1.1""
#define SERVER_PORT 8080
#define BUFF_SIZE 1024
#define MAX_CLIENTS 10

struct client_info {
    int socket;
    struct sockaddr_in addr;
    char name[32];
};

struct drone_info {
    int x;
    int y;
    int z;
    int yaw;
    int pitch;
    int roll;
};

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
struct client_info clients[MAX_CLIENTS];
struct drone_info drone_info;
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buff[BUFF_SIZE];
    int n;

    while (1) {
        memset(buff, 0, BUFF_SIZE);
        n = recv(client_socket, buff, BUFF_SIZE, 0);
        if (n <= 0) {
            break;
        }

        pthread_mutex_lock(&mutex);
        if (strncmp(buff, ""name"", 4) == 0) {
            strcpy(clients[num_clients].name, buff + 5);
            num_clients++;
        } else if (strncmp(buff, ""move"", 4) == 0) {
            sscanf(buff + 5, ""%d %d %d %d %d %d"", &drone_info.x, &drone_info.y, &drone_info.z, &drone_info.yaw, &drone_info.pitch, &drone_info.roll);
        }
        pthread_mutex_unlock(&mutex);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len;
    pthread_t client_thread;

    // Create the server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        return -1;
    }

    // Set the server socket options
    int opt = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt)) == -1) {
        perror(""setsockopt"");
        return -1;
    }

    // Bind the server socket to the IP address and port
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(SERVER_PORT);
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        return -1;
    }

    // Listen for incoming connections
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        perror(""listen"");
        return -1;
    }

    // Accept incoming connections and create a thread for each client
    while (1) {
        client_addr_len = sizeof(client_addr);
        client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_len);
        if (client_socket == -1) {
            perror(""accept"");
            return -1;
        }

        pthread_create(&client_thread, NULL, handle_client, &client_socket);
    }

    // Close the server socket
    close(server_socket);

    return 0;
}",116,6.0
VULNERABLE,falcon180b-4252.c,yes,21,5,handle_client,"
  file falcon180b-4252.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while(1) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_DATA_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_DATA_SIZE];

    while(1) {
        memset(buffer, 0, MAX_DATA_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_DATA_SIZE, 0);

        if(bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for(int i = 0; i < num_clients; i++) {
            if(i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is running on port 8080\n"");

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);

        client_sockets[num_clients] = client_socket;
        num_clients++;
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-4457.c,yes,20,5,handle_client,"
  file falcon180b-4457.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_sock = *(int *) client_socket;
    char buf[BUF_SIZE];

    while (1) {
        memset(buf, 0, BUF_SIZE);
        int bytes_received = recv(client_sock, buf, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_sock = *(int *) client_socket;
    char buf[BUF_SIZE];

    while (1) {
        memset(buf, 0, BUF_SIZE);
        int bytes_received = recv(client_sock, buf, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_sock);
            clients[num_clients--] = -1;
            break;
        }

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= -1) {
                send(clients[i], buf, bytes_received, 0);
            }
        }
    }

    return NULL;
}

int main() {
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);

    if (server_sock == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    inet_pton(AF_INET, ""127.0.0.1"", &server_addr.sin_addr);

    if (bind(server_sock, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_sock, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_size = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *) &client_addr, &client_size);

        if (client_sock!= -1) {
            clients[num_clients++] = client_sock;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_sock);
        }
    }

    return 0;
}",82,5.5
VULNERABLE,falcon180b-1621.c,yes,18,5,handle_client,"
  file falcon180b-1621.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            close(sock);
            pthread_exit(0);
        }

        printf(""Client %d sent message: %s\n"", sock, buffer);
        for(int i = 0; i < num_clients; i++) {
            if(i!= sock) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server is listening on port 8080\n"");

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if(client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",78,4.5
VULNERABLE,falcon180b-41923.c,yes,19,5,handle_client,"
  file falcon180b-41923.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", sizeof(""Server is full\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-54640.c,yes,18,5,handle_client,"
  file falcon180b-54640.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
char *filenames[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: File Synchronizer ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;
char *filenames[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Received message from client %d: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server is running on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",67,3.0
VULNERABLE,gemini_pro-21498.c,yes,30,17,handle_client,"
  file gemini_pro-21498.c line 30 column 17 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client'",dereference failure: accessed expired variable pointer,"void *handle_client(void *arg) {
    client_t *client = (client_t *)arg;
    char buffer[1024];
    int n;

    while ((n = read(client->sockfd, buffer, sizeof(buffer))) > 0) {
        // Parse the HTTP request
        char *method = strtok(buffer, "" "");
        char *path = strtok(NULL, "" "");
        char *version = strtok(NULL, ""\r\n"");
","//GEMINI-pro DATASET v1.0 Category: Simple HTTP Proxy ; Style: unmistakable
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10

typedef struct {
    int sockfd;
    struct sockaddr_in addr;
} client_t;

typedef struct {
    int num_clients;
    client_t clients[MAX_CLIENTS];
} proxy_t;

proxy_t proxy;

void *handle_client(void *arg) {
    client_t *client = (client_t *)arg;
    char buffer[1024];
    int n;

    while ((n = read(client->sockfd, buffer, sizeof(buffer))) > 0) {
        // Parse the HTTP request
        char *method = strtok(buffer, "" "");
        char *path = strtok(NULL, "" "");
        char *version = strtok(NULL, ""\r\n"");

        // Check if the request is valid
        if (strcmp(method, ""GET"") != 0 || strcmp(version, ""HTTP/1.1"") != 0) {
            write(client->sockfd, ""HTTP/1.1 400 Bad Request\r\n\r\n"", 32);
            close(client->sockfd);
            return NULL;
        }

        // Connect to the remote server
        int remote_sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (remote_sockfd == -1) {
            write(client->sockfd, ""HTTP/1.1 500 Internal Server Error\r\n\r\n"", 39);
            close(client->sockfd);
            return NULL;
        }

        struct sockaddr_in remote_addr;
        remote_addr.sin_family = AF_INET;
        remote_addr.sin_port = htons(80);
        remote_addr.sin_addr.s_addr = inet_addr(""127.0.0.1"");

        if (connect(remote_sockfd, (struct sockaddr *)&remote_addr, sizeof(remote_addr)) == -1) {
            write(client->sockfd, ""HTTP/1.1 500 Internal Server Error\r\n\r\n"", 39);
            close(client->sockfd);
            return NULL;
        }

        // Forward the request to the remote server
        write(remote_sockfd, buffer, n);

        // Read the response from the remote server
        while ((n = read(remote_sockfd, buffer, sizeof(buffer))) > 0) {
            // Forward the response to the client
            write(client->sockfd, buffer, n);
        }

        // Close the connections
        close(client->sockfd);
        close(remote_sockfd);
    }

    return NULL;
}

int main(int argc, char **argv) {
    proxy.num_clients = 0;

    int listen_sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_sockfd == -1) {
        perror(""socket"");
        return -1;
    }

    struct sockaddr_in listen_addr;
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_port = htons(8080);
    listen_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(listen_sockfd, (struct sockaddr *)&listen_addr, sizeof(listen_addr)) == -1) {
        perror(""bind"");
        return -1;
    }

    if (listen(listen_sockfd, MAX_CLIENTS) == -1) {
        perror(""listen"");
        return -1;
    }

    while (1) {
        client_t client;
        socklen_t len = sizeof(client.addr);

        client.sockfd = accept(listen_sockfd, (struct sockaddr *)&client.addr, &len);
        if (client.sockfd == -1) {
            perror(""accept"");
            continue;
        }

        if (proxy.num_clients >= MAX_CLIENTS) {
            write(client.sockfd, ""HTTP/1.1 503 Service Unavailable\r\n\r\n"", 36);
            close(client.sockfd);
            continue;
        }

        proxy.clients[proxy.num_clients++] = client;

        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, &client);
    }

    return 0;
}",126,7.0
VULNERABLE,falcon180b-60220.c,yes,21,5,handle_client,"
  file falcon180b-60220.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: Dennis Ritchie
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            close(client_socket);
            printf(""Client %d disconnected\n"", client_socket);
            pthread_exit(0);
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
        num_clients++;
    }

    close(server_socket);
    return 0;
}",65,3.0
VULNERABLE,falcon180b-30961.c,yes,18,5,handle_client,"
  file falcon180b-30961.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for(int i = 0; i < num_clients; i++) {
            if(i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if(client_socket == -1) {
            break;
        }
        if(num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",65,4.5
VULNERABLE,gpt35-55796.c,yes,12,5,handle_client,"
  file gpt35-55796.c line 12 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#include <arpa/inet.h>
#include <pthread.h>

// Function to handle client connections
void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];

    // Read incoming messages from client
    while (1) {
        memset(buffer, 0, sizeof(buffer));","//FormAI DATASET v1.0 Category: Chat server ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

// Function to handle client connections
void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[1024];

    // Read incoming messages from client
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int read_result = read(client_socket, buffer, sizeof(buffer));
        
        // If client disconnected, close socket and exit thread
        if (read_result == 0) {
            close(client_socket);
            pthread_exit(NULL);
        }
        
        // Display the message from client
        printf(""Client: %s"", buffer);
        
        // Send message back to client
        write(client_socket, buffer, strlen(buffer));
    }
}

int main() {
    // Create socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        printf(""Error creating socket\n"");
        exit(1);
    }
    
    // Bind socket to port
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // Use port 8080
    server_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        exit(1);
    }
    
    // Listen for incoming connections
    if (listen(server_socket, 5) < 0) {
        printf(""Error listening for incoming connections\n"");
        exit(1);
    }
    
    printf(""Server started\n"");
    
    // Handle incoming connections from clients
    while (1) {
        struct sockaddr_in client_addr;
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, sizeof(client_addr));
        if (client_socket < 0) {
            printf(""Error accepting client connection\n"");
            continue; // Try again with another connection
        }
        
        printf(""Client connected: %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        
        // Create thread to handle client
        pthread_t thread_id;
        int thread_result = pthread_create(&thread_id, NULL, &handle_client, &client_socket);
        if (thread_result < 0) {
            printf(""Error creating thread to handle client\n"");
            close(client_socket);
            continue; // Try again with another connection
        }
    }
    
    // Close server socket
    close(server_socket);
    return 0;
}",84,5.0
VULNERABLE,falcon180b-71691.c,yes,21,5,handle_client,"
  file falcon180b-71691.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(server_socket, MAX_CLIENTS) < 0) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        socklen_t client_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_size);
        if (client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }
        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }
        client_sockets[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",75,4.5
VULNERABLE,falcon180b-2631.c,yes,19,5,handle_client,"
  file falcon180b-2631.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: Ada Lovelace
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full.\n"", 16, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = 0;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",77,4.0
VULNERABLE,falcon180b-56128.c,yes,20,5,handle_client,"
  file falcon180b-56128.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Romeo and Juliet
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is running on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = 0;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,3.0
VULNERABLE,gpt35-31437.c,yes,56,5,handleClient,"
  file gpt35-31437.c line 56 column 5 function handleClient
","
  c:@F@handleClient at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client'",dereference failure: accessed expired variable pointer,"    return 0;
}

// Thread function to handle client
void *handleClient(void *args) {
    struct Client client = *((struct Client*)args); // Client details
    int socket = client.socket;

    // Receive packet data from client
    char buffer[MAX_BUFFER] = {0};
    read(socket, buffer, MAX_BUFFER);","//FormAI DATASET v1.0 Category: Firewall ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_BUFFER 1024

// Structure for rules
struct Rule {
    char sourceIP[20];
    char destinationIP[20];
    int sourcePort;
    int destinationPort;
    char protocol[10];
};

struct Client {
    int socket;
    struct sockaddr_in address;
};

// Array to hold all firewall rules
struct Rule rules[10];
int ruleCount = 0;

// Add new firewall rule
void addRule(char sourceIP[20], char destinationIP[20], int sourcePort, int destinationPort, char protocol[10]) {
    strcpy(rules[ruleCount].sourceIP, sourceIP);
    strcpy(rules[ruleCount].destinationIP, destinationIP);
    rules[ruleCount].sourcePort = sourcePort;
    rules[ruleCount].destinationPort = destinationPort;
    strcpy(rules[ruleCount].protocol, protocol);
    ruleCount++;
}

// Check if given rule matches the given packet data
int isMatch(char sourceIP[20], char destinationIP[20], int sourcePort, int destinationPort, char protocol[10]) {
    for(int i=0; i<ruleCount; i++) {
        if(strcmp(rules[i].sourceIP, sourceIP) == 0 && strcmp(rules[i].destinationIP, destinationIP) == 0 && 
        rules[i].sourcePort == sourcePort && rules[i].destinationPort == destinationPort && strcmp(rules[i].protocol, protocol) == 0) {
          return 1;
        }
    }
    return 0;
}

// Thread function to handle client
void *handleClient(void *args) {
    struct Client client = *((struct Client*)args); // Client details
    int socket = client.socket;

    // Receive packet data from client
    char buffer[MAX_BUFFER] = {0};
    read(socket, buffer, MAX_BUFFER);

    // Parse packet data
    char sourceIP[20], destinationIP[20], protocol[10];
    int sourcePort, destinationPort;
    sscanf(buffer, ""%[^,],%d,%[^,],%d,%[^,]"", sourceIP, &sourcePort, destinationIP, &destinationPort, protocol);

    // Check if packet data matches firewall rule
    if(!isMatch(sourceIP, destinationIP, sourcePort, destinationPort, protocol)) {
        // Send rejection message to client
        char *responseMessage = ""Packet Rejected by Firewall!"";
        send(socket, responseMessage, strlen(responseMessage), 0);
    } else {
        // Send success message to client
        char *responseMessage = ""Packet Approved by Firewall!"";
        send(socket, responseMessage, strlen(responseMessage), 0);
    }

    close(socket); // Close client socket
    pthread_exit(NULL);
}

int main(int argc, char const *argv[]) {
    int serverSocket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    // Create server socket
    if((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }

    // Set server socket options
    if(setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt failed"");
        exit(EXIT_FAILURE);
    }

    // Set server socket details
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind server socket to address and port
    if(bind(serverSocket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if(listen(serverSocket, 3)) {
        perror(""listen failed"");
        exit(EXIT_FAILURE);
    }

    printf(""Firewall listening on port %d...\n"", PORT);

    // Start accepting incoming connections
    while(1) {
        int clientSocket;
        struct sockaddr_in clientAddress;
        pthread_t threadID;

        // Accept incoming connection
        if((clientSocket = accept(serverSocket, (struct sockaddr*)&clientAddress, (socklen_t*)&addrlen)) < 0) {
            perror(""accept failed"");
            exit(EXIT_FAILURE);
        }

        // Create thread to handle client
        struct Client client;
        client.socket = clientSocket;
        client.address = clientAddress;
        pthread_create(&threadID, NULL, handleClient, (void*)&client);
    }

    return 0;
}

// Example usage:
// addRule(""192.168.0.1"", ""192.168.0.2"", 80, 8080, ""TCP"");
// addRule(""192.168.0.2"", ""192.168.0.1"", 8080, 80, ""TCP"");
// addRule(""192.168.0.1"", ""192.168.0.3"", 53, 53, ""UDP"");",145,4.25
VULNERABLE,falcon180b-55382.c,yes,20,5,handle_client,"
  file falcon180b-55382.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 3) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server listening on port 8080\n"");

    while (1) {
        socklen_t client_size = sizeof(struct sockaddr_in);
        int client_socket = accept(server_socket, (struct sockaddr *) &clients[num_clients], &client_size);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""New client connected\n"");
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",81,4.5
VULNERABLE,gpt35-40296.c,yes,15,5,handle_connection,"
  file gpt35-40296.c line 15 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"#define PORT 8080
#define QUEUE_SIZE 10
#define RESPONSE ""HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 12\r\n\r\nHello World!""

void *handle_connection(void *arg){
    int client_sock = *(int*)arg;
    char buffer[1024] = {0};
    read(client_sock, buffer, 1024);
    write(client_sock, RESPONSE, strlen(RESPONSE));
    close(client_sock);
    pthread_exit(NULL);","//FormAI DATASET v1.0 Category: Simple Web Server ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define QUEUE_SIZE 10
#define RESPONSE ""HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 12\r\n\r\nHello World!""

void *handle_connection(void *arg){
    int client_sock = *(int*)arg;
    char buffer[1024] = {0};
    read(client_sock, buffer, 1024);
    write(client_sock, RESPONSE, strlen(RESPONSE));
    close(client_sock);
    pthread_exit(NULL);
}

int main(){
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if(server_sock == -1){
        printf(""Failed to create socket"");
        return -1;
    }

    struct sockaddr_in server_addr, client_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if(bind(server_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0){
        printf(""Failed to bind"");
        return -1;
    }

    if(listen(server_sock, QUEUE_SIZE) < 0){
        printf(""Failed to listen"");
        return -1;
    }

    printf(""Listening on port %d...\n"", PORT);

    while(1){
        socklen_t clilen = sizeof(client_addr);
        int client_sock = accept(server_sock, (struct sockaddr *)&client_addr, &clilen);
        if(client_sock < 0){
            printf(""Failed to accept"");
            continue;
        }
        pthread_t tid;
        if(pthread_create(&tid, NULL, handle_connection, &client_sock) != 0){
            printf(""Failed to create thread"");
            continue;
        }
        pthread_detach(tid);
    }

    close(server_sock);
    return 0;
}",64,4.0
VULNERABLE,falcon180b-33373.c,yes,14,5,task_func,"
  file falcon180b-33373.c line 14 column 5 function task_func
","
  c:@F@task_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `task_id'",dereference failure: accessed expired variable pointer,"// Mutex for thread-safe access to the num_tasks variable
pthread_mutex_t num_tasks_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to create a new task
void* task_func(void* arg) {
    int task_id = *(int*) arg;
    printf(""Starting task %d\n"", task_id);
    sleep(1);
    printf(""Finished task %d\n"", task_id);
    return NULL;
}","//Falcon-180B DATASET v1.0 Category: Task Scheduler ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Global variable to keep track of the number of tasks
int num_tasks = 0;

// Mutex for thread-safe access to the num_tasks variable
pthread_mutex_t num_tasks_mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to create a new task
void* task_func(void* arg) {
    int task_id = *(int*) arg;
    printf(""Starting task %d\n"", task_id);
    sleep(1);
    printf(""Finished task %d\n"", task_id);
    return NULL;
}

// Function to add a new task to the scheduler
void add_task() {
    pthread_mutex_lock(&num_tasks_mutex);
    num_tasks++;
    pthread_mutex_unlock(&num_tasks_mutex);

    int task_id = num_tasks;
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, task_func, &task_id);
    printf(""Added task %d\n"", task_id);
}

// Function to remove a task from the scheduler
void remove_task(int task_id) {
    pthread_mutex_lock(&num_tasks_mutex);
    num_tasks--;
    pthread_mutex_unlock(&num_tasks_mutex);

    printf(""Removed task %d\n"", task_id);
}

// Function to print the current state of the scheduler
void print_state() {
    pthread_mutex_lock(&num_tasks_mutex);
    printf(""Current number of tasks: %d\n"", num_tasks);
    pthread_mutex_unlock(&num_tasks_mutex);
}

int main() {
    add_task();
    add_task();
    add_task();

    sleep(2);

    remove_task(1);

    print_state();

    return 0;
}",61,1.0
VULNERABLE,falcon180b-62997.c,yes,18,5,handle_client,"
  file falcon180b-62997.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int client_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[1024];
    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        for(int i=0; i<client_count; i++) {
            if(clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_count >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[client_count] = client_socket;
        client_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-66643.c,yes,26,5,handle_client,"
  file falcon180b-66643.c line 26 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * client_socket) {
    int client_socket_fd = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: System administration ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 20
#define PORT 8080
#define BACKLOG 10
#define BUFFER_SIZE 1024
#define SERVER_IP ""127.0.0.1""

int clients[MAX_CLIENTS];
int num_clients = 0;

void * handle_client(void * client_socket) {
    int client_socket_fd = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);
        if(bytes_received <= 0) {
            close(client_socket_fd);
            pthread_exit(0);
        }
        printf(""Client %d sent: %s"", client_socket_fd, buffer);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);

    if(bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if(listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server is listening on port %d\n"", PORT);

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);
        if(client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if(num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",87,5.0
VULNERABLE,gemini_pro-38378.c,yes,85,5,people_thread,"
  file gemini_pro-38378.c line 85 column 5 function people_thread
","
  c:@F@people_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `floor'",dereference failure: accessed expired variable pointer,"}

// Thread function for the people
void *people_thread(void *arg)
{
    int floor = *(int *)arg;

    // Simulate the person waiting for the elevator
    sleep(rand() % 5);

    // Acquire the lock","//GEMINI-pro DATASET v1.0 Category: Elevator Simulation ; Style: funny
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

// Elevator states
#define IDLE 0
#define UP 1
#define DOWN 2

// Elevator directions
#define UPWARD 1
#define DOWNWARD -1

// Maximum number of floors
#define MAX_FLOORS 10

// Maximum number of people in the elevator
#define MAX_PEOPLE 5

// Global variables
int current_floor = 1;
int destination_floor = 1;
int direction = UPWARD;
int state = IDLE;
int num_people = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

// Thread function for the elevator
void *elevator_thread(void *arg)
{
    while (1)
    {
        // Acquire the lock
        pthread_mutex_lock(&mutex);

        // Wait for a request
        while (state == IDLE)
        {
            pthread_cond_wait(&cond, &mutex);
        }

        // Set the destination floor
        destination_floor = *(int *)arg;

        // Set the direction
        if (destination_floor > current_floor)
        {
            direction = UPWARD;
        }
        else
        {
            direction = DOWNWARD;
        }

        // Set the state to moving
        state = direction == UPWARD ? UP : DOWN;

        // Release the lock
        pthread_mutex_unlock(&mutex);

        // Move the elevator
        while (current_floor != destination_floor)
        {
            // Simulate the elevator moving
            sleep(1);

            // Update the current floor
            current_floor += direction;
        }

        // Set the state to idle
        pthread_mutex_lock(&mutex);
        state = IDLE;
        pthread_mutex_unlock(&mutex);
    }

    return NULL;
}

// Thread function for the people
void *people_thread(void *arg)
{
    int floor = *(int *)arg;

    // Simulate the person waiting for the elevator
    sleep(rand() % 5);

    // Acquire the lock
    pthread_mutex_lock(&mutex);

    // Add the person to the elevator
    num_people++;

    // If the elevator is idle, wake it up
    if (state == IDLE)
    {
        pthread_cond_signal(&cond);
    }

    // Release the lock
    pthread_mutex_unlock(&mutex);

    // Simulate the person riding the elevator
    sleep(rand() % 5);

    // Acquire the lock
    pthread_mutex_lock(&mutex);

    // Remove the person from the elevator
    num_people--;

    // Release the lock
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main()
{
    // Create the elevator thread
    pthread_t elevator;
    pthread_create(&elevator, NULL, elevator_thread, NULL);

    // Create a random number of people threads
    int num_people = rand() % 10;
    pthread_t people[num_people];
    for (int i = 0; i < num_people; i++)
    {
        int floor = rand() % MAX_FLOORS + 1;
        pthread_create(&people[i], NULL, people_thread, &floor);
    }

    // Join the threads
    pthread_join(elevator, NULL);
    for (int i = 0; i < num_people; i++)
    {
        pthread_join(people[i], NULL);
    }

    return 0;
}",143,3.667
VULNERABLE,gpt35-61248.c,yes,16,3,handle_connection,"
  file gpt35-61248.c line 16 column 3 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"#define BACKLOG 10
#define MAXLINE 1024
#define PORT 8888

void *handle_connection(void *fd) {
  int client_fd = *(int*)fd;
  char buffer[MAXLINE];
  int n;
  while ((n = recv(client_fd, buffer, MAXLINE, 0)) > 0) {
    printf(""Received %d bytes\n"", n);
    fwrite(buffer, sizeof(char), n, stdout);","//FormAI DATASET v1.0 Category: Simple HTTP Proxy ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>

#define BACKLOG 10
#define MAXLINE 1024
#define PORT 8888

void *handle_connection(void *fd) {
  int client_fd = *(int*)fd;
  char buffer[MAXLINE];
  int n;
  while ((n = recv(client_fd, buffer, MAXLINE, 0)) > 0) {
    printf(""Received %d bytes\n"", n);
    fwrite(buffer, sizeof(char), n, stdout);
    send(client_fd, buffer, n, 0);
  }
  close(client_fd);
  printf(""Connection closed\n"");
  return NULL;
}

int main() {
  printf(""Surprise! Here's a simple HTTP proxy example in C!\n"");
  printf(""--------------------------------------------------\n\n"");
  
  int server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (server_fd < 0) {
    perror(""socket"");
    exit(EXIT_FAILURE);
  }

  struct sockaddr_in server_addr = {
    .sin_family = AF_INET,
    .sin_port = htons(PORT),
    .sin_addr.s_addr = htonl(INADDR_ANY)
  };

  int optval = 1;
  if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
    perror(""setsockopt"");
    exit(EXIT_FAILURE);
  }

  if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr_in)) < 0) {
    perror(""bind"");
    exit(EXIT_FAILURE);
  }

  if (listen(server_fd, BACKLOG) < 0) {
    perror(""listen"");
    exit(EXIT_FAILURE);
  }
  printf(""Listening on port %d...\n"", PORT);
  while (1) {
    struct sockaddr_in client_addr;
    socklen_t client_size = sizeof(struct sockaddr_in);
    int client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_size);
    if (client_fd < 0) {
      perror(""accept"");
      exit(EXIT_FAILURE);
    }
    printf(""Incoming HTTP request from %s:%d\n"", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
    pthread_t tid;
    pthread_create(&tid, NULL, handle_connection, &client_fd);
  }
  return EXIT_SUCCESS;
}",74,4.5
VULNERABLE,gpt35-30670.c,yes,67,5,connection_handler,"
  file gpt35-30670.c line 67 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *connection_handler(void *socket_desc) {
    //get socket descriptor
    int sock = *(int *)socket_desc;
    char buffer[BUFF_SIZE];
    int read_size;

    //send initial message to client
    char *message = ""Welcome to the Chat Server! Type 'bye' to exit\n"";","//FormAI DATASET v1.0 Category: Client Server Application ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define BUFF_SIZE 1024

void *connection_handler(void *);

int main(int argc, char const *argv[]) {

    //create socket
    int socket_desc = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_desc == -1) {
        printf(""Could not create socket"");
    }
    puts(""Socket created"");

    //prepare socket address
    struct sockaddr_in server, client;
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    //bind socket to the port
    if (bind(socket_desc, (struct sockaddr *)&server, sizeof(server)) == -1) {
        printf(""Bind failed"");
        return 1;
    }
    puts(""Bind done"");

    //listen for incoming connections
    listen(socket_desc, 3);

    //keep accepting incoming connections
    puts(""Waiting for incoming connections..."");
    int c = sizeof(struct sockaddr_in);
    int new_socket;
    while ((new_socket = accept(socket_desc, (struct sockaddr *)&client, (socklen_t *)&c))) {
        puts(""Connection accepted"");

        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, connection_handler, (void *)&new_socket) < 0) {
            perror(""Could not create thread"");
            return 1;
        }

        //close socket file descriptor
        close(new_socket);
    }

    if (new_socket < 0) {
        perror(""Accept failed"");
        return 1;
    }

    return 0;
}

void *connection_handler(void *socket_desc) {
    //get socket descriptor
    int sock = *(int *)socket_desc;
    char buffer[BUFF_SIZE];
    int read_size;

    //send initial message to client
    char *message = ""Welcome to the Chat Server! Type 'bye' to exit\n"";
    write(sock, message, strlen(message));

    //keep communication going with client
    while ((read_size = recv(sock, buffer, BUFF_SIZE, 0)) > 0) {
        //add null terminator to end of message
        buffer[read_size] = '\0';

        //check if client wants to exit
        if (strncmp(buffer, ""bye"", 3) == 0) {
            message = ""Goodbye!\n"";
            write(sock, message, strlen(message));
            break;
        }

        //print message from client to server console
        printf(""Client: %s"", buffer);

        //send message back to client
        write(sock, buffer, strlen(buffer));
    }

    if (read_size == 0) {
        puts(""Client disconnected"");
        fflush(stdout);
    } else if (read_size == -1) {
        perror(""Receive failed"");
    }

    //exit thread
    pthread_exit(NULL);
}",103,5.5
VULNERABLE,falcon180b-43477.c,yes,22,5,handle_client,"
  file falcon180b-43477.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int g_server_socket = -1;
pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define TRUE  1
#define FALSE 0
#define PORT  8080
#define BACKLOG 10

int g_server_socket = -1;
pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while(1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Received message from client: %s\n"", buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if(server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 2;
    }

    if(listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 3;
    }

    printf(""Server is listening on port %d\n"", PORT);

    while(TRUE) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    close(server_socket);
    return 0;
}",81,4.5
VULNERABLE,gpt35-33087.c,yes,13,5,handle_client,"
  file gpt35-33087.c line 13 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#include <pthread.h>

#define PORT 8080

void *handle_client(void *client_socket) {
    int socket = *(int *)client_socket;
    char buffer[1024] = {0};
    while (recv(socket, buffer, 1024, 0) > 0) {
        printf(""Message from client: %s\n"", buffer);
        memset(buffer, 0, 1024);
    }","//FormAI DATASET v1.0 Category: Socket programming ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

void *handle_client(void *client_socket) {
    int socket = *(int *)client_socket;  
    char buffer[1024] = {0};
    while (recv(socket, buffer, 1024, 0) > 0) {
        printf(""Message from client: %s\n"", buffer);
        memset(buffer, 0, 1024);
    }
    close(socket);
    return NULL;
}

int main(int argc, char const *argv[])
{
    int server_socket;
    struct sockaddr_in address;

    // Create socket file descriptor
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }
    
    // Set socket options
    int opt = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }
    
    // Bind socket to port
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    if (bind(server_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }
    
    // Listen for incoming connections
    if (listen(server_socket, 3) < 0) {
        perror(""listen failed"");
        exit(EXIT_FAILURE);
    }

    printf(""Server running on port %d\n"", PORT);
    while(1) {
        struct sockaddr_in client_address;
        int addrlen = sizeof(client_address);

        // Accept incoming connection
        int client_socket = accept(server_socket, (struct sockaddr *)&client_address, (socklen_t*)&addrlen);
        if (client_socket < 0) {
            perror(""accept failed"");
            exit(EXIT_FAILURE);
        }
        
        printf(""Client connected: %s:%d\n"", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));

        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket) < 0) {
            perror(""pthread_create failed"");
            exit(EXIT_FAILURE);
        }
    }
    return 0;
}",77,5.0
VULNERABLE,gpt35-23994.c,yes,81,17,main,"
  file gpt35-23994.c line 81 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `category'",dereference failure: accessed expired variable pointer,"                printf(""\nExpense added successfully."");
                break;
            case 2: // View Expenses By Category
                // Get category to view
                printf(""\nEnter category to view (1-%d): "", MAX_CATEGORIES);
                scanf(""%d"", &category);
                // Print header
                printf(""\nExpenses for Category %d:"", category);
                printf(""\n=========================="");
                // Loop through array of expenses and print those with selected category
                for(int i = 0; i < numExpenses; i++) {","//FormAI DATASET v1.0 Category: Expense Tracker ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>

// Define maximum number of expenses and categories
#define MAX_EXPENSES 100
#define MAX_CATEGORIES 10

// Define struct for expense
struct Expense {
    int category;
    double amount;
    char description[50];
};

// Function to display menu 
void displayMenu() {
    printf(""\n======= EXPENSE TRACKER MENU ======="");
    printf(""\n1. Add Expense"");
    printf(""\n2. View Expenses By Category"");
    printf(""\n3. View Total Expenses By Category"");
    printf(""\n4. View Total Expenses"");
    printf(""\n5. Exit"");
}

int main() {
    // Initialize array of expenses
    struct Expense expenses[MAX_EXPENSES];
    // Initialize array of category totals
    double categoryTotals[MAX_CATEGORIES] = {0};
    // Initialize total expense variable
    double totalExpense = 0;
    // Initialize number of expenses entered counter
    int numExpenses = 0;
    // Initialize main loop variable
    int choice = 0;
    
    // Main loop
    do {
        // Display menu
        displayMenu();
        // Get user's choice
        printf(""\nEnter your choice: "");
        scanf(""%d"", &choice);
        
        switch(choice) {
            case 1: // Add Expense
                // Check if maximum number of expenses have been entered
                if(numExpenses == MAX_EXPENSES) {
                    printf(""\nMaximum number of expenses reached."");
                    break;
                }
                // Get expense category
                int category;
                printf(""\nEnter expense category (1-%d): "", MAX_CATEGORIES);
                scanf(""%d"", &category);
                // Check if category is within range
                if(category < 1 || category > MAX_CATEGORIES) {
                    printf(""\nInvalid category."");
                    break;
                }
                // Get expense amount
                double amount;
                printf(""Enter expense amount: $"");
                scanf(""%lf"", &amount);
                // Get expense description
                char description[50];
                printf(""Enter expense description: "");
                scanf(""%s"", description);
                // Update total expense variable and category total
                totalExpense += amount;
                categoryTotals[category-1] += amount;
                // Create expense struct and add to array
                struct Expense expense = {category, amount, description};
                expenses[numExpenses++] = expense;
                printf(""\nExpense added successfully."");
                break;
            case 2: // View Expenses By Category
                // Get category to view
                printf(""\nEnter category to view (1-%d): "", MAX_CATEGORIES);
                scanf(""%d"", &category);
                // Print header
                printf(""\nExpenses for Category %d:"", category);
                printf(""\n=========================="");
                // Loop through array of expenses and print those with selected category
                for(int i = 0; i < numExpenses; i++) {
                    if(expenses[i].category == category) {
                        printf(""\nAmount: $%.2lf\nDescription: %s"", expenses[i].amount, expenses[i].description);
                    }
                }
                break;
            case 3: // View Total Expenses By Category
                // Print header
                printf(""\nTotal Expenses By Category:"");
                printf(""\n==========================="");
                // Loop through category totals array and print each category's total
                for(int i = 0; i < MAX_CATEGORIES; i++) {
                    printf(""\nCategory %d Total: $%.2lf"", i+1, categoryTotals[i]);
                }
                break;
            case 4: // View Total Expenses
                printf(""\nTotal Expenses: $%.2lf"", totalExpense);
                break;
            case 5: // Exit
                printf(""\nExiting program..."");
                break;
            default:
                printf(""\nInvalid choice."");
        }
    } while(choice != 5);
    
    return 0;
}",113,7.0
VULNERABLE,falcon180b-41820.c,yes,30,5,read_file,"
  file falcon180b-41820.c line 30 column 5 function read_file
","
  c:@F@read_file at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `f'",dereference failure: accessed expired variable pointer,"    file_t *f = arg;
    char buf[BUF_SIZE];
    ssize_t n;
    size_t offset = 0;

    while ((n = read(f->fd, buf, BUF_SIZE)) > 0) {
        if (f->data == NULL) {
            f->data = malloc(f->filesize);
        }
        memcpy(f->data + offset, buf, n);
        offset += n;","//Falcon-180B DATASET v1.0 Category: Data recovery tool ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/sendfile.h>
#include <sys/mman.h>

#define BUF_SIZE 4096

typedef struct {
    char *filename;
    size_t filesize;
    int fd;
    void *data;
} file_t;

void *read_file(void *arg) {
    file_t *f = arg;
    char buf[BUF_SIZE];
    ssize_t n;
    size_t offset = 0;

    while ((n = read(f->fd, buf, BUF_SIZE)) > 0) {
        if (f->data == NULL) {
            f->data = malloc(f->filesize);
        }
        memcpy(f->data + offset, buf, n);
        offset += n;
    }

    if (n < 0) {
        perror(""read"");
    }

    return NULL;
}

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s <filename>\n"", argv[0]);
        return 1;
    }

    file_t f;
    f.filename = argv[1];
    f.filesize = 0;
    f.fd = open(f.filename, O_RDONLY);
    if (f.fd == -1) {
        perror(""open"");
        return 1;
    }

    struct stat st;
    if (fstat(f.fd, &st) == -1) {
        perror(""fstat"");
        return 1;
    }

    f.filesize = st.st_size;
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, read_file, &f);

    void *data = NULL;
    size_t size = 0;

    while (f.data == NULL) {
        usleep(100000);
    }

    data = f.data;
    size = f.filesize;

    close(f.fd);

    printf(""Data recovery successful!\n"");
    printf(""File size: %zu bytes\n"", size);

    return 0;
}",86,4.5
VULNERABLE,falcon180b-29839.c,yes,19,5,handle_client,"
  file falcon180b-29839.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int g_client_sockets[MAX_CLIENTS];
pthread_t g_client_threads[MAX_CLIENTS];
int g_num_clients = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int g_server_socket;
int g_client_sockets[MAX_CLIENTS];
pthread_t g_client_threads[MAX_CLIENTS];
int g_num_clients = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char* message = strdup(buffer);
        printf(""Client %d sent message: %s\n"", client_socket, message);

        // Send message to all connected clients
        for (int i = 0; i < g_num_clients; i++) {
            if (g_client_sockets[i]!= client_socket) {
                send(g_client_sockets[i], message, strlen(message), 0);
            }
        }

        free(message);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (g_num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 14, 0);
            close(client_socket);
            continue;
        }

        g_client_sockets[g_num_clients] = client_socket;
        g_num_clients++;

        pthread_create(&g_client_threads[g_num_clients - 1], NULL, handle_client, (void*)&client_socket);
    }

    return 0;
}",77,4.0
VULNERABLE,falcon180b-8050.c,yes,18,5,handle_client,"
  file falcon180b-8050.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    accept_connections();

    close(server_socket);

    return 0;
}",82,2.667
VULNERABLE,falcon180b-47923.c,yes,19,5,handle_client,"
  file falcon180b-47923.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 15, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,3.0
VULNERABLE,falcon180b-52246.c,yes,18,5,handle_client,"
  file falcon180b-52246.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int max_clients = 0;

void *handle_client(void *client_socket) {
    char buffer[BUFFER_SIZE];
    int client_socket_fd = *(int *) client_socket;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);
","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int max_clients = 0;

void *handle_client(void *client_socket) {
    char buffer[BUFFER_SIZE];
    int client_socket_fd = *(int *) client_socket;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_fd, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        for (int i = 0; i < max_clients; i++) {
            if (clients[i]!= -1 && clients[i]!= client_socket_fd) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket_fd);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (max_clients == MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 16, 0);
            close(client_socket);
            continue;
        }

        clients[max_clients] = client_socket;
        max_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",70,4.5
VULNERABLE,falcon180b-4688.c,yes,41,5,backup_thread,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-4688.c line 41 column 5 function backup_thread
  c:@F@backup_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `source_file'",dereference failure: accessed expired variable pointer,"}

void *backup_thread(void *arg) {
    char source_file[100];
    char dest_file[200];
    strcpy(source_file, (char *)arg);
    strcat(dest_file, ""backup_"");
    strcat(dest_file, source_file);

    FILE *source = fopen(source_file, ""rb"");
    if (source == NULL) {","//Falcon-180B DATASET v1.0 Category: File Backup System ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <pthread.h>

#define MAX_BACKUP_FILES 10

struct backup_file {
    char filename[100];
    time_t timestamp;
};

struct backup_file backup_files[MAX_BACKUP_FILES];
int num_backup_files = 0;

void add_backup_file(char *filename) {
    if (num_backup_files >= MAX_BACKUP_FILES) {
        printf(""Error: Backup file limit reached.\n"");
        return;
    }
    strcpy(backup_files[num_backup_files].filename, filename);
    backup_files[num_backup_files].timestamp = time(NULL);
    num_backup_files++;
}

void print_backup_files() {
    printf(""Backup files:\n"");
    for (int i = 0; i < num_backup_files; i++) {
        printf(""%s (%ld)\n"", backup_files[i].filename, backup_files[i].timestamp);
    }
}

void *backup_thread(void *arg) {
    char source_file[100];
    char dest_file[200];
    strcpy(source_file, (char *)arg);
    strcat(dest_file, ""backup_"");
    strcat(dest_file, source_file);

    FILE *source = fopen(source_file, ""rb"");
    if (source == NULL) {
        printf(""Error: Could not open source file %s.\n"", source_file);
        return NULL;
    }

    FILE *dest = fopen(dest_file, ""wb"");
    if (dest == NULL) {
        printf(""Error: Could not create destination file %s.\n"", dest_file);
        fclose(source);
        return NULL;
    }

    char buffer[1024];
    while (fread(buffer, 1, 1024, source) > 0) {
        fwrite(buffer, 1, 1024, dest);
    }

    fclose(source);
    fclose(dest);

    add_backup_file(dest_file);

    printf(""Backup of %s complete.\n"", source_file);
    return NULL;
}

int main() {
    pthread_t thread_id;
    char source_file[100];

    printf(""Enter source file name: "");
    scanf(""%s"", source_file);

    pthread_create(&thread_id, NULL, backup_thread, (void *)source_file);

    printf(""Press any key to exit...\n"");
    getchar();

    return 0;
}",85,2.25
VULNERABLE,falcon180b-55238.c,yes,18,5,listenToClient,"
  file falcon180b-55238.c line 18 column 5 function listenToClient
","
  c:@F@listenToClient at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientSocket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int clientCount = 0;

void *listenToClient(void *socket) {
    char buffer[BUFFER_SIZE];
    int clientSocket = *(int *)socket;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytesReceived = recv(clientSocket, buffer, BUFFER_SIZE, 0);
","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int clientCount = 0;

void *listenToClient(void *socket) {
    char buffer[BUFFER_SIZE];
    int clientSocket = *(int *)socket;

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytesReceived = recv(clientSocket, buffer, BUFFER_SIZE, 0);

        if (bytesReceived <= 0) {
            close(clientSocket);
            pthread_exit(0);
        }

        printf(""Received message from client %d: %s\n"", clientSocket, buffer);
    }
}

int main() {
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(8080);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    bind(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr));
    listen(serverSocket, 10);

    printf(""Server started on port 8080\n"");

    while (1) {
        int clientSocket = accept(serverSocket, NULL, NULL);

        if (clientSocket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        clientCount++;
        clients[clientCount - 1] = clientSocket;

        pthread_t threadID;
        pthread_create(&threadID, NULL, listenToClient, (void *)&clientSocket);
    }

    return 0;
}",63,3.0
VULNERABLE,gemma7b-20586.c,yes,45,13,main,"
  file gemma7b-20586.c line 45 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `email'",dereference failure: accessed expired variable pointer,"            // Insert user data into database
            break;
        case 2:
            system(""clear"");
            printf(""Enter your email address:"");
            scanf(""%s"", email);

            printf(""Enter your password:"");
            char password[20];

            // Validate user credentials","//Gemma-7B DATASET v1.0 Category: Online Examination System ; Style: visionary
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main()
{
    system(""clear"");
    printf(""Welcome to the Omni-Visionary C Online Examination System!\n"");
    printf(""Please select an option:\n"");
    printf(""1. Register\n"");
    printf(""2. Login\n"");
    printf(""3. View Exam Schedule\n"");
    printf(""4. Take Exam\n"");
    printf(""5. View Results\n"");

    int choice = 0;
    scanf(""%d"", &choice);

    switch (choice)
    {
        case 1:
            system(""clear"");
            printf(""Enter your first name:"");
            char firstName[20];
            scanf(""%s"", firstName);

            printf(""Enter your last name:"");
            char lastName[20];
            scanf(""%s"", lastName);

            printf(""Enter your email address:"");
            char email[50];
            scanf(""%s"", email);

            printf(""Enter your phone number:"");
            int phoneNumber;
            scanf(""%d"", &phoneNumber);

            // Insert user data into database
            break;
        case 2:
            system(""clear"");
            printf(""Enter your email address:"");
            scanf(""%s"", email);

            printf(""Enter your password:"");
            char password[20];

            // Validate user credentials
            break;
        case 3:
            system(""clear"");
            // Display exam schedule
            break;
        case 4:
            system(""clear"");
            // Start the exam
            break;
        case 5:
            system(""clear"");
            // Display exam results
            break;
        default:
            printf(""Invalid choice.\n"");
    }

    printf(""Thank you for using the Omni-Visionary C Online Examination System.\n"");
    system(""pause"");
}",70,6.0
VULNERABLE,falcon180b-4575.c,yes,20,5,handle_client,"
  file falcon180b-4575.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int listen_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    char response[MAX_REQUEST_SIZE];
    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: curious
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_REQUEST_SIZE 1024
#define MAX_CLIENTS 10

int listen_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    char response[MAX_REQUEST_SIZE];
    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Received request: %s\n"", request);
        strcat(response, ""HTTP/1.1 200 OK\r\n"");
        strcat(response, ""Content-Type: text/html\r\n"");
        strcat(response, ""Connection: close\r\n"");
        strcat(response, ""\r\n"");
        strcat(response, ""<html><body><h1>Hello, World!</h1></body></html>"");
        send(client_socket, response, strlen(response), 0);
    }
    close(client_socket);
    num_clients--;
    printf(""Client disconnected\n"");
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }
    if (listen(server_socket, BACKLOG) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }
    printf(""Server listening on port %d\n"", PORT);
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            exit(EXIT_FAILURE);
        }
        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""HTTP/1.1 503 Service Unavailable\r\n"", strlen(""HTTP/1.1 503 Service Unavailable\r\n""), 0);
            close(client_socket);
            continue;
        }
        client_sockets[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
    return 0;
}",79,5.0
VULNERABLE,gpt35-5118.c,yes,23,5,handle_connection,"
  file gpt35-5118.c line 23 column 5 function handle_connection
","
  c:@F@handle_connection at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_fd'",dereference failure: accessed expired variable pointer,"int num_clients = 0;                // Number of connected clients
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // Mutex lock for thread safety

// Function to handle client connections
void *handle_connection(void* arg) {
    int client_fd = *(int*)arg;     // Client file descriptor
    char buffer[1024] = {0};        // Buffer for messages

    // Greetings
    write(client_fd, ""My bounty is as boundless as the sea\nMy love as deep; the more I give to thee\nThe more I have, for both are infinite.\n"", 1024);
    write(client_fd, ""Welcome to our chat! Tell me, dear, who art thou?\n"", 1024);","//FormAI DATASET v1.0 Category: Chat server ; Style: Romeo and Juliet
/*
* A Chat Server example program 
* Written in the style of Romeo and Juliet
*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

// Global variables
int server_socket;                  // File descriptor for server socket
int client_socket[5] = {0};         // File descriptor array of connected clients
int num_clients = 0;                // Number of connected clients
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // Mutex lock for thread safety

// Function to handle client connections
void *handle_connection(void* arg) {
    int client_fd = *(int*)arg;     // Client file descriptor
    char buffer[1024] = {0};        // Buffer for messages
    
    // Greetings
    write(client_fd, ""My bounty is as boundless as the sea\nMy love as deep; the more I give to thee\nThe more I have, for both are infinite.\n"", 1024);
    write(client_fd, ""Welcome to our chat! Tell me, dear, who art thou?\n"", 1024);

    // Loop to receive messages and broadcast to other clients
    while(read(client_fd, buffer, 1024) != 0) {
        // Lock mutex to prevent multiple clients from writing at the same time
        pthread_mutex_lock(&mutex);
        
        // Broadcast message to all other clients
        for(int i=0; i<num_clients; i++) {
            if(client_socket[i] != client_fd) {
                write(client_socket[i], buffer, strlen(buffer));
                write(client_socket[i], ""\n"", 1);
            }
        }
        
        // Unlock mutex
        pthread_mutex_unlock(&mutex);
    }
    
    // Cleanup and goodbyes
    write(client_fd, ""Good night, good night! Parting is such sweet sorrow\nThat I shall say good night till it be morrow.\n"", 1024);
    close(client_fd);
    pthread_exit(NULL);
}

int main() {
    struct sockaddr_in server_address;
    int address_len = sizeof(server_address);    // Address length
    
    // Create server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if(server_socket == -1) {
        perror(""socket failed"");
        exit(EXIT_FAILURE);
    }
    
    // Set server address
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8888);
    
    // Bind server socket
    if(bind(server_socket, (struct sockaddr *)&server_address, address_len) == -1) {
        perror(""bind failed"");
        exit(EXIT_FAILURE);
    }
    
    // Listen for incoming connections
    if(listen(server_socket, 5)) {
        perror(""listen failed"");
        exit(EXIT_FAILURE);
    }
    
    printf(""Server running on port 8888...\n"");

    // Loop to handle incoming connections
    while(1) {
        // Accept incoming connection
        int client_fd = accept(server_socket, (struct sockaddr *)&server_address, (socklen_t*)&address_len);
        if (client_fd == -1) {
            perror(""accept failed"");
            exit(EXIT_FAILURE);
        }
        
        // Add client to client_socket array
        pthread_mutex_lock(&mutex);
        client_socket[num_clients++] = client_fd;
        pthread_mutex_unlock(&mutex);
        
        // Start thread to handle client messages
        pthread_t thread;
        if(pthread_create(&thread, NULL, handle_connection, (void*)&client_fd)) {
            fprintf(stderr, ""Error creating thread\n"");
            exit(EXIT_FAILURE);
        }
    }
    
    return 0;
}",106,5.5
VULNERABLE,falcon180b-29224.c,yes,18,5,handle_client,"
  file falcon180b-29224.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 1234
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, MAX_CLIENTS);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",65,3.0
VULNERABLE,codellama_13b-1696.c,yes,53,13,translate_sentence,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file string.c line 53 column 3 function strcat
  c:@F@strcat at file codellama_13b-1696.c line 53 column 13 function translate_sentence
  c:@F@translate_sentence at file codellama_13b-1696.c line 67 column 30 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `english_word'",dereference failure: accessed expired variable pointer,"    for (int i = 0, j = 0; i < strlen(alien_sentence); i++) {
        // Check if the character is a space or the end of the sentence
        if (alien_sentence[i] == ' ' || alien_sentence[i] == '\0') {
            // Translate the word and add it to the English sentence
            char* english_word = translate(alien_sentence + j);
            strcat(english_sentence, english_word);
            j = i + 1;
        }
    }

    // Return the English translation","//Code Llama-13B DATASET v1.0 Category: Alien Language Translator ; Style: all-encompassing
#include <stdio.h>
#include <string.h>

#define MAX_WORD_LENGTH 100
#define MAX_LINE_LENGTH 1000

// Function to translate an alien language to English
char* translate(char* alien_word) {
    // Check if the alien word is NULL
    if (alien_word == NULL) {
        return NULL;
    }

    // Create a new char array to store the English translation
    char english_word[MAX_WORD_LENGTH];

    // Loop through each character in the alien word
    for (int i = 0; i < strlen(alien_word); i++) {
        // Check if the character is a vowel
        if (alien_word[i] == 'a' || alien_word[i] == 'e' || alien_word[i] == 'i' || alien_word[i] == 'o' || alien_word[i] == 'u') {
            // Replace the character with its corresponding English vowel
            english_word[i] = 'a';
        } else if (alien_word[i] == 'A' || alien_word[i] == 'E' || alien_word[i] == 'I' || alien_word[i] == 'O' || alien_word[i] == 'U') {
            // Replace the character with its corresponding uppercase English vowel
            english_word[i] = 'A';
        } else {
            // Replace the character with its corresponding English consonant
            english_word[i] = 'b';
        }
    }

    // Return the English translation
    return english_word;
}

// Function to translate an entire sentence from an alien language to English
char* translate_sentence(char* alien_sentence) {
    // Check if the alien sentence is NULL
    if (alien_sentence == NULL) {
        return NULL;
    }

    // Create a new char array to store the English translation
    char english_sentence[MAX_LINE_LENGTH];

    // Loop through each word in the alien sentence
    for (int i = 0, j = 0; i < strlen(alien_sentence); i++) {
        // Check if the character is a space or the end of the sentence
        if (alien_sentence[i] == ' ' || alien_sentence[i] == '\0') {
            // Translate the word and add it to the English sentence
            char* english_word = translate(alien_sentence + j);
            strcat(english_sentence, english_word);
            j = i + 1;
        }
    }

    // Return the English translation
    return english_sentence;
}

int main() {
    // Define the alien sentence
    char alien_sentence[] = ""Ghek zghek dghek"";

    // Translate the sentence
    char* english_sentence = translate_sentence(alien_sentence);

    // Print the English translation
    printf(""%s\n"", english_sentence);

    return 0;
}",73,6.333
VULNERABLE,falcon180b-2273.c,yes,18,5,handle_client,"
  file falcon180b-2273.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];
    while (1) {
        memset(buffer, 0, MAX_MSG_SIZE);
        if (recv(client_socket, buffer, MAX_MSG_SIZE, 0) <= 0) {
            close(client_socket);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define MAX_MSG_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_MSG_SIZE];
    while (1) {
        memset(buffer, 0, MAX_MSG_SIZE);
        if (recv(client_socket, buffer, MAX_MSG_SIZE, 0) <= 0) {
            close(client_socket);
            clients[num_clients - 1] = 0;
            num_clients--;
            break;
        }
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }
    printf(""Server listening on port 8080\n"");
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }
        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
        } else {
            clients[num_clients] = client_socket;
            num_clients++;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }
    close(server_socket);
    return 0;
}",74,6.0
VULNERABLE,falcon180b-1604.c,yes,20,5,handle_client,"
  file falcon180b-1604.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_REQUEST_SIZE];

    while (1) {
        memset(buffer, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024
#define BUFFER_SIZE 4096

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[MAX_REQUEST_SIZE];

    while (1) {
        memset(buffer, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, buffer, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client %d disconnected\n"", client_socket);
            close(client_socket);
            return NULL;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Too many clients\n"");
            continue;
        }

        clients[num_clients++] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,3.5
VULNERABLE,gpt35-74252.c,yes,75,24,main,"
  file io.c line 185 column 24 function fread
","
  c:@F@fread at file gpt35-74252.c line 75 column 24 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `record'",dereference failure: accessed expired variable pointer,"                printf(""\nEnter the account number to search for: "");
                scanf(""%d"", &accountNumber);

                fp = fopen(""bank_records.dat"", ""rb"");

                while (fread(&record, sizeof(record), 1, fp)) {
                    if (record.accountNumber == accountNumber) {
                        printf(""\nAccount number\tAccount holder's name\tBalance\n"");
                        printf(""---------------------------------------------------\n"");
                        printf(""%d\t\t%s\t\t%.2f\n"", record.accountNumber, record.name, record.balance);
                        flag = 1;","//FormAI DATASET v1.0 Category: Banking Record System ; Style: genious
#include <stdio.h>
#include <stdlib.h>

struct BankRecord {
    int accountNumber;
    char name[30];
    float balance;
};

void main() {
    int choice, i, accountNumber, flag = 0;
    char name[30];
    float balance;

    printf(""Welcome to the Genius Banking Record System\n"");
    printf(""---------------------------------------------\n"");

    while (1) {
        printf(""\n1. Add a new record"");
        printf(""\n2. Display all records"");
        printf(""\n3. Search for a record"");
        printf(""\n4. Modify a record"");
        printf(""\n5. Delete a record"");
        printf(""\n6. Exit"");

        printf(""\nEnter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""\nEnter the account number: "");
                scanf(""%d"", &accountNumber);

                printf(""Enter the account holder's name: "");
                scanf(""%s"", name);

                printf(""Enter the balance: "");
                scanf(""%f"", &balance);

                FILE *fp;
                fp = fopen(""bank_records.dat"", ""ab""); // Opening the file in append mode

                struct BankRecord record = {accountNumber, name, balance};
                fwrite(&record, sizeof(record), 1, fp); // Writing the record to the file

                fclose(fp);
                printf(""\nRecord added successfully!"");
                break;

            case 2:
                fp = fopen(""bank_records.dat"", ""rb""); // Opening the file in read mode

                if (fp == NULL) {
                    printf(""\nThe record list is empty."");
                    break;
                }

                printf(""\nAccount number\tAccount holder's name\tBalance\n"");
                printf(""---------------------------------------------------\n"");

                while (fread(&record, sizeof(record), 1, fp)) { // Reading records from the file
                    printf(""%d\t\t%s\t\t%.2f\n"", record.accountNumber, record.name, record.balance);
                }

                fclose(fp);
                break;

            case 3:
                printf(""\nEnter the account number to search for: "");
                scanf(""%d"", &accountNumber);

                fp = fopen(""bank_records.dat"", ""rb"");

                while (fread(&record, sizeof(record), 1, fp)) {
                    if (record.accountNumber == accountNumber) {
                        printf(""\nAccount number\tAccount holder's name\tBalance\n"");
                        printf(""---------------------------------------------------\n"");
                        printf(""%d\t\t%s\t\t%.2f\n"", record.accountNumber, record.name, record.balance);
                        flag = 1;
                        break;
                    }
                }

                if (flag == 0) {
                    printf(""\nRecord not found."");
                }

                fclose(fp);
                break;

            case 4:
                printf(""\nEnter the account number to modify: "");
                scanf(""%d"", &accountNumber);

                fp = fopen(""bank_records.dat"", ""rb+"");
                flag = 0;

                while (fread(&record, sizeof(record), 1, fp)) {
                    if (record.accountNumber == accountNumber) {
                        printf(""\nEnter the new account holder's name: "");
                        scanf(""%s"", record.name);

                        printf(""Enter the new balance: "");
                        scanf(""%f"", &record.balance);

                        fseek(fp, -sizeof(record), SEEK_CUR); // Moving the file pointer back by the size of a record
                        fwrite(&record, sizeof(record), 1, fp); // Updating the record in the file

                        flag = 1;
                        break;
                    }
                }

                if (flag == 0) {
                    printf(""\nRecord not found."");
                } else {
                    printf(""\nRecord modified successfully!"");
                }

                fclose(fp);
                break;

            case 5:
                printf(""\nEnter the account number to delete: "");
                scanf(""%d"", &accountNumber);

                fp = fopen(""bank_records.dat"", ""rb"");
                FILE *temp;
                temp = fopen(""temp.dat"", ""wb"");

                flag = 0;

                while (fread(&record, sizeof(record), 1, fp)) {
                    if (record.accountNumber != accountNumber) {
                        fwrite(&record, sizeof(record), 1, temp);
                    } else {
                        flag = 1;
                    }
                }

                fclose(fp);
                fclose(temp);

                remove(""bank_records.dat""); // Deleting the old file
                rename(""temp.dat"", ""bank_records.dat""); // Renaming the temporary file

                if (flag == 0) {
                    printf(""\nRecord not found."");
                } else {
                    printf(""\nRecord deleted successfully!"");
                }

                break;

            case 6:
                exit(0);

            default:
                printf(""\nInvalid choice. Please choose from the menu."");
                break;
        }
    }
}",164,19.0
VULNERABLE,falcon180b-35431.c,yes,21,5,handle_client,"
  file falcon180b-35431.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Metadata Extractor ; Style: distributed
//User: Hey, can you add some comments to the code to make it more understandable?
//ASSISTANT: Sure, here's the updated code with comments:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define SERVER_PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", 16, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}

// Note: This code is not complete and may require additional libraries and headers to compile and run.",73,3.0
VULNERABLE,gemini_pro-23450.c,yes,103,17,main,"
  file gemini_pro-23450.c line 103 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `index'",dereference failure: accessed expired variable pointer,"
                read_email(index);
                break;
            case 3:
                printf(""Enter the index of the email you want to delete: "");
                scanf(""%d"", &index);

                delete_email(index);
                break;
            case 4:
                printf(""Goodbye!\n"");","//GEMINI-pro DATASET v1.0 Category: Email Client ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_EMAIL_SIZE 1024
#define MAX_EMAILS 10

typedef struct Email {
    char sender[64];
    char recipient[64];
    char subject[64];
    char body[MAX_EMAIL_SIZE];
} Email;

Email inbox[MAX_EMAILS];
int inbox_count = 0;

void send_email(char *sender, char *recipient, char *subject, char *body) {
    if (inbox_count >= MAX_EMAILS) {
        printf(""Sorry, your inbox is full. Please delete some emails to make room for new ones.\n"");
        return;
    }

    strcpy(inbox[inbox_count].sender, sender);
    strcpy(inbox[inbox_count].recipient, recipient);
    strcpy(inbox[inbox_count].subject, subject);
    strcpy(inbox[inbox_count].body, body);

    inbox_count++;

    printf(""Email sent successfully!\n"");
}

void read_email(int index) {
    if (index < 0 || index >= inbox_count) {
        printf(""Sorry, that email doesn't exist.\n"");
        return;
    }

    Email email = inbox[index];

    printf(""From: %s\n"", email.sender);
    printf(""To: %s\n"", email.recipient);
    printf(""Subject: %s\n"", email.subject);
    printf(""Body: %s\n"", email.body);
}

void delete_email(int index) {
    if (index < 0 || index >= inbox_count) {
        printf(""Sorry, that email doesn't exist.\n"");
        return;
    }

    for (int i = index; i < inbox_count - 1; i++) {
        inbox[i] = inbox[i + 1];
    }

    inbox_count--;

    printf(""Email deleted successfully!\n"");
}

int main() {
    int choice;
    char sender[64];
    char recipient[64];
    char subject[64];
    char body[MAX_EMAIL_SIZE];

    while (true) {
        printf(""What would you like to do?\n"");
        printf(""1. Send an email\n"");
        printf(""2. Read an email\n"");
        printf(""3. Delete an email\n"");
        printf(""4. Quit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""Enter the sender's email address: "");
                scanf(""%s"", sender);
                printf(""Enter the recipient's email address: "");
                scanf(""%s"", recipient);
                printf(""Enter the subject of the email: "");
                scanf("" %[^\n]"", subject);  // Read the subject line with spaces
                printf(""Enter the body of the email: "");
                scanf("" %[^\n]"", body);  // Read the body with spaces

                send_email(sender, recipient, subject, body);
                break;
            case 2:
                printf(""Enter the index of the email you want to read: "");
                int index;
                scanf(""%d"", &index);

                read_email(index);
                break;
            case 3:
                printf(""Enter the index of the email you want to delete: "");
                scanf(""%d"", &index);

                delete_email(index);
                break;
            case 4:
                printf(""Goodbye!\n"");
                return 0;
            default:
                printf(""Invalid choice. Please enter a number from 1 to 4.\n"");
        }
    }

    return 0;
}",116,3.75
VULNERABLE,gemini_pro-21787.c,yes,23,5,handle_client,"
  file gemini_pro-21787.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `fd'",dereference failure: accessed expired variable pointer,"
client_t clients[MAX_CLIENTS];
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int fd = *(int *)arg;
    char buffer[256];
    int n;

    while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
        // Process the request","//GEMINI-pro DATASET v1.0 Category: Appointment Scheduler ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10

typedef struct {
    int fd;
    char name[256];
} client_t;

client_t clients[MAX_CLIENTS];
pthread_mutex_t clients_mutex = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int fd = *(int *)arg;
    char buffer[256];
    int n;

    while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
        // Process the request
        if (strncmp(buffer, ""PING"", 4) == 0) {
            // Send a PONG response
            write(fd, ""PONG"", 4);
        } else if (strncmp(buffer, ""BOOK"", 4) == 0) {
            // Parse the appointment details
            char *name = strtok(buffer, "" "");
            char *date = strtok(NULL, "" "");
            char *time = strtok(NULL, "" "");

            // Check if the client is already registered
            pthread_mutex_lock(&clients_mutex);
            int i;
            for (i = 0; i < MAX_CLIENTS; i++) {
                if (clients[i].fd == fd) {
                    strcpy(clients[i].name, name);
                    break;
                }
            }
            pthread_mutex_unlock(&clients_mutex);

            // Book the appointment
            printf(""Booked appointment for %s on %s at %s\n"", name, date, time);

            // Send a confirmation message
            write(fd, ""OK"", 2);
        }
    }

    // Close the socket
    close(fd);

    return NULL;
}

int main() {
    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");
        exit(1);
    }

    // Bind the socket to the port
    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(PORT),
        .sin_addr = { .s_addr = INADDR_ANY },
    };

    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        perror(""bind"");
        exit(1);
    }

    // Listen for incoming connections
    if (listen(sockfd, MAX_CLIENTS) == -1) {
        perror(""listen"");
        exit(1);
    }

    // Accept incoming connections
    while (1) {
        int fd = accept(sockfd, NULL, NULL);
        if (fd == -1) {
            perror(""accept"");
            continue;
        }

        // Create a new thread to handle the client
        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, &fd);
    }

    // Close the socket
    close(sockfd);

    return 0;
}",106,6.0
VULNERABLE,falcon180b-60101.c,yes,18,5,handle_client,"
  file falcon180b-60101.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define PORT 8080
#define MAX_CLIENTS 10

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (client_sockets[i]!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,4.0
VULNERABLE,gpt35-2087.c,yes,18,5,handle_client,"
  file gpt35-2087.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientfd'",dereference failure: accessed expired variable pointer,"
int client_count = 0;
int clients[MAX_CLIENTS];

void *handle_client(void *arg) {
    int clientfd = *(int *)arg;
    char buffer[BUF_SIZE];
    char welcome[BUF_SIZE] = ""Welcome to the chat room!\n"";

    // Send welcome message to new client
    if (send(clientfd, welcome, strlen(welcome), 0) == -1) {","//FormAI DATASET v1.0 Category: Socket programming ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024

int client_count = 0;
int clients[MAX_CLIENTS];

void *handle_client(void *arg) {
    int clientfd = *(int *)arg;
    char buffer[BUF_SIZE];
    char welcome[BUF_SIZE] = ""Welcome to the chat room!\n"";

    // Send welcome message to new client
    if (send(clientfd, welcome, strlen(welcome), 0) == -1) {
        perror(""Failed to send welcome message"");
        return NULL;
    }

    // Add client to list of active clients
    clients[client_count++] = clientfd;

    // Start chat loop
    while (1) {
        int nbytes_recv = recv(clientfd, buffer, BUF_SIZE, 0);
        if (nbytes_recv <= 0) {
            // Handle disconnected client
            for (int i = 0; i < client_count; i++) {
                if (clients[i] == clientfd) {
                    close(clients[i]);
                    clients[i] = -1;
                    break;
                }
            }
            break;
        } else {
            // Forward message to all clients
            for (int i = 0; i < client_count; i++) {
                if (clients[i] != -1 && clients[i] != clientfd) {
                    if (send(clients[i], buffer, nbytes_recv, 0) == -1) {
                        perror(""Failed to forward message"");
                    }
                }
            }
        }
    }

    // Remove client from list of active clients
    for (int i = 0; i < client_count; i++) {
        if (clients[i] == clientfd) {
            clients[i] = -1;
            break;
        }
    }

    close(clientfd);
    return NULL;
}

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sockfd == -1) {
        perror(""Failed to create socket"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9001);
    addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        perror(""Failed to bind socket"");
        exit(EXIT_FAILURE);
    }

    if (listen(sockfd, MAX_CLIENTS) == -1) {
        perror(""Failed to listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server started on port 9001...\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t len = sizeof(client_addr);
        int clientfd = accept(sockfd, (struct sockaddr *)&client_addr, &len);

        if (clientfd == -1) {
            perror(""Failed to accept connection"");
            continue;
        }

        pthread_t tid;
        if (pthread_create(&tid, NULL, handle_client, &clientfd) != 0) {
            perror(""Failed to create thread"");
            continue;
        }

        // Detach thread to avoid memory leaks
        if (pthread_detach(tid) != 0) {
            perror(""Failed to detach thread"");
            continue;
        }
    }

    return 0;
}",116,10.0
VULNERABLE,codellama_13b-10799.c,yes,25,5,check_password,"
  file codellama_13b-10799.c line 25 column 5 function check_password
","
  c:@F@check_password at file codellama_13b-10799.c line 56 column 9 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `password'",dereference failure: accessed expired variable pointer,"
// Function to check if a password is valid
int check_password(char* password) {
  int i;
  for (i = 0; i < PASSWORD_LENGTH; i++) {
    if (password[i] < 'a' || password[i] > 'z') {
      return 0;
    }
  }
  return 1;
}","//Code Llama-13B DATASET v1.0 Category: Password management ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define PASSWORD_LENGTH 12
#define MAX_PASSWORD_TRIES 3

// Function to generate a random password
char* generate_password() {
  char password[PASSWORD_LENGTH + 1];
  int i;
  for (i = 0; i < PASSWORD_LENGTH; i++) {
    password[i] = 'a' + rand() % 26;
  }
  password[PASSWORD_LENGTH] = '\0';
  return password;
}

// Function to check if a password is valid
int check_password(char* password) {
  int i;
  for (i = 0; i < PASSWORD_LENGTH; i++) {
    if (password[i] < 'a' || password[i] > 'z') {
      return 0;
    }
  }
  return 1;
}

// Function to prompt the user for a password
char* prompt_password() {
  char password[PASSWORD_LENGTH + 1];
  int i;
  printf(""Enter your password: "");
  fgets(password, PASSWORD_LENGTH + 1, stdin);
  password[strlen(password) - 1] = '\0';
  return password;
}

// Function to display the password
void display_password(char* password) {
  int i;
  for (i = 0; i < PASSWORD_LENGTH; i++) {
    printf(""%c"", password[i]);
  }
  printf(""\n"");
}

int main() {
  int tries = 0;
  char* password;
  while (tries < MAX_PASSWORD_TRIES) {
    password = prompt_password();
    if (check_password(password)) {
      display_password(password);
      break;
    } else {
      tries++;
      printf(""Invalid password. Try again.\n"");
    }
  }
  if (tries == MAX_PASSWORD_TRIES) {
    printf(""Maximum number of tries exceeded. Goodbye.\n"");
  }
  return 0;
}",68,2.6
VULNERABLE,falcon180b-44928.c,yes,19,5,handle_client,"
  file falcon180b-44928.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <time.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *client_socket) {
    int client_socket_copy = *((int *) client_socket);
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket_copy, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket_copy) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket_copy);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            break;
        }
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }
        clients[num_clients] = client_socket;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 3) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections(server_socket);

    return 0;
}",82,4.333
VULNERABLE,falcon180b-3753.c,yes,22,5,scanner,"
  file falcon180b-3753.c line 22 column 5 function scanner
","
  c:@F@scanner at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `interface_index'",dereference failure: accessed expired variable pointer,"char *interfaces[MAX_INTERFACES];
int num_interfaces;
pthread_t threads[MAX_THREADS];

void *scanner(void *arg) {
    int interface_index = *(int *)arg;
    char buffer[PACKET_SIZE];
    while (1) {
        int bytes_received = recvfrom(sock, buffer, PACKET_SIZE, 0, NULL, NULL);
        if (bytes_received <= 0) {
            printf(""Error receiving packet on interface %s\n"", interfaces[interface_index]);","//Falcon-180B DATASET v1.0 Category: Wireless Network Scanner ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PACKET_SIZE 1024
#define MAX_INTERFACES 10
#define MAX_THREADS 10

int sock;
struct sockaddr_in server;
char *interfaces[MAX_INTERFACES];
int num_interfaces;
pthread_t threads[MAX_THREADS];

void *scanner(void *arg) {
    int interface_index = *(int *)arg;
    char buffer[PACKET_SIZE];
    while (1) {
        int bytes_received = recvfrom(sock, buffer, PACKET_SIZE, 0, NULL, NULL);
        if (bytes_received <= 0) {
            printf(""Error receiving packet on interface %s\n"", interfaces[interface_index]);
            break;
        }
        printf(""Received packet on interface %s: %s\n"", interfaces[interface_index], buffer);
    }
    return NULL;
}

void start_scanner(int interface_index) {
    pthread_create(&threads[interface_index], NULL, scanner, &interface_index);
}

void *listener(void *arg) {
    char buffer[PACKET_SIZE];
    while (1) {
        int bytes_received = recvfrom(sock, buffer, PACKET_SIZE, 0, NULL, NULL);
        if (bytes_received <= 0) {
            printf(""Error receiving packet\n"");
            break;
        }
        printf(""Received packet: %s\n"", buffer);
        for (int i = 0; i < num_interfaces; i++) {
            start_scanner(i);
        }
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc!= 3) {
        printf(""Usage: %s <interface1> <interface2>... <interfaceN>\n"", argv[0]);
        return 1;
    }
    num_interfaces = 0;
    for (int i = 1; i < argc; i++) {
        int result = if_nametoindex(argv[i]);
        if (result == 0) {
            printf(""Error: Invalid interface name %s\n"", argv[i]);
            return 1;
        }
        interfaces[num_interfaces++] = argv[i];
    }
    sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
    if (sock == -1) {
        printf(""Error creating socket: %s\n"", strerror(errno));
        return 1;
    }
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(12345);
    if (bind(sock, (struct sockaddr *)&server, sizeof(server)) == -1) {
        printf(""Error binding socket: %s\n"", strerror(errno));
        return 1;
    }
    printf(""Listening for packets...\n"");
    pthread_t listener_thread;
    pthread_create(&listener_thread, NULL, listener, NULL);
    pthread_join(listener_thread, NULL);
    return 0;
}",86,3.5
VULNERABLE,gpt35-70238.c,yes,150,17,main,"
  file gpt35-70238.c line 150 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `username'",dereference failure: accessed expired variable pointer,"                deleteAccount(passwords, numPasswords, username);
                numPasswords--;
                break;
            case 3:
                printf(""Enter username of account to change password: "");
                scanf(""%s"", username);
                changePassword(passwords, numPasswords, username);
                break;
            case 4:
                printAccounts(passwords, numPasswords);
                break;","//FormAI DATASET v1.0 Category: Password management ; Style: ephemeral
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_PASSWORDS 100
#define MAX_LENGTH 50

// Struct for storing username and password
typedef struct {
    char username[MAX_LENGTH];
    char password[MAX_LENGTH];
} Account;

// Function to generate a random password
char* generatePassword(int length) {
    char* password = malloc(length+1);
    char characters[] = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"";
    int numChars = strlen(characters);
    srand(time(NULL)); // Seed random number generator with current time

    for (int i = 0; i < length; i++) {
        int randomIndex = rand() % numChars;
        password[i] = characters[randomIndex];
    }

    password[length] = '\0';
    return password;
}

// Function to add a new account to the password manager
void addAccount(Account* passwords, int numPasswords) {
    if (numPasswords >= MAX_PASSWORDS) {
        printf(""Cannot add more passwords. Maximum number of passwords reached.\n"");
        return;
    }

    printf(""Enter username: "");
    scanf(""%s"", passwords[numPasswords].username);

    printf(""Do you want to generate a random password? (y/n) "");
    char choice;
    scanf("" %c"", &choice);

    if (choice == 'y' || choice == 'Y') {
        char* password = generatePassword(10); // Generate a random 10 character password
        strcpy(passwords[numPasswords].password, password);
        printf(""Generated password: %s\n"", password);
        free(password);
    } else {
        // Otherwise, ask the user to enter a password
        printf(""Enter password: "");
        scanf(""%s"", passwords[numPasswords].password);
    }

    printf(""Account added successfully.\n"");
}

// Function to find an account by its username
int findAccount(Account* passwords, int numPasswords, char* username) {
    for (int i = 0; i < numPasswords; i++) {
        if (strcmp(passwords[i].username, username) == 0) {
            return i;
        }
    }

    return -1; // Account not found
}

// Function to delete an account
void deleteAccount(Account* passwords, int numPasswords, char* username) {
    int index = findAccount(passwords, numPasswords, username);

    if (index == -1) {
        printf(""Account not found.\n"");
        return;
    }

    // Shift all accounts after the deleted account back by one index
    for (int i = index; i < numPasswords-1; i++) {
        passwords[i] = passwords[i+1];
    }

    printf(""Account deleted successfully.\n"");
}

// Function to change a password
void changePassword(Account* passwords, int numPasswords, char* username) {
    int index = findAccount(passwords, numPasswords, username);

    if (index == -1) {
        printf(""Account not found.\n"");
        return;
    }

    // Generate a new random password and set it for the account
    char* newPassword = generatePassword(10);
    strcpy(passwords[index].password, newPassword);
    printf(""New password: %s\n"", newPassword);
    free(newPassword);
}

// Function to print all accounts
void printAccounts(Account* passwords, int numPasswords) {
    if (numPasswords == 0) {
        printf(""No passwords stored.\n"");
        return;
    }

    printf(""Accounts:\n"");

    for (int i = 0; i < numPasswords; i++) {
        printf(""%s: %s\n"", passwords[i].username, passwords[i].password);
    }
}

int main() {
    Account passwords[MAX_PASSWORDS]; // Array to store accounts
    int numPasswords = 0; // Keep track of number of accounts stored

    // Loop infinitely until the user chooses to exit
    while (true) {
        printf(""\n*** PASSWORD MANAGER ***\n"");
        printf(""1. Add account\n"");
        printf(""2. Delete account\n"");
        printf(""3. Change password\n"");
        printf(""4. Show accounts\n"");
        printf(""5. Exit\n"");
        printf(""Enter choice (1-5): "");

        int choice;
        scanf(""%d"", &choice);

        switch(choice) {
            case 1:
                addAccount(passwords, numPasswords);
                numPasswords++;
                break;
            case 2:
                printf(""Enter username of account to delete: "");
                char username[MAX_LENGTH];
                scanf(""%s"", username);
                deleteAccount(passwords, numPasswords, username);
                numPasswords--;
                break;
            case 3:
                printf(""Enter username of account to change password: "");
                scanf(""%s"", username);
                changePassword(passwords, numPasswords, username);
                break;
            case 4:
                printAccounts(passwords, numPasswords);
                break;
            case 5:
                exit(0);
            default:
                printf(""Invalid choice. Please enter a number between 1 and 5.\n"");
        }
    }

    return 0;
}",164,3.429
VULNERABLE,falcon180b-68951.c,yes,19,5,handle_client,"
  file falcon180b-68951.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080
#define SERVER_IP ""127.0.0.1""

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        int i;
        for (i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            break;
        }
        printf(""Client connected on socket %d\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        clients[num_clients++] = client_socket;
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(PORT);
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }
    printf(""Server listening on port %d\n"", PORT);
    accept_connections(server_socket);
    return 0;
}",74,4.0
VULNERABLE,falcon180b-47262.c,yes,22,5,handle_client,"
  file falcon180b-47262.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Email Client ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080
#define SERVER_IP ""127.0.0.1""

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

void accept_clients() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr);
    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }
    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }
    while (1) {
        printf(""Waiting for client to connect...\n"");
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        printf(""Client connected on socket %d\n"", client_socket);
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        client_sockets[num_clients++] = client_socket;
    }
}

int main() {
    srand(time(NULL));
    accept_clients();
    return 0;
}",74,3.333
VULNERABLE,gpt35-63664.c,yes,73,5,connection_handler,"
  file gpt35-63664.c line 73 column 5 function connection_handler
","
  c:@F@connection_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `newSocket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *connection_handler(void *socket_desc) {
    // Get socket descriptor
    int newSocket = *(int *)socket_desc;
    char client_message[2000];

    // Send message to client
    char *message = ""Welcome to the chat server.\n"";
    write(newSocket, message, strlen(message));","//FormAI DATASET v1.0 Category: Chat server ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10

void *connection_handler(void *);

int main(int argc, char const *argv[]) {
    int serverSocket, newSocket, c;
    struct sockaddr_in server, client;
    char *message;

    // Create socket
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket == -1) {
        printf(""Error: Failed to create socket.\n"");
        return 1;
    }

    // Prepare sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    // Bind
    if (bind(serverSocket, (struct sockaddr *)&server, sizeof(server)) < 0) {
        printf(""Error: Failed to bind the socket.\n"");
        return 1;
    }

    // Listen
    listen(serverSocket, MAX_CLIENTS);

    // Accept and incoming connection
    printf(""Waiting for incoming connections...\n"");
    c = sizeof(struct sockaddr_in);

    while ((newSocket = accept(serverSocket, (struct sockaddr *)&client, (socklen_t *)&c))) {
        printf(""Connection accepted.\n"");

        // Reply to client
        message = ""Connected to chat server.\n"";
        write(newSocket, message, strlen(message));

        // Create new thread for the connection
        pthread_t sniffer_thread;
        if (pthread_create(&sniffer_thread, NULL, connection_handler, (void *)&newSocket) < 0) {
            printf(""Error: Failed to create thread.\n"");
            return 1;
        }

        // Thread detached
        pthread_detach(sniffer_thread);
    }

    if (newSocket < 0) {
        printf(""Error: Failed to accept the connection.\n"");
        return 1;
    }

    return 0;
}

void *connection_handler(void *socket_desc) {
    // Get socket descriptor
    int newSocket = *(int *)socket_desc;
    char client_message[2000];

    // Send message to client
    char *message = ""Welcome to the chat server.\n"";
    write(newSocket, message, strlen(message));

    // Receive client message
    while (recv(newSocket, client_message, 2000, 0) > 0) {
        printf(""Client: %s"", client_message);

        // Send message to client
        printf(""Server: "");
        fgets(client_message, 2000, stdin);
        write(newSocket, client_message, strlen(client_message));
    }

    if (recv(newSocket, client_message, 2000, 0) == 0) {
        printf(""Client disconnected.\n"");
        fflush(stdout);
    } else {
        printf(""Error: Failed to receive message from the client.\n"");
    }

    // Free the socket pointer
    free(socket_desc);

    return 0;
}",101,4.5
VULNERABLE,falcon180b-36023.c,yes,19,5,thread_client,"
  file falcon180b-36023.c line 19 column 5 function thread_client
","
  c:@F@thread_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"int listen_sock = 0;
int client_socks[MAX_CLIENTS] = { 0 };
int num_clients = 0;

void *thread_client(void *arg) {
    int sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define LISTEN_PORT 8080

int listen_sock = 0;
int client_socks[MAX_CLIENTS] = { 0 };
int num_clients = 0;

void *thread_client(void *arg) {
    int sock = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        recv(sock, buffer, BUFFER_SIZE, 0);
        printf(""Client %d: %s\n"", sock, buffer);
        send(sock, buffer, strlen(buffer), 0);
    }

    close(sock);
    pthread_exit(0);
}

int main() {
    int listen_sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(LISTEN_PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(listen_sock, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(listen_sock, 5);

    printf(""Server is listening on port %d\n"", LISTEN_PORT);

    while (1) {
        int client_sock = accept(listen_sock, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_sock, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_sock);
        } else {
            client_socks[num_clients++] = client_sock;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, thread_client, (void *) &client_sock);
        }
    }

    close(listen_sock);
    return 0;
}",61,2.5
VULNERABLE,falcon180b-34059.c,yes,20,5,handle_client,"
  file falcon180b-34059.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int connections[MAX_CONNECTIONS];
int num_connections = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chess engine ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CONNECTIONS 10
#define BUFFER_SIZE 1024

int connections[MAX_CONNECTIONS];
int num_connections = 0;

void* handle_client(void* arg) {
    int client_socket = *(int*) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(12345);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr*) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CONNECTIONS);

    printf(""Server started on port 12345\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_connections >= MAX_CONNECTIONS) {
            send(client_socket, ""Server is full\n"", 16, 0);
            close(client_socket);
        } else {
            connections[num_connections++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void*) &client_socket);
        }
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-6268.c,yes,19,5,handle_client,"
  file falcon180b-6268.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];

    while (1) {
        memset(request, 0, MAX_REQUEST_SIZE);
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent request: %s\n"", client_socket, request);

        // Process request here

        memset(request, 0, MAX_REQUEST_SIZE);
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        clients[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    close(server_socket);
    return 0;
}",89,5.0
VULNERABLE,falcon180b-66410.c,yes,18,5,handle_client,"
  file falcon180b-66410.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

void accept_connections() {
    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            break;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
        client_sockets[num_clients++] = client_socket;
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket == -1) {
            break;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
        client_sockets[num_clients++] = client_socket;
    }

    return 0;
}",67,3.0
VULNERABLE,falcon180b-46269.c,yes,21,5,handle_client,"
  file falcon180b-46269.c line 21 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char request[MAX_REQUEST_SIZE];
    int bytes_received = 0;

    while ((bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0)) > 0) {
        char *token;","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 2048

int clients[MAX_CLIENTS];
int num_clients = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char request[MAX_REQUEST_SIZE];
    int bytes_received = 0;

    while ((bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0)) > 0) {
        char *token;
        char *method = strtok_r(request, "" "", &token);
        char *path = strtok_r(NULL, "" "", &token);

        if (strcasecmp(method, ""GET"") == 0 && strcasecmp(path, ""/"") == 0) {
            // Send response for GET / request
            send(client_socket, ""HTTP/1.1 200 OK\r\nContent-Length: 12\r\n\r\nHello, World!"", 50, 0);
        } else {
            // Send response for all other requests
            send(client_socket, ""HTTP/1.1 404 Not Found\r\nContent-Length: 16\r\n\r\n404 Not Found"", 46, 0);
        }
    }

    close(client_socket);
    return NULL;
}

void accept_connections(int server_socket) {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket >= 0) {
            pthread_mutex_lock(&lock);
            clients[num_clients] = client_socket;
            num_clients++;
            pthread_mutex_unlock(&lock);

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, &client_socket);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket < 0) {
        printf(""Error creating socket\n"");
        return 1;
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 10) < 0) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");
    accept_connections(server_socket);

    return 0;
}",87,3.667
VULNERABLE,falcon180b-28077.c,yes,22,5,handle_client,"
  file falcon180b-28077.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
struct sockaddr_in server_addr;
pthread_t thread_id;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Simple Web Server ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BACKLOG 10
#define BUF_SIZE 1024
#define SERVER_PORT 8080

// Global variables
int server_socket;
struct sockaddr_in server_addr;
pthread_t thread_id;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];
    while (1) {
        memset(buffer, 0, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Received message: %s\n"", buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        printf(""Client connected\n"");
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",58,2.5
VULNERABLE,falcon180b-3521.c,yes,20,5,handle_client,"
  file falcon180b-3521.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t threads[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    pthread_exit(0);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",72,3.0
VULNERABLE,falcon180b-61869.c,yes,18,5,handle_client,"
  file falcon180b-61869.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int listen_socket;
int client_sockets[MAX_CONNECTIONS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        bzero(buffer, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Simple HTTP Proxy ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define BUF_SIZE 1024
#define MAX_CONNECTIONS 10

int listen_socket;
int client_sockets[MAX_CONNECTIONS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        bzero(buffer, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(listen_socket, NULL, NULL);

        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients >= MAX_CONNECTIONS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, &client_socket);
    }
}

int main() {
    int opt = 1;
    int port = 8080;

    setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(listen_socket, (struct sockaddr *) &server_addr, sizeof(server_addr))!= 0) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(listen_socket, MAX_CONNECTIONS)!= 0) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    accept_connections();

    return 0;
}",83,3.333
VULNERABLE,gpt35-14151.c,yes,71,9,main,"
  file gpt35-14151.c line 71 column 9 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `bulbId'",dereference failure: accessed expired variable pointer,"        toggleBulb(&bulbs[bulbId-1]);
        break;
      case 2:
        // Set the brightness level of a bulb
        printf(""\nEnter the bulb ID: "");
        scanf(""%d"", &bulbId);
        if (bulbId < 1 || bulbId > MAX_BULBS) {
          printf(""Invalid bulb ID!\n"");
          break;
        }
        printf(""Enter the brightness level (0-100): "");","//FormAI DATASET v1.0 Category: Smart home light control ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_BULBS 10

// Bulb struct definition
typedef struct {
  int id;
  bool isOn;
  int brightness;
} Bulb;

// Function to create a new Bulb
Bulb createBulb(int id) {
  Bulb bulb = {id, false, 0};
  return bulb;
}

// Function to turn on/off a bulb
void toggleBulb(Bulb* b) {
  b->isOn = !b->isOn;
  printf(""Bulb %d is now %s\n"", b->id, b->isOn ? ""on"" : ""off"");
}

// Function to set the brightness level of a bulb
void setBrightness(Bulb* b, int brightness) {
  b->brightness = brightness;
  printf(""Bulb %d brightness set to %d%%\n"", b->id, b->brightness);
}

int main() {
  Bulb bulbs[MAX_BULBS];

  // Initialize the bulbs
  for (int i = 0; i < MAX_BULBS; i++) {
    bulbs[i] = createBulb(i+1);
  }

  // Welcome message
  printf(""Welcome to Smart Home Light Control!\n"");

  // Main loop
  while (true) {
    // Print options
    printf(""\nChoose an option:\n"");
    printf(""1 - Turn on/off a bulb\n"");
    printf(""2 - Set the brightness level of a bulb\n"");
    printf(""3 - Quit\n"");

    // Get user input
    int option;
    scanf(""%d"", &option);

    switch (option) {
      case 1:
        // Turn on/off a bulb
        printf(""\nEnter the bulb ID: "");
        int bulbId;
        scanf(""%d"", &bulbId);
        if (bulbId < 1 || bulbId > MAX_BULBS) {
          printf(""Invalid bulb ID!\n"");
          break;
        }
        toggleBulb(&bulbs[bulbId-1]);
        break;
      case 2:
        // Set the brightness level of a bulb
        printf(""\nEnter the bulb ID: "");
        scanf(""%d"", &bulbId);
        if (bulbId < 1 || bulbId > MAX_BULBS) {
          printf(""Invalid bulb ID!\n"");
          break;
        }
        printf(""Enter the brightness level (0-100): "");
        int brightness;
        scanf(""%d"", &brightness);
        if (brightness < 0 || brightness > 100) {
          printf(""Invalid brightness level!\n"");
          break;
        }
        setBrightness(&bulbs[bulbId-1], brightness);
        break;
      case 3:
        // Quit
        printf(""\nGoodbye!\n\n"");
        exit(0);
      default:
        printf(""Invalid option!\n"");
        break;
    }
  }

  return 0;
}",96,4.0
VULNERABLE,falcon180b-24691.c,yes,23,5,handle_client,"
  file falcon180b-24691.c line 23 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <pthread.h>
#include <semaphore.h>

#define BUFFER_SIZE 1024
#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        num_clients++;
        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
            continue;
        }
        clients[num_clients - 1] = client_socket;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",69,3.5
VULNERABLE,falcon180b-59834.c,yes,20,5,handle_client,"
  file falcon180b-59834.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Wireless Network Scanner ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(0);
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (client_sockets[i]!= sender_socket) {
            send(client_sockets[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    while (1) {
        struct sockaddr_in server_addr, client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",67,3.0
VULNERABLE,falcon180b-15481.c,yes,36,17,main,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file falcon180b-15481.c line 36 column 17 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `word'",dereference failure: accessed expired variable pointer,"        frequency->word = strdup(word);
        frequency->frequency = rand() % 100 + 1;
        totalFrequency += frequency->frequency;

        for (int i = 0; i < numWords; i++) {
            if (strcmp(words[i], word) == 0) {
                free(frequency->word);
                free(frequency);
                i--;
            }
        }","//Falcon-180B DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define MAX_WORDS 1000
#define MAX_WORD_LENGTH 20

typedef struct {
    char *word;
    int frequency;
} WordFrequency;

int main() {
    srand(time(NULL));

    char *words[MAX_WORDS];
    int numWords = 0;
    int totalFrequency = 0;

    while (numWords < MAX_WORDS && totalFrequency < 100) {
        char word[MAX_WORD_LENGTH];
        int length = rand() % MAX_WORD_LENGTH + 1;
        for (int i = 0; i < length; i++) {
            word[i] = rand() % 26 + 'a';
        }
        word[length] = '\0';

        WordFrequency *frequency = (WordFrequency *)malloc(sizeof(WordFrequency));
        frequency->word = strdup(word);
        frequency->frequency = rand() % 100 + 1;
        totalFrequency += frequency->frequency;

        for (int i = 0; i < numWords; i++) {
            if (strcmp(words[i], word) == 0) {
                free(frequency->word);
                free(frequency);
                i--;
            }
        }

        words[numWords++] = word;
    }

    printf(""The top 10 most frequent words are:\n"");
    for (int i = 0; i < numWords; i++) {
        printf(""%s: %d\n"", words[i], rand() % 100 + 1);
    }

    return 0;
}",52,7.0
VULNERABLE,falcon180b-24175.c,yes,16,5,handle_client,"
  file falcon180b-24175.c line 16 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"#define SERVER_IP ""127.0.0.1""
#define BUFFER_SIZE 1024

// Function to handle client connection
void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define SERVER_PORT 8080
#define SERVER_IP ""127.0.0.1""
#define BUFFER_SIZE 1024

// Function to handle client connection
void *handle_client(void *socket_desc) {
    int client_socket = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            printf(""Client disconnected\n"");
            close(client_socket);
            pthread_exit(NULL);
        }

        printf(""Received message: %s\n"", buffer);

        // Send response to client
        send(client_socket, ""Response from server\n"", strlen(""Response from server\n""), 0);
    }

    return NULL;
}

// Function to create socket and listen for client connections
int create_socket() {
    int socket_fd;
    struct sockaddr_in server_addr;

    socket_fd = socket(AF_INET, SOCK_STREAM, 0);

    if(socket_fd == -1) {
        printf(""Socket creation failed\n"");
        exit(1);
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(SERVER_PORT);

    if(bind(socket_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        printf(""Bind failed\n"");
        exit(1);
    }

    if(listen(socket_fd, 5) == -1) {
        printf(""Listen failed\n"");
        exit(1);
    }

    printf(""Socket created and listening on port %d\n"", SERVER_PORT);

    return socket_fd;
}

// Main function to start server and handle client connections
int main() {
    int socket_fd = create_socket();

    while(1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(socket_fd, (struct sockaddr *)&client_addr, &addr_size);

        if(client_socket == -1) {
            printf(""Client connection failed\n"");
            continue;
        }

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",88,3.333
VULNERABLE,falcon180b-22013.c,yes,19,5,handle_client,"
  file falcon180b-22013.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Socket programming ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", sock, buffer);

        // Send message to all connected clients
        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= sock) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(sock);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 3);

    while (1) {
        printf(""Waiting for client connection...\n"");
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        printf(""Client %d connected.\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",76,4.0
VULNERABLE,falcon180b-53588.c,yes,18,5,handle_client,"
  file falcon180b-53588.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent message: %s\n"", client_socket, buffer);

        // Send message to all clients
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full"", strlen(""Server is full""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,falcon180b-21261.c,yes,19,5,handle_client,"
  file falcon180b-21261.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Client Server Application ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(0);
}

void accept_connections() {
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", 45, 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char *) &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) < 0) {
        printf(""Error binding socket\n"");
        return 1;
    }

    if (listen(server_socket, 3) < 0) {
        printf(""Error listening on socket\n"");
        return 1;
    }

    printf(""Server is listening on port %d\n"", PORT);

    accept_connections();

    return 0;
}",85,3.667
VULNERABLE,falcon180b-33798.c,yes,20,5,handle_client,"
  file falcon180b-33798.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: TCP/IP Programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define SERVER_PORT 8080
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        char message[BUFFER_SIZE];
        sprintf(message, ""Client %d: %s"", client_socket, buffer);
        send(client_socket, message, strlen(message), 0);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port %d\n"", SERVER_PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (client_socket < 0) {
            printf(""Error accepting connection\n"");
            continue;
        }

        if (num_clients == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,3.5
VULNERABLE,falcon180b-24110.c,yes,17,5,handle_client,"
  file falcon180b-24110.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        fprintf(stdout, ""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        fprintf(stderr, ""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        fprintf(stderr, ""Error binding socket\n"");
        exit(2);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        fprintf(stderr, ""Error listening on socket\n"");
        exit(3);
    }

    fprintf(stdout, ""Server is listening on port 8080\n"");

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_size);

        if (client_socket == -1) {
            fprintf(stderr, ""Error accepting connection\n"");
            exit(4);
        }

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            fprintf(stderr, ""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",85,5.0
VULNERABLE,gpt35-37139.c,yes,194,52,parse_tree,"
  file string.c line 92 column 5 function strcmp
","
  c:@F@strcmp at file gpt35-37139.c line 194 column 52 function parse_tree
  c:@F@parse_tree at file gpt35-37139.c line 220 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `tag_name'",dereference failure: accessed expired variable pointer,"            printf("" />\n"");
        }
        else {
            printf("">%s</%s>\n"", parser->node.value, parser->node.name);
        }
        if (strcmp(parser->node.name, ""/"") != 0 && strcmp(parser->node.name, ""?xml"") != 0) {
            parser->depth++;
            parse_tree(parser);
            parser->depth--;
        }
    }","//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: rigorous
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define MAX_DEPTH 100

struct XMLNode {
    char* name; // tag name
    char* value; // tag value
    int depth; // depth of the node in the XML tree
};

struct XMLParser {
    FILE* file; // file pointer
    int depth; // current depth of the parsed node
    struct XMLNode node; // current parsed node
};

// function to create a new XML node
struct XMLNode* new_node(const char* name, const char* value, int depth) {
    struct XMLNode* node = (struct XMLNode*)malloc(sizeof(struct XMLNode));
    node->name = (char*)malloc(sizeof(char) * (strlen(name) + 1));
    strcpy(node->name, name);
    if (value != NULL) {
        node->value = (char*)malloc(sizeof(char) * (strlen(value) + 1));
        strcpy(node->value, value);
    }
    else {
        node->value = NULL;
    }
    node->depth = depth;
    return node;
}

// function to free an XML node
void free_node(struct XMLNode* node) {
    free(node->name);
    if (node->value != NULL) {
        free(node->value);
    }
    free(node);
}

// function to parse the next tag from the XML file
int parse_tag(struct XMLParser* parser) {
    int c;
    char tag_name[100], tag_value[100];
    int name_len = 0, value_len = 0;

    // skip whitespace
    do {
        c = fgetc(parser->file);
        if (c == EOF) {
            return 0;
        }
    } while (c == ' ' || c == '\t' || c == '\n');

    // parse tag name
    if (c == '<') {
        // skip the opening '<'
        c = fgetc(parser->file);

        while (c != ' ' && c != '>' && c != '/') {
            if (name_len < 99) {
                tag_name[name_len++] = c;
            }
            c = fgetc(parser->file);
        }
        tag_name[name_len] = '\0';

        // parse attributes
        while (c != '>') {
            if (c == '/') {
                // empty tag
                c = fgetc(parser->file);
                if (c != '>') {
                    return 0;
                }
                parser->node.name = tag_name;
                parser->node.value = NULL;
                parser->node.depth = parser->depth;
                return 1;
            }

            name_len = 0;
            value_len = 0;
            while (c != '=' && c != ' ') {
                c = fgetc(parser->file);
                if (c == EOF) {
                    return 0;
                }
            }
            if (c == ' ') {
                c = fgetc(parser->file);
            }
            while (c != '""' && c != '\'') {
                c = fgetc(parser->file);
                if (c == EOF) {
                    return 0;
                }
            }
            c = fgetc(parser->file);
            while (c != '""' && c != '\'') {
                if (value_len < 99) {
                    tag_value[value_len++] = c;
                }
                c = fgetc(parser->file);
                if (c == EOF) {
                    return 0;
                }
            }
            tag_value[value_len] = '\0';

            // skip whitespace after attribute
            do {
                c = fgetc(parser->file);
            } while (c == ' ' || c == '\t' || c == '\n');
        }

        // parse tag value
        name_len = 0;
        value_len = 0;
        while (1) {
            c = fgetc(parser->file);
            if (c == '<') {
                // end of tag
                break;
            }
            else if (c == '&') {
                // parse escape sequence
                char esc[10];
                int esc_len = 0;
                while (c != ';') {
                    c = fgetc(parser->file);
                    if (esc_len < 9) {
                        esc[esc_len++] = c;
                    }
                }
                esc[esc_len - 1] = '\0';
                if (strcmp(esc, ""lt"") == 0) {
                    tag_value[value_len++] = '<';
                }
                else if (strcmp(esc, ""gt"") == 0) {
                    tag_value[value_len++] = '>';
                }
                else if (strcmp(esc, ""amp"") == 0) {
                    tag_value[value_len++] = '&';
                }
                else if (strcmp(esc, ""apos"") == 0) {
                    tag_value[value_len++] = '\'';
                }
                else if (strcmp(esc, ""quot"") == 0) {
                    tag_value[value_len++] = '""';
                }
                else {
                    // unknown escape sequence
                    return 0;
                }
            }
            else {
                if (value_len < 99) {
                    tag_value[value_len++] = c;
                }
            }
            if (c == EOF) {
                return 0;
            }
        }
        tag_value[value_len] = '\0';

        // create new node
        parser->node.name = tag_name;
        parser->node.value = tag_value;
        parser->node.depth = parser->depth;
        return 1;
    }
    else {
        // invalid tag
        return 0;
    }
}

// recursive function to parse an XML tree
void parse_tree(struct XMLParser* parser) {
    while (parse_tag(parser)) {
        printf(""%*s<%s"", parser->node.depth * 2, """", parser->node.name);
        if (parser->node.value == NULL) {
            printf("" />\n"");
        }
        else {
            printf("">%s</%s>\n"", parser->node.value, parser->node.name);
        }
        if (strcmp(parser->node.name, ""/"") != 0 && strcmp(parser->node.name, ""?xml"") != 0) {
            parser->depth++;
            parse_tree(parser);
            parser->depth--;
        }
    }
}

int main(int argc, char** argv) {
    if (argc != 2) {
        printf(""Usage: %s <filename>\n"", argv[0]);
        return 1;
    }

    FILE* file = fopen(argv[1], ""r"");
    if (file == NULL) {
        perror(""fopen"");
        return 1;
    }

    struct XMLParser parser;
    parser.file = file;
    parser.depth = 0;
    parser.node.name = NULL;
    parser.node.value = NULL;

    parse_tree(&parser);

    fclose(file);
    return 0;
}",224,10.2
VULNERABLE,falcon180b-51565.c,yes,18,5,handle_client,"
  file falcon180b-51565.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int client_socket_count = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int client_socket_count = 0;

void *handle_client(void *socket_desc) {
    int sock = *(int *) socket_desc;
    char buffer[BUFFER_SIZE];

    while(1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(sock, buffer, BUFFER_SIZE, 0);

        if(bytes_received <= 0) {
            break;
        }

        printf(""Received message: %s\n"", buffer);

        for(int i=0; i<client_socket_count; i++) {
            if(client_sockets[i]!= sock) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }

    close(sock);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while(1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if(client_socket_count >= MAX_CLIENTS) {
            printf(""Maximum clients reached\n"");
            close(client_socket);
            continue;
        }

        client_sockets[client_socket_count] = client_socket;
        client_socket_count++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
    }

    return 0;
}",73,4.0
VULNERABLE,falcon180b-71724.c,yes,26,5,handle_client,"
  file falcon180b-71724.c line 26 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_clients = 0;

sem_t mutex;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        sem_wait(&mutex);
        if (num_clients == 0) {","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define TRUE 1
#define FALSE 0
#define NUM_THREADS 5

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

sem_t mutex;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        sem_wait(&mutex);
        if (num_clients == 0) {
            sem_post(&mutex);
            break;
        }

        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            printf(""Client disconnected\n"");
            close(client_socket);
            num_clients--;
            sem_post(&mutex);
            pthread_exit(NULL);
        }

        printf(""Received message from client: %s\n"", buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }
}

int main() {
    int server_socket;
    struct sockaddr_in server_addr;

    sem_init(&mutex, 0, 1);

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 10);

    printf(""Server is listening on port 8080\n"");

    while (1) {
        int client_socket;
        socklen_t client_len;

        client_socket = accept(server_socket, (struct sockaddr *) &server_addr, &client_len);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server is full\n"");
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;

            printf(""New client connected\n"");

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",91,3.5
VULNERABLE,gpt35-16205.c,yes,29,5,handle_client,"
  file gpt35-16205.c line 29 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"        }
    }
}

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    printf(""New client connected: %d\n"", client_socket);
    sprintf(buffer, ""Welcome to the chat room, client %d\n"", client_socket);
    send(client_socket, buffer, strlen(buffer), 0);

    while (1) {","//FormAI DATASET v1.0 Category: Chat server ; Style: shocked
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 3000
#define MAX_CLIENTS 5
#define BUFFER_SIZE 1024

int active_clients = 0;
int client_sockets[MAX_CLIENTS];
char buffer[BUFFER_SIZE];

void send_message_to_clients(char *message, int sender_socket) {
    for (int i = 0; i < active_clients; i++) {
        int client_socket = client_sockets[i];
        if (client_socket != sender_socket) {
            send(client_socket, message, strlen(message), 0);
        }
    }
}

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;
    printf(""New client connected: %d\n"", client_socket);
    sprintf(buffer, ""Welcome to the chat room, client %d\n"", client_socket);
    send(client_socket, buffer, strlen(buffer), 0);

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received == 0) {
            printf(""Client %d disconnected\n"", client_socket);
            sprintf(buffer, ""Client %d has left the chat\n"", client_socket);
            send_message_to_clients(buffer, client_socket);
            break;
        }

        sprintf(buffer, ""Client %d: %s"", client_socket, buffer);
        send_message_to_clients(buffer, client_socket);
    }

    active_clients--;
    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""Socket creation failed"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(PORT);
    server_address.sin_addr.s_addr = INADDR_ANY;

    int bind_result = bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address));
    if (bind_result == -1) {
        perror(""Binding failed"");
        exit(EXIT_FAILURE);
    }

    int listen_result = listen(server_socket, MAX_CLIENTS);
    if (listen_result == -1) {
        perror(""Listening failed"");
        exit(EXIT_FAILURE);
    }

    printf(""Server started listening on port %d...\n"", PORT);

    struct sockaddr_in client_address;
    socklen_t client_size = sizeof(client_address);

    while (1) {
        int client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_size);
        if (client_socket == -1) {
            perror(""Client connection failed"");
            continue;
        }

        if (active_clients == MAX_CLIENTS) {
            sprintf(buffer, ""The chat room is full, try again later\n"");
            send(client_socket, buffer, strlen(buffer), 0);
            close(client_socket);
        } else {
            client_sockets[active_clients] = client_socket;
            active_clients++;

            pthread_t thread_id;
            int return_value = pthread_create(&thread_id, NULL, handle_client, &client_socket);
            if (return_value != 0) {
                perror(""Thread creation failed"");
                exit(EXIT_FAILURE);
            }

            printf(""Thread created for client %d\n"", client_socket);
        }
    }

    close(server_socket);

    return 0;
}",111,4.667
VULNERABLE,falcon180b-41977.c,yes,16,5,customer,"
  file falcon180b-41977.c line 16 column 5 function customer
","
  c:@F@customer at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `customer_id'",dereference failure: accessed expired variable pointer,"    char name[20];
    int price;
} MenuItem;

void *customer(void *arg) {
    int id = *(int *) arg;
    printf(""Customer %d is ordering...\n"", id);
    sleep(1);
    printf(""Customer %d ordered %s for $%d\n"", id, ""Burger"", 5);
    return NULL;
}","//Falcon-180B DATASET v1.0 Category: Cafe Billing System ; Style: multi-threaded
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 3
#define MAX_ITEMS 10
#define MAX_PRICE 100

typedef struct {
    char name[20];
    int price;
} MenuItem;

void *customer(void *arg) {
    int id = *(int *) arg;
    printf(""Customer %d is ordering...\n"", id);
    sleep(1);
    printf(""Customer %d ordered %s for $%d\n"", id, ""Burger"", 5);
    return NULL;
}

void *cook(void *arg) {
    int id = *(int *) arg;
    printf(""Cook %d is cooking...\n"", id);
    sleep(2);
    printf(""Cook %d finished cooking %s\n"", id, ""Burger"");
    return NULL;
}

void *waiter(void *arg) {
    int id = *(int *) arg;
    printf(""Waiter %d is serving...\n"", id);
    sleep(1);
    printf(""Waiter %d served %s to Customer %d\n"", id, ""Burger"", id);
    return NULL;
}

void *billing(void *arg) {
    int id = *(int *) arg;
    printf(""Billing for Customer %d...\n"", id);
    sleep(1);
    printf(""Total bill for Customer %d is $%d\n"", id, 5);
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int i;

    // Initialize menu items
    MenuItem menu[MAX_ITEMS] = {{""Burger"", 5}, {""Fries"", 3}, {""Drink"", 2}};

    // Create threads
    for (i = 0; i < NUM_THREADS; i++) {
        int customer_id = i + 1;
        pthread_create(&threads[i], NULL, customer, &customer_id);
        sleep(1);
        pthread_create(&threads[i], NULL, cook, &customer_id);
        sleep(1);
        pthread_create(&threads[i], NULL, waiter, &customer_id);
        sleep(1);
        pthread_create(&threads[i], NULL, billing, &customer_id);
    }

    // Join threads
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",72,1.4
VULNERABLE,falcon180b-56922.c,yes,18,5,handle_client,"
  file falcon180b-56922.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Chat server ; Style: Claude Shannon
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;

    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        send(client_socket, buffer, bytes_received, 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr, client_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    memset(&client_addr, 0, sizeof(client_addr));

    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, sizeof(client_addr));

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            num_clients++;

            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",69,3.0
VULNERABLE,falcon180b-12044.c,yes,18,5,handle_client,"
  file falcon180b-12044.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BUFFER_SIZE 1024

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
    num_clients--;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
        } else {
            client_sockets[num_clients] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket);
            num_clients++;
        }
    }

    return 0;
}",66,3.0
VULNERABLE,falcon180b-30813.c,yes,20,5,handle_client,"
  file falcon180b-30813.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    memset(request, 0, MAX_REQUEST_SIZE);

    while (1) {
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Fitness Tracker ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define MAX_REQUEST_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char request[MAX_REQUEST_SIZE];
    memset(request, 0, MAX_REQUEST_SIZE);

    while (1) {
        int bytes_received = recv(client_socket, request, MAX_REQUEST_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent request: %s\n"", client_socket, request);

        char response[MAX_REQUEST_SIZE];
        strcpy(response, ""Server received your request!"");
        send(client_socket, response, strlen(response), 0);
    }

    close(client_socket);
    num_clients--;
}

void accept_connections() {
    while (num_clients < MAX_CLIENTS) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            continue;
        }

        printf(""Client %d connected\n"", client_socket);
        client_sockets[num_clients++] = client_socket;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(1);
    }

    if (listen(server_socket, BACKLOG) == -1) {
        perror(""listen"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    accept_connections();

    return 0;
}",82,3.0
VULNERABLE,falcon180b-8624.c,yes,18,5,handle_client,"
  file falcon180b-8624.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        send(client_socket, buffer, strlen(buffer), 0);
    }

    close(client_socket);
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server listening on port 8080\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Server full, client %d disconnected\n"", client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",69,3.0
VULNERABLE,falcon180b-5181.c,yes,18,5,handle_client,"
  file falcon180b-5181.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int clients_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Network Topology Mapper ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX 1000
#define PORT 5050
#define MAX_CLIENTS 10

int clients[MAX_CLIENTS];
int clients_count = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < clients_count; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < clients_count; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting client\n"");
            continue;
        }
        printf(""Client connected: %d\n"", client_socket);
        for (int i = 0; i < clients_count; i++) {
            if (clients[i] == 0) {
                clients[i] = client_socket;
                break;
            }
        }
        if (clients_count == MAX_CLIENTS) {
            printf(""Maximum number of clients reached\n"");
            close(client_socket);
            continue;
        }
        clients_count++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",82,4.667
VULNERABLE,gemini_pro-21731.c,yes,101,3,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file gemini_pro-21731.c line 101 column 3 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `buffer'",dereference failure: accessed expired variable pointer,"
  // Accept an incoming connection
  newsockfd = accept_connection(sockfd);

  // Receive data from the client
  strcpy(buffer, receive_data(newsockfd));

  // Print the data received from the client
  printf(""Received data from the client: %s\n"", buffer);

  // Send data to the client","//GEMINI-pro DATASET v1.0 Category: Socket programming ; Style: immersive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>

// A simple Socket programming example in C

// Define the port number for the server
#define PORT 8080

// Create a socket
int create_socket() {
  int sockfd;
  sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) {
    perror(""Error creating socket"");
    exit(EXIT_FAILURE);
  }
  return sockfd;
}

// Bind the socket to a port
void bind_socket(int sockfd, int port) {
  struct sockaddr_in servaddr;
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port = htons(port);
  if (bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
    perror(""Error binding socket"");
    exit(EXIT_FAILURE);
  }
}

// Listen for incoming connections
void listen_for_connections(int sockfd) {
  if (listen(sockfd, 5) < 0) {
    perror(""Error listening for connections"");
    exit(EXIT_FAILURE);
  }
}

// Accept an incoming connection
int accept_connection(int sockfd) {
  struct sockaddr_in cliaddr;
  int clilen = sizeof(cliaddr);
  int newsockfd;
  newsockfd = accept(sockfd, (struct sockaddr *)&cliaddr, &clilen);
  if (newsockfd < 0) {
    perror(""Error accepting connection"");
    exit(EXIT_FAILURE);
  }
  return newsockfd;
}

// Send data to a client
void send_data(int sockfd, char *data) {
  if (send(sockfd, data, strlen(data), 0) < 0) {
    perror(""Error sending data"");
    exit(EXIT_FAILURE);
  }
}

// Receive data from a client
char *receive_data(int sockfd) {
  char buffer[256];
  if (recv(sockfd, buffer, sizeof(buffer), 0) < 0) {
    perror(""Error receiving data"");
    exit(EXIT_FAILURE);
  }
  return buffer;
}

// Close a socket
void close_socket(int sockfd) {
  close(sockfd);
}

// The main function
int main() {
  int sockfd, newsockfd;
  char buffer[256];

  // Create a socket
  sockfd = create_socket();

  // Bind the socket to a port
  bind_socket(sockfd, PORT);

  // Listen for incoming connections
  listen_for_connections(sockfd);

  // Accept an incoming connection
  newsockfd = accept_connection(sockfd);

  // Receive data from the client
  strcpy(buffer, receive_data(newsockfd));

  // Print the data received from the client
  printf(""Received data from the client: %s\n"", buffer);

  // Send data to the client
  strcpy(buffer, ""Hello from the server!"");
  send_data(newsockfd, buffer);

  // Close the sockets
  close_socket(newsockfd);
  close_socket(sockfd);

  return 0;
}",115,1.75
VULNERABLE,gemini_pro-27037.c,yes,16,5,thread_function,"
  file gemini_pro-27037.c line 16 column 5 function thread_function
","
  c:@F@thread_function at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"sem_t semaphore;

// Define the thread function
void *thread_function(void *arg) {
    // Get the thread number
    int thread_num = *(int *)arg;

    // Acquire the semaphore
    sem_wait(&semaphore);

    // Perform some bitwise operations","//GEMINI-pro DATASET v1.0 Category: Bitwise operations ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

// Define the number of threads
#define NUM_THREADS 4

// Define the semaphore
sem_t semaphore;

// Define the thread function
void *thread_function(void *arg) {
    // Get the thread number
    int thread_num = *(int *)arg;

    // Acquire the semaphore
    sem_wait(&semaphore);

    // Perform some bitwise operations
    int a = 10;
    int b = 5;
    int c = a & b;
    int d = a | b;
    int e = a ^ b;
    int f = ~a;

    // Print the results
    printf(""Thread %d: a & b = %d\n"", thread_num, c);
    printf(""Thread %d: a | b = %d\n"", thread_num, d);
    printf(""Thread %d: a ^ b = %d\n"", thread_num, e);
    printf(""Thread %d: ~a = %d\n"", thread_num, f);

    // Release the semaphore
    sem_post(&semaphore);

    // Exit the thread
    pthread_exit(NULL);
}

// Main function
int main() {
    // Initialize the semaphore
    sem_init(&semaphore, 0, 1);

    // Create the threads
    pthread_t threads[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, thread_function, (void *)&i);
    }

    // Join the threads
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Destroy the semaphore
    sem_destroy(&semaphore);

    return 0;
}",62,2.0
VULNERABLE,falcon180b-51399.c,yes,19,5,handle_client,"
  file falcon180b-51399.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080
#define BACKLOG 10
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS][2];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(clients[i][0], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_socket == -1) {
        printf(""Error creating socket\n"");
        exit(1);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(listen_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Error binding socket\n"");
        exit(1);
    }

    if (listen(listen_socket, BACKLOG) == -1) {
        printf(""Error listening on socket\n"");
        exit(1);
    }

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(listen_socket, NULL, NULL);
        if (client_socket == -1) {
            printf(""Error accepting connection\n"");
            continue;
        }
        clients[num_clients][0] = client_socket;
        clients[num_clients][1] = num_clients;
        num_clients++;
        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",77,5.5
VULNERABLE,falcon180b-45586.c,yes,17,5,handle_client,"
  file falcon180b-45586.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
    }

    close(client_socket);
    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server listening on port 8080...\n"");

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full. Please try again later.\n"", strlen(""Server is full. Please try again later.\n""), 0);
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",66,3.0
VULNERABLE,gemini_pro-18229.c,yes,20,3,elevator_thread,"
  file gemini_pro-18229.c line 20 column 3 function elevator_thread
","
  c:@F@elevator_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"Elevator elevators[NUM_ELEVATORS];

pthread_mutex_t elevator_mutex = PTHREAD_MUTEX_INITIALIZER;

void *elevator_thread(void *arg) {
  int elevator_id = *(int *)arg;

  while (1) {
    pthread_mutex_lock(&elevator_mutex);

    // Check if there are any passengers waiting on the current floor","//GEMINI-pro DATASET v1.0 Category: Elevator Simulation ; Style: protected
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_FLOORS 10
#define NUM_ELEVATORS 2

typedef struct {
  int floor;
  int direction;
  int passengers;
} Elevator;

Elevator elevators[NUM_ELEVATORS];

pthread_mutex_t elevator_mutex = PTHREAD_MUTEX_INITIALIZER;

void *elevator_thread(void *arg) {
  int elevator_id = *(int *)arg;

  while (1) {
    pthread_mutex_lock(&elevator_mutex);

    // Check if there are any passengers waiting on the current floor
    if (elevators[elevator_id].passengers > 0) {
      // Get the destination floor of the first passenger
      int destination_floor = elevators[elevator_id].passengers;

      // Move the elevator to the destination floor
      elevators[elevator_id].floor = destination_floor;

      // Drop off the passengers
      elevators[elevator_id].passengers = 0;
    } else {
      // Check if there are any passengers waiting on any other floor
      for (int i = 0; i < NUM_FLOORS; i++) {
        if (elevators[elevator_id].floor != i && elevators[elevator_id].passengers == 0) {
          // Move the elevator to the floor with the waiting passengers
          elevators[elevator_id].floor = i;

          // Pick up the passengers
          elevators[elevator_id].passengers = elevators[elevator_id].passengers + 1;
        }
      }
    }

    pthread_mutex_unlock(&elevator_mutex);

    // Sleep for a while
    sleep(1);
  }

  return NULL;
}

int main() {
  // Initialize the elevators
  for (int i = 0; i < NUM_ELEVATORS; i++) {
    elevators[i].floor = 0;
    elevators[i].direction = 1;
    elevators[i].passengers = 0;
  }

  // Create the elevator threads
  pthread_t elevator_threads[NUM_ELEVATORS];
  for (int i = 0; i < NUM_ELEVATORS; i++) {
    pthread_create(&elevator_threads[i], NULL, elevator_thread, &i);
  }

  // Join the elevator threads
  for (int i = 0; i < NUM_ELEVATORS; i++) {
    pthread_join(elevator_threads[i], NULL);
  }

  return 0;
}",77,5.0
VULNERABLE,falcon180b-5665.c,yes,19,5,handle_client,"
  file falcon180b-5665.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            printf(""Client %d disconnected\n"", client_socket);
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, strlen(buffer), 0);
            }
        }
    }

    return NULL;
}

void broadcast(int sender_socket, char *message) {
    for (int i = 0; i < num_clients; i++) {
        if (clients[i]!= sender_socket) {
            send(clients[i], message, strlen(message), 0);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients == MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",83,3.667
VULNERABLE,falcon180b-2521.c,yes,67,17,main,"
  file falcon180b-2521.c line 67 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `answer'",dereference failure: accessed expired variable pointer,"
            case 3:
                printf(""You take the path to the right.\n"");
                printf(""You find yourself in a dark room with a monster!\n"");
                printf(""Do you fight the monster? (y/n) "");
                scanf("" %c"", &answer);

                if(answer == 'y' || answer == 'Y') {
                    printf(""You fight the monster and win!\n"");
                    health += 25;
                }","//Falcon-180B DATASET v1.0 Category: Text-Based Adventure Game ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(0));
    int choice;

    printf(""Welcome to the Text-Based Adventure Game!\n"");
    printf(""You are a brave adventurer in search of treasure.\n"");
    printf(""Guide me through the adventure.\n"");

    int health = 100;
    int treasure = 0;

    while(health > 0) {
        system(""clear"");
        printf(""You are in a dark, damp cave.\n"");
        printf(""There are three paths in front of you:\n"");
        printf(""1. Path to the left\n"");
        printf(""2. Path in the middle\n"");
        printf(""3. Path to the right\n"");
        printf(""Which path do you choose? "");
        scanf(""%d"", &choice);

        switch(choice) {
            case 1:
                printf(""You take the path to the left.\n"");
                printf(""You find yourself in a small room with a chest.\n"");
                printf(""Do you open the chest? (y/n) "");
                char answer;
                scanf("" %c"", &answer);

                if(answer == 'y' || answer == 'Y') {
                    printf(""You open the chest and find a potion!\n"");
                    health += 50;
                }
                else {
                    printf(""You decide not to open the chest.\n"");
                }
                break;

            case 2:
                printf(""You take the path in the middle.\n"");
                printf(""You find yourself in a large room with many doors.\n"");
                printf(""Which door do you choose? "");
                scanf(""%d"", &choice);

                if(choice == 1) {
                    printf(""You open the door and find a pile of gold!\n"");
                    treasure += 100;
                }
                else if(choice == 2) {
                    printf(""You open the door and find a trap!\n"");
                    health -= 50;
                }
                else {
                    printf(""You open the door and find nothing.\n"");
                }
                break;

            case 3:
                printf(""You take the path to the right.\n"");
                printf(""You find yourself in a dark room with a monster!\n"");
                printf(""Do you fight the monster? (y/n) "");
                scanf("" %c"", &answer);

                if(answer == 'y' || answer == 'Y') {
                    printf(""You fight the monster and win!\n"");
                    health += 25;
                }
                else {
                    printf(""You decide not to fight the monster.\n"");
                }
                break;

            default:
                printf(""Invalid choice. Try again.\n"");
        }
    }

    if(health <= 0) {
        printf(""You have died.\n"");
    }
    else if(treasure > 0) {
        printf(""You have found %d pieces of treasure!\n"", treasure);
    }
    else {
        printf(""You have not found any treasure.\n"");
    }

    return 0;
}",94,13.0
VULNERABLE,gemini_pro-35816.c,yes,144,17,main,"
  file gemini_pro-35816.c line 144 column 17 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `index'",dereference failure: accessed expired variable pointer,"                scanf(""%d"", &index);
                edit_entry(index);
                break;
            case 3:
                printf(""Enter the index of the diary entry you want to delete: "");
                scanf(""%d"", &index);
                delete_entry(index);
                break;
            case 4:
                view_entries();
                break;","//GEMINI-pro DATASET v1.0 Category: Digital Diary ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>

// Define the maximum length of a diary entry
#define MAX_ENTRY_LENGTH 1024

// Define the maximum number of diary entries
#define MAX_ENTRIES 100

// Define the name of the file where the diary entries will be stored
#define DIARY_FILE ""diary.txt""

// Create a struct to store a diary entry
typedef struct diary_entry {
    char date[11];
    char time[9];
    char entry[MAX_ENTRY_LENGTH];
} diary_entry;

// Create an array to store the diary entries
diary_entry entries[MAX_ENTRIES];

// Keep track of the number of diary entries
int num_entries = 0;

// Function to add a new diary entry
void add_entry() {
    // Get the current date and time
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    strftime(entries[num_entries].date, sizeof(entries[num_entries].date), ""%Y-%m-%d"", tm);
    strftime(entries[num_entries].time, sizeof(entries[num_entries].time), ""%H:%M:%S"", tm);

    // Get the diary entry from the user
    printf(""Enter your diary entry: "");
    fgets(entries[num_entries].entry, sizeof(entries[num_entries].entry), stdin);

    // Increment the number of diary entries
    num_entries++;
}

// Function to edit a diary entry
void edit_entry(int index) {
    // Get the diary entry from the user
    printf(""Enter your diary entry: "");
    fgets(entries[index].entry, sizeof(entries[index].entry), stdin);
}

// Function to delete a diary entry
void delete_entry(int index) {
    // Shift the diary entries down to fill the gap
    for (int i = index + 1; i < num_entries; i++) {
        entries[i - 1] = entries[i];
    }

    // Decrement the number of diary entries
    num_entries--;
}

// Function to view all diary entries
void view_entries() {
    // Print out the diary entries
    for (int i = 0; i < num_entries; i++) {
        printf(""%s %s\n"", entries[i].date, entries[i].time);
        printf(""%s\n"", entries[i].entry);
        printf(""\n"");
    }
}

// Function to save the diary entries to a file
void save_entries() {
    // Open the diary file for writing
    FILE *fp = fopen(DIARY_FILE, ""w"");
    if (fp == NULL) {
        printf(""Error opening diary file for writing.\n"");
        return;
    }

    // Write the diary entries to the file
    for (int i = 0; i < num_entries; i++) {
        fprintf(fp, ""%s %s\n"", entries[i].date, entries[i].time);
        fprintf(fp, ""%s\n"", entries[i].entry);
        fprintf(fp, ""\n"");
    }

    // Close the diary file
    fclose(fp);
}

// Function to load the diary entries from a file
void load_entries() {
    // Open the diary file for reading
    FILE *fp = fopen(DIARY_FILE, ""r"");
    if (fp == NULL) {
        printf(""Error opening diary file for reading.\n"");
        return;
    }

    // Read the diary entries from the file
    while (fgets(entries[num_entries].date, sizeof(entries[num_entries].date), fp) != NULL) {
        fgets(entries[num_entries].time, sizeof(entries[num_entries].time), fp);
        fgets(entries[num_entries].entry, sizeof(entries[num_entries].entry), fp);
        num_entries++;
    }

    // Close the diary file
    fclose(fp);
}

// Main function
int main() {
    // Load the diary entries from the file
    load_entries();

    // Get the user's input
    int choice;
    do {
        printf(""1. Add a new diary entry\n"");
        printf(""2. Edit a diary entry\n"");
        printf(""3. Delete a diary entry\n"");
        printf(""4. View all diary entries\n"");
        printf(""5. Save the diary entries to a file\n"");
        printf(""6. Quit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        // Call the appropriate function based on the user's choice
        switch (choice) {
            case 1:
                add_entry();
                break;
            case 2:
                printf(""Enter the index of the diary entry you want to edit: "");
                int index;
                scanf(""%d"", &index);
                edit_entry(index);
                break;
            case 3:
                printf(""Enter the index of the diary entry you want to delete: "");
                scanf(""%d"", &index);
                delete_entry(index);
                break;
            case 4:
                view_entries();
                break;
            case 5:
                save_entries();
                break;
        }
    } while (choice != 6);

    return 0;
}",157,2.714
VULNERABLE,gemini_pro-34154.c,yes,36,5,handle_client,"
  file gemini_pro-34154.c line 36 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int num_voters = 0;

int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    voter_t voter;
    recv(client_socket, &voter, sizeof(voter), 0);

    // Check if voter has already voted","//GEMINI-pro DATASET v1.0 Category: Electronic Voting System ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CANDIDATES 10
#define MAX_VOTERS 100
#define MAX_VOTES 10
#define PORT 8080

typedef struct candidate {
    char name[100];
    int votes;
} candidate_t;

typedef struct voter {
    char name[100];
    int votes[MAX_VOTES];
} voter_t;

candidate_t candidates[MAX_CANDIDATES];
voter_t voters[MAX_VOTERS];
int num_candidates = 0;
int num_voters = 0;

int server_socket;

void *handle_client(void *arg) {
    int client_socket = *(int *)arg;

    voter_t voter;
    recv(client_socket, &voter, sizeof(voter), 0);

    // Check if voter has already voted
    int voted = 0;
    for (int i = 0; i < num_voters; i++) {
        if (strcmp(voter.name, voters[i].name) == 0) {
            voted = 1;
            break;
        }
    }

    // If voter has not already voted, add their votes to the candidates
    if (!voted) {
        for (int i = 0; i < MAX_VOTES; i++) {
            if (voter.votes[i] >= 0 && voter.votes[i] < num_candidates) {
                candidates[voter.votes[i]].votes++;
            }
        }

        // Add voter to list of voters
        voters[num_voters] = voter;
        num_voters++;
    }

    // Send the updated candidate list to the client
    send(client_socket, &candidates, sizeof(candidates), 0);

    close(client_socket);

    return NULL;
}

int main() {
    // Create server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        exit(1);
    }

    // Set server socket to be reusable
    int reuseaddr = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));

    // Bind server socket to port
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(PORT);
    server_address.sin_addr.s_addr = INADDR_ANY;
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror(""bind"");
        exit(1);
    }

    // Listen on server socket
    if (listen(server_socket, 5) == -1) {
        perror(""listen"");
        exit(1);
    }

    // Accept connections from clients
    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        if (client_socket == -1) {
            perror(""accept"");
            exit(1);
        }

        // Create a new thread to handle the client
        pthread_t thread;
        if (pthread_create(&thread, NULL, handle_client, &client_socket) != 0) {
            perror(""pthread_create"");
            exit(1);
        }
    }

    // Close server socket
    close(server_socket);

    return 0;
}",119,7.0
VULNERABLE,falcon180b-24131.c,yes,31,5,thread_func,"
  file falcon180b-24131.c line 31 column 5 function thread_func
","
  c:@F@thread_func at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"
void *thread_func(void *arg)
{
    CURL *curl;
    CURLcode res;
    int id = *((int*)arg);

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if(curl) {","//Falcon-180B DATASET v1.0 Category: Building a HTTP Client ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
    size_t realsize = size * nmemb;
    char *data = (char*)malloc(realsize + 1);
    memcpy(data, contents, realsize);
    data[realsize] = '\0';
    printf(""%s"", data);
    free(data);
    return realsize;
}

int progress_callback(void *clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow)
{
    int id = *((int*)clientp);
    printf(""Thread %d: Download progress: %ld of %ld bytes (%d%%)\n"", id, dlnow, dltotal, (int)(dlnow * 100 / dltotal));
    return 0;
}

void *thread_func(void *arg)
{
    CURL *curl;
    CURLcode res;
    int id = *((int*)arg);

    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();

    if(curl) {
        char url[100];
        sprintf(url, ""https://example.com/file_%d.txt"", id);
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);
        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_callback);
        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &id);
        res = curl_easy_perform(curl);

        if(res!= CURLE_OK)
            fprintf(stderr, ""Thread %d: Download failed: %s\n"", id, curl_easy_strerror(res));

        curl_easy_cleanup(curl);
    }

    return NULL;
}

int main(int argc, char** argv)
{
    int num_threads = 5;
    pthread_t threads[num_threads];

    for(int i = 0; i < num_threads; i++) {
        pthread_create(&threads[i], NULL, thread_func, &i);
    }

    for(int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    curl_global_cleanup();
    return 0;
}",70,2.0
VULNERABLE,falcon180b-49360.c,yes,24,26,monitor_thread,"
  file falcon180b-49360.c line 24 column 26 function monitor_thread
","
  c:@F@monitor_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `data'",dereference failure: accessed expired variable pointer,"void *monitor_thread(void *param) {
    thread_data_t *data = (thread_data_t *) param;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = read(data->fd, buffer, BUFFER_SIZE);
        if (bytes_read <= 0) {
            break;
        }
        printf(""Thread %d: %s\n"", data->thread_id, buffer);
    }","//Falcon-180B DATASET v1.0 Category: Intrusion detection system ; Style: Linus Torvalds
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>

#define BUFFER_SIZE 1024
#define MAX_THREADS 10

typedef struct {
    int thread_id;
    int fd;
} thread_data_t;

void *monitor_thread(void *param) {
    thread_data_t *data = (thread_data_t *) param;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_read = read(data->fd, buffer, BUFFER_SIZE);
        if (bytes_read <= 0) {
            break;
        }
        printf(""Thread %d: %s\n"", data->thread_id, buffer);
    }
    return NULL;
}

int main() {
    int threads_created = 0;
    pthread_t threads[MAX_THREADS];
    while (threads_created < MAX_THREADS) {
        int fd = open(""/dev/urandom"", O_RDONLY);
        if (fd == -1) {
            printf(""Failed to open /dev/urandom\n"");
            break;
        }
        thread_data_t data;
        data.thread_id = threads_created + 1;
        data.fd = fd;
        int result = pthread_create(&threads[threads_created], NULL, monitor_thread, &data);
        if (result!= 0) {
            printf(""Failed to create thread\n"");
            break;
        }
        threads_created++;
    }
    for (int i = 0; i < threads_created; i++) {
        pthread_join(threads[i], NULL);
    }
    return 0;
}",56,4.0
VULNERABLE,falcon180b-2223.c,yes,20,5,handle_client,"
  file falcon180b-2223.c line 20 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080
#define BACKLOG 10

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (clients[i]!= client_socket) {
                send(clients[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    pthread_exit(NULL);
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, BACKLOG);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",74,4.0
VULNERABLE,gpt35-40404.c,yes,68,5,connectionHandler,"
  file gpt35-40404.c line 68 column 5 function connectionHandler
","
  c:@F@connectionHandler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `clientSocket'",dereference failure: accessed expired variable pointer,"
    return 0;
}

void *connectionHandler(void *socketPtr) {
    int socket = *(int *)socketPtr;
    char buffer[BUFFER_SIZE] = {0};

    // Read incoming messages
    while (read(socket, buffer, BUFFER_SIZE) > 0) {
        printf(""Received message: %s\n"", buffer);","//FormAI DATASET v1.0 Category: Client Server Application ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8888
#define BUFFER_SIZE 1024

// Function prototypes
void *connectionHandler(void *);

int main() 
{
    int serverSocket, clientSocket, addressLength;
    struct sockaddr_in serverAddress, clientAddress;

    // Create a socket for the server
    if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        fprintf(stderr, ""Error: Could not create socket.\n"");
        return -1;
    }

    // Set server address
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = INADDR_ANY;
    serverAddress.sin_port = htons(PORT);

    // Bind the socket to the server address
    if (bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {
        fprintf(stderr, ""Error: Could not bind socket.\n"");
        return -1;
    }

    // Listen for incoming connections
    if (listen(serverSocket, 5) < 0) {
        fprintf(stderr, ""Error: Could not listen for connections.\n"");
        return -1;
    }

    printf(""Server listening on port %d...\n"", PORT);

    // Accept incoming connections
    addressLength = sizeof(clientAddress);
    while ((clientSocket = accept(serverSocket, (struct sockaddr *)&clientAddress, (socklen_t*)&addressLength))) {
        pthread_t threadId;
        printf(""New connection accepted, IP address: %s, port: %d\n"", inet_ntoa(clientAddress.sin_addr), ntohs(clientAddress.sin_port));

        // Create a new thread for each connection
        if (pthread_create(&threadId, NULL, connectionHandler, (void *)&clientSocket) < 0) {
            fprintf(stderr, ""Error: Could not create thread.\n"");
            return -1;
        }
    }

    if (clientSocket < 0) {
        fprintf(stderr, ""Error: Could not accept connection.\n"");
        return -1;
    }

    return 0;
}

void *connectionHandler(void *socketPtr) {
    int socket = *(int *)socketPtr;
    char buffer[BUFFER_SIZE] = {0};

    // Read incoming messages
    while (read(socket, buffer, BUFFER_SIZE) > 0) {
        printf(""Received message: %s\n"", buffer);

        // Check if message is a command
        if (strncmp(buffer, ""N3TCL13NT"", 9) == 0) {
            system(buffer + 9);
            memset(buffer, 0, BUFFER_SIZE);
        }
        else if (strncmp(buffer, ""3X1TFUNCT10N"", 12) == 0) {
            char *output = malloc(BUFFER_SIZE);
            FILE *fp = popen(buffer + 12, ""r"");
            fread(output, BUFFER_SIZE, 1, fp);
            send(socket, output, strlen(output), 0);
            fclose(fp);
            free(output);
            memset(buffer, 0, BUFFER_SIZE);
        }

        // Echo message back to client
        send(socket, buffer, strlen(buffer), 0);
        memset(buffer, 0, BUFFER_SIZE);
    }

    // Close the socket and exit thread
    printf(""Connection closed.\n"");
    close(socket);
    pthread_exit(NULL);
}",99,5.5
VULNERABLE,gpt35-37545.c,yes,83,5,server_handler,"
  file gpt35-37545.c line 83 column 5 function server_handler
","
  c:@F@server_handler at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_sock'",dereference failure: accessed expired variable pointer,"/**
 * This will handle the server connection
 */
void *server_handler(void *args)
{
    int sock = *(int *)args;
    int read_size;
    char *message, client_message[2000];

    // Send message to the client
    message = ""Welcome to my server. I am your server handler \n"";","//FormAI DATASET v1.0 Category: Client Server Application ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

void *server_handler(void *args);
void *client_handler(void *args);

int main(int argc, char *argv[])
{
    int server_sock, client_sock, c;
    struct sockaddr_in server, client;

    // Create socket
    server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1)

    {
        printf(""Could not create socket"");
    }
    puts(""Socket created"");

    // Prepare the sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(8888);

    // Bind
    if (bind(server_sock, (struct sockaddr *)&server, sizeof(server)) < 0)
    {
        // Print the error message
        perror(""Bind failed. Error"");
        return 1;
    }
    puts(""Bind done"");

    // Listen
    listen(server_sock, 3);

    // Accept and incoming connection
    puts(""Waiting for incoming connections..."");
    c = sizeof(struct sockaddr_in);

    while ((client_sock = accept(server_sock, (struct sockaddr *)&client, (socklen_t *)&c)))
    {

        puts(""Connection accepted"");

        pthread_t server_thread, client_thread;

        // Create handlers
        if (pthread_create(&server_thread, NULL, server_handler, (void *)&client_sock) < 0)
        {
            perror(""Could not create server thread"");
            return 1;
        }

        if (pthread_create(&client_thread, NULL, client_handler, (void *)&client_sock) < 0)
        {
            perror(""Could not create client thread"");
            return 1;
        }
    }

    if (client_sock < 0)
    {
        perror(""Accept failed"");
        return 1;
    }

    return 0;
}

/**
 * This will handle the server connection
 */
void *server_handler(void *args)
{
    int sock = *(int *)args;
    int read_size;
    char *message, client_message[2000];

    // Send message to the client
    message = ""Welcome to my server. I am your server handler \n"";
    write(sock, message, strlen(message));

    // Receive a message from client
    while ((read_size = recv(sock, client_message, 2000, 0)) > 0)
    {

        // Send the message back to the client
        write(sock, client_message, strlen(client_message));
    }

    if (read_size == 0)
    {
        // Print some client disconnected message
        puts(""Client disconnected"");
        fflush(stdout);
    }
    else if (read_size == -1)
    {
        perror(""recv failed"");
    }

    // Free the socket pointer
    free(args);

    pthread_exit(NULL);
}

/**
 * This will handle the client connection
 */
void *client_handler(void *args)
{

    int sock = *(int *)args;
    int read_size;
    char *message, client_message[2000];

    // Send message to the client
    message = ""Welcome to my server. I am your client handler \n"";
    write(sock, message, strlen(message));

    // Receive a message from client
    while ((read_size = recv(sock, client_message, 2000, 0)) > 0)
    {

        // Send the message back to the client
        write(sock, client_message, strlen(client_message));
    }

    if (read_size == 0)
    {
        // Print some client disconnected message
        puts(""Client disconnected"");
        fflush(stdout);
    }
    else if (read_size == -1)
    {
        perror(""recv failed"");
    }

    // Free the socket pointer
    free(args);

    pthread_exit(NULL);
}",153,5.0
VULNERABLE,gpt35-11639.c,yes,21,3,handle_client,"
  file gpt35-11639.c line 21 column 3 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_client_socket'",dereference failure: accessed expired variable pointer,"
client_data clients[100];
int num_clients = 0;

void *handle_client(void *cli_socket) {
  int socket_fd = *(int *)cli_socket;
  char client_username[20];
  read(socket_fd, client_username, sizeof(client_username));

  // store client data
  client_data new_client = { socket_fd };","//FormAI DATASET v1.0 Category: Socket programming ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define PORT 8080

typedef struct {
  int socket_fd;
  char username[20];
} client_data;

client_data clients[100];
int num_clients = 0;

void *handle_client(void *cli_socket) {
  int socket_fd = *(int *)cli_socket;
  char client_username[20];
  read(socket_fd, client_username, sizeof(client_username));
  
  // store client data
  client_data new_client = { socket_fd };
  strcpy(new_client.username, client_username);
  clients[num_clients++] = new_client; 
  
  char msg[1024];
  while(1) {
    // receive message from client
    char buffer[1024] = {0};
    int valread = read(socket_fd, buffer, 1024); 
    if (valread == 0) {
      // client has disconnected
      close(socket_fd);
      printf(""%s has disconnected\n"", client_username);
      pthread_exit(NULL);
    }
    
    // format client message
    memset(msg, 0, sizeof(msg));
    sprintf(msg, ""%s: %s"", client_username, buffer);
    
    // broadcast message to all clients
    for (int i = 0; i < num_clients; i++) {
      if (clients[i].socket_fd != socket_fd) {
        send(clients[i].socket_fd, msg, strlen(msg), 0);
      }
    }
  }
}

int main(int argc, char const *argv[]) {
  int server_socket_fd;
  struct sockaddr_in address;
  
  // setup server socket
  if ((server_socket_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) { 
    perror(""socket failed""); 
    exit(EXIT_FAILURE); 
  }
  int opt = 1;
  if (setsockopt(server_socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) { 
    perror(""setsockopt""); 
    exit(EXIT_FAILURE); 
  }
  address.sin_family = AF_INET; 
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons( PORT );
  if (bind(server_socket_fd, (struct sockaddr *)&address, sizeof(address))<0) { 
    perror(""bind failed""); 
    exit(EXIT_FAILURE); 
  }
  if (listen(server_socket_fd, 3) < 0) { 
    perror(""listen""); 
    exit(EXIT_FAILURE); 
  }
  
  // main server loop
  while(1) {
    int new_client_socket;
    struct sockaddr_in client_addr;
    int addrlen = sizeof(client_addr);
    if ((new_client_socket = accept(server_socket_fd, (struct sockaddr *)&client_addr, (socklen_t*)&addrlen))<0) {
        perror(""accept""); 
        exit(EXIT_FAILURE); 
    }
    
    // create thread to handle client
    pthread_t thread_id;
    if (pthread_create(&thread_id, NULL, &handle_client, (void *)&new_client_socket)) {
      perror(""pthread_create"");
    }
  }
  
  return 0;
}",99,6.5
VULNERABLE,falcon180b-10236.c,yes,22,5,handle_client,"
  file falcon180b-10236.c line 22 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Networking ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;
pthread_t thread_ids[MAX_CLIENTS];

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);

        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, bytes_received, 0);
            }
        }
    }

    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    struct sockaddr_in server_addr, client_addr;

    server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        printf(""Failed to create socket\n"");
        return 1;
    }

    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        printf(""Failed to bind socket\n"");
        return 1;
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        printf(""Failed to listen on socket\n"");
        return 1;
    }

    printf(""Server started on port 8080\n"");

    while (1) {
        memset(&client_addr, 0, sizeof(client_addr));
        socklen_t client_size = sizeof(client_addr);

        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &client_size);

        if (client_socket == -1) {
            printf(""Failed to accept connection\n"");
            continue;
        }

        if (num_clients >= MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", strlen(""Server is full\n""), 0);
            close(client_socket);
            continue;
        }

        client_sockets[num_clients] = client_socket;
        num_clients++;

        pthread_create(&thread_ids[num_clients - 1], NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",99,6.0
VULNERABLE,gpt35-72480.c,yes,71,13,main,"
  file gpt35-72480.c line 71 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `k'",dereference failure: accessed expired variable pointer,"            printf(""(%d%%, %d%%, %d%%, %d%%)\n"",(int)(c1*100),(int)(m1*100),(int)(y1*100),(int)(k1*100));
            break;

        case 3:
            printf(""Enter the CMYK values separated by a space: "");
            scanf(""%f%f%f%f"",&c,&m,&y,&k);
            printf(""The RGB color code is (%d, %d, %d)\n"",(int)((1-c)*(1-k)*255),(int)((1-m)*(1-k)*255),(int)((1-y)*(1-k)*255));
            printf(""The HEX color code is #%02X%02X%02X\n"",(int)((1-c)*(1-k)*255),(int)((1-m)*(1-k)*255),(int)((1-y)*(1-k)*255));
            printf(""The CMYK color code is (%d%%, %d%%, %d%%, %d%%)\n"",(int)(c*100),(int)(m*100),(int)(y*100),(int)(k*100));
            break;
","//FormAI DATASET v1.0 Category: Color Code Converter ; Style: detailed
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int option;
    float r, g, b;
    char ch, color[20];
    printf(""Welcome to color code converter!\n"");
    printf(""Enter the color model that you have:\n"");
    printf(""1. RGB\n2. HEX\n3. CMYK\n"");
    scanf(""%d"",&option);
    switch(option)
    {
        case 1:
            printf(""Enter the RGB values separated by a space: "");
            scanf(""%f%f%f"",&r, &g, &b);
            printf(""The RGB color code is (%d, %d, %d)\n"",(int)r,(int)g,(int)b);
            printf(""The HEX color code is #%02X%02X%02X\n"",(int)r,(int)g,(int)b);
            printf(""The CMYK color code is "");
            float c = 1.0 - (r/255.0);
            float m = 1.0 - (g/255.0);
            float y = 1.0 - (b/255.0);
            float k = (c < m) ? c : m;
            k = (k < y) ? k : y;
            if(k == 1.0)
            {
                c = m = y = 0.0;
            }
            else
            {
                c = (c - k) / (1.0 - k);
                m = (m - k) / (1.0 - k);
                y = (y - k) / (1.0 - k);
            }
            printf(""(%d%%, %d%%, %d%%, %d%%)\n"",(int)(c*100),(int)(m*100),(int)(y*100),(int)(k*100));
            break;
            
        case 2:
            printf(""Enter the HEX color code: "");
            scanf(""%s"",color);
            printf(""The RGB color code is (%d, %d, %d)\n"", 
                (int)strtol(color+0, &ch, 16),
                (int)strtol(color+2, &ch, 16),
                (int)strtol(color+4, &ch, 16));
            printf(""The CMYK color code is "");
            r = (float)(strtol(color+0, &ch, 16)) / 255.0;
            g = (float)(strtol(color+2, &ch, 16)) / 255.0;
            b = (float)(strtol(color+4, &ch, 16)) / 255.0;
            float c1 = 1.0 - r;
            float m1 = 1.0 - g;
            float y1 = 1.0 - b;
            float k1 = (c1 < m1) ? c1 : m1;
            k1 = (k1 < y1) ? k1 : y1;
            if(k1 == 1.0)
            {
                c1 = m1 = y1 = 0.0;
            }
            else
            {
                c1 = (c1 - k1) / (1.0 - k1);
                m1 = (m1 - k1) / (1.0 - k1);
                y1 = (y1 - k1) / (1.0 - k1);
            }
            printf(""(%d%%, %d%%, %d%%, %d%%)\n"",(int)(c1*100),(int)(m1*100),(int)(y1*100),(int)(k1*100));
            break;
            
        case 3:
            printf(""Enter the CMYK values separated by a space: "");
            scanf(""%f%f%f%f"",&c,&m,&y,&k);
            printf(""The RGB color code is (%d, %d, %d)\n"",(int)((1-c)*(1-k)*255),(int)((1-m)*(1-k)*255),(int)((1-y)*(1-k)*255));
            printf(""The HEX color code is #%02X%02X%02X\n"",(int)((1-c)*(1-k)*255),(int)((1-m)*(1-k)*255),(int)((1-y)*(1-k)*255));
            printf(""The CMYK color code is (%d%%, %d%%, %d%%, %d%%)\n"",(int)(c*100),(int)(m*100),(int)(y*100),(int)(k*100));
            break;
            
        default:
            printf(""Invalid input. Please try again.\n"");
    }
    return 0;
}",81,10.0
VULNERABLE,gpt35-17704.c,yes,72,5,handle_client,"
  file gpt35-17704.c line 72 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"    return 0;
}

void *handle_client(void *_client_socket)
{
    int client_socket = *(int *)_client_socket;

    // Receive message from client
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, sizeof(buffer));
    ssize_t recv_size = recv(client_socket, buffer, sizeof(buffer), 0);","//FormAI DATASET v1.0 Category: Networking ; Style: imaginative
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CONNECTIONS 5
#define BUFFER_SIZE 1024

void *handle_client(void *);

int main(int argc, char *argv[])
{
    // Create socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0)
    {
        perror(""Failed to create socket"");
        exit(EXIT_FAILURE);
    }

    // Bind socket to a port
    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = htonl(INADDR_ANY);
    server_address.sin_port = htons(8080);

    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) < 0)
    {
        perror(""Failed to bind socket"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, MAX_CONNECTIONS) < 0)
    {
        perror(""Failed to listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server running on port %d\n"", ntohs(server_address.sin_port));
    printf(""Waiting for incoming connections...\n"");

    // Accept incoming connections
    int client_socket;
    struct sockaddr_in client_address;
    socklen_t client_address_len = sizeof(client_address);

    while ((client_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_len)))
    {
        printf(""Connection accepted, creating thread for client...\n"");

        pthread_t thread_id;
        if (pthread_create(&thread_id, NULL, handle_client, (void *)&client_socket) != 0)
        {
            perror(""Failed to create thread"");
            exit(EXIT_FAILURE);
        }
    }

    // Close server socket
    close(server_socket);

    return 0;
}

void *handle_client(void *_client_socket)
{
    int client_socket = *(int *)_client_socket;

    // Receive message from client
    char buffer[BUFFER_SIZE];
    memset(buffer, 0, sizeof(buffer));
    ssize_t recv_size = recv(client_socket, buffer, sizeof(buffer), 0);

    if (recv_size < 0)
    {
        perror(""Error receiving message from client"");
        exit(EXIT_FAILURE);
    }

    printf(""Received message from client: '%s'\n"", buffer);

    // Send message back to client
    char *message = ""Hello from server!"";
    ssize_t send_size = send(client_socket, message, strlen(message), 0);

    if (send_size < 0)
    {
        perror(""Error sending message to client"");
        exit(EXIT_FAILURE);
    }

    printf(""Sent message to client: '%s'\n"", message);

    // Close client socket
    close(client_socket);

    pthread_exit(NULL);
}",103,4.5
VULNERABLE,falcon180b-50766.c,yes,25,5,handle_client,"
  file falcon180b-50766.c line 25 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {","//Falcon-180B DATASET v1.0 Category: Networking ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080
#define SERVER_IP ""127.0.0.1""

int server_socket;
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];
    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
        if (bytes_received <= 0) {
            break;
        }
        printf(""Client %d sent message: %s\n"", client_socket, buffer);
        for (int i = 0; i < num_clients; i++) {
            if (i!= client_socket) {
                send(client_sockets[i], buffer, strlen(buffer), 0);
            }
        }
    }
    close(client_socket);
    return NULL;
}

int main() {
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    server_addr.sin_port = htons(SERVER_PORT);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, MAX_CLIENTS);

    while (1) {
        printf(""Waiting for client connections...\n"");
        int client_socket = accept(server_socket, NULL, NULL);
        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        client_sockets[num_clients++] = client_socket;
    }

    close(server_socket);
    return 0;
}",68,3.5
VULNERABLE,falcon180b-56167.c,yes,17,5,handle_client,"
  file falcon180b-56167.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        recv(client_socket, buffer, sizeof(buffer), 0);
        printf(""Client %d sent: %s\n"", client_socket, buffer);

        if (strcmp(buffer, ""light on"") == 0) {
            system(""echo 1 > /sys/class/leds/led1/brightness"");
        } else if (strcmp(buffer, ""light off"") == 0) {
            system(""echo 0 > /sys/class/leds/led1/brightness"");
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 5);

    printf(""Server is listening on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);
        printf(""Client connected on socket %d\n"", client_socket);

        if (num_clients == MAX_CLIENTS) {
            send(client_socket, ""Server is full\n"", sizeof(""Server is full\n""), 0);
            close(client_socket);
        } else {
            clients[num_clients++] = client_socket;
            pthread_t thread_id;
            pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        }
    }

    return 0;
}",62,3.5
VULNERABLE,falcon180b-41132.c,yes,19,5,handle_client,"
  file falcon180b-41132.c line 19 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: System event logger ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
#define SERVER_PORT 8080

int client_sockets[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUFFER_SIZE];

    while (1) {
        memset(buffer, 0, BUFFER_SIZE);
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);

        if (bytes_received <= 0) {
            break;
        }

        printf(""Client %d sent: %s\n"", client_socket, buffer);
        fflush(stdout);
    }

    close(client_socket);
    return NULL;
}

void accept_clients() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, MAX_CLIENTS) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server is listening on port %d\n"", SERVER_PORT);

    while (1) {
        struct sockaddr_in client_addr;
        socklen_t addr_size = sizeof(client_addr);
        int client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);

        if (client_socket == -1) {
            perror(""accept"");
            exit(EXIT_FAILURE);
        }

        printf(""Client %d connected\n"", client_socket);

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
        num_clients++;
    }
}

int main() {
    srand(time(NULL));

    accept_clients();

    return 0;
}",88,3.333
VULNERABLE,gpt35-75127.c,yes,43,13,main,"
  file gpt35-75127.c line 43 column 13 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `confirm'",dereference failure: accessed expired variable pointer,"
        case 2:
            // Reboot system
            printf(""Are you sure you want to reboot the system? (y/n)\n"");

            scanf("" %c"", &confirm);

            if (confirm == 'y' || confirm == 'Y') {
                system(""reboot"");
            } else {
                printf(""Reboot cancelled.\n"");","//FormAI DATASET v1.0 Category: System administration ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Print welcome message
    printf(""Welcome to the peaceful system administration program.\n\n"");
    
    // Prompt user to choose an option
    printf(""Please choose an option:\n"");
    printf(""1. Shutdown system\n"");
    printf(""2. Reboot system\n"");
    printf(""3. View system status\n"");
    printf(""4. Exit program\n\n"");
    
    int choice;
    
    // Get user input
    printf(""Enter your choice: "");
    scanf(""%d"", &choice);
    
    // Handle user choice
    switch (choice) {
        case 1:
            // Shutdown system
            printf(""Are you sure you want to shutdown the system? (y/n)\n"");
            
            char confirm;
            scanf("" %c"", &confirm);
            
            if (confirm == 'y' || confirm == 'Y') {
                system(""shutdown -h now"");
            } else {
                printf(""Shutdown cancelled.\n"");
            }
            
            break;
            
        case 2:
            // Reboot system
            printf(""Are you sure you want to reboot the system? (y/n)\n"");
            
            scanf("" %c"", &confirm);
            
            if (confirm == 'y' || confirm == 'Y') {
                system(""reboot"");
            } else {
                printf(""Reboot cancelled.\n"");
            }
            
            break;
            
        case 3:
            // View system status
            system(""top"");
            
            break;
            
        case 4:
            // Exit program
            printf(""Exiting program...\n"");
            exit(0);
            
        default:
            // Invalid choice
            printf(""Invalid choice. Please try again.\n"");
    }
    
    return 0;
}",70,9.0
VULNERABLE,falcon180b-56980.c,yes,18,5,handle_client,"
  file falcon180b-56980.c line 18 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        bzero(buffer, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);","//Falcon-180B DATASET v1.0 Category: Smart home automation ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define BUF_SIZE 1024
#define PORT 8080

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[BUF_SIZE];

    while (1) {
        bzero(buffer, BUF_SIZE);
        int bytes_received = recv(client_socket, buffer, BUF_SIZE, 0);

        if (bytes_received <= 0) {
            close(client_socket);
            pthread_exit(NULL);
        }

        char *command = strtok(buffer, "" "");
        if (strcmp(command, ""lights"") == 0) {
            char *status = strtok(NULL, "" "");
            if (strcmp(status, ""on"") == 0) {
                // Turn lights on
            } else if (strcmp(status, ""off"") == 0) {
                // Turn lights off
            }
        } else if (strcmp(command, ""temperature"") == 0) {
            char *value = strtok(NULL, "" "");
            // Set temperature to specified value
        } else if (strcmp(command, ""exit"") == 0) {
            pthread_exit(NULL);
        }
    }
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));
    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum number of clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",78,5.5
VULNERABLE,codellama_13b-5773.c,yes,48,5,main,"
  file codellama_13b-5773.c line 48 column 5 function main
","
  c:@F@main
  dereference failure: accessed expired variable pointer `password'",dereference failure: accessed expired variable pointer,"
    // Print the password
    printf(""Your password is: %s\n"", password);

    // Free the memory allocated for the password
    free(password);

    return 0;
}","//Code Llama-13B DATASET v1.0 Category: Secure Password Generator ; Style: funny
// A funny unique C secure password generator program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define PASSWORD_LENGTH 16

// Function to generate a random password
char *generate_password(void) {
    char password[PASSWORD_LENGTH + 1];
    int i;

    // Generate a random number between 0 and 25
    int random_number = rand() % 26;

    // Assign the first character of the password to the random number
    password[0] = 'A' + random_number;

    // Generate the remaining characters of the password
    for (i = 1; i < PASSWORD_LENGTH; i++) {
        // Generate a random number between 0 and 25
        random_number = rand() % 26;

        // Assign the next character of the password to the random number
        password[i] = 'A' + random_number;
    }

    // Null-terminate the password
    password[PASSWORD_LENGTH] = '\0';

    return password;
}

int main() {
    // Seed the random number generator
    srand(time(NULL));

    // Generate a password
    char *password = generate_password();

    // Print the password
    printf(""Your password is: %s\n"", password);

    // Free the memory allocated for the password
    free(password);

    return 0;
}",51,1.5
VULNERABLE,gpt35-53161.c,yes,62,5,handle_client,"
  file gpt35-53161.c line 62 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `new_socket'",dereference failure: accessed expired variable pointer,"    }
    return 0;
}

void *handle_client(void *socket_desc) {
    int sock = *(int*)socket_desc;
    int read_size;
    char message[1024], client_message[1024];

    // Send welcome message to the client
    strcpy(message, ""Welcome to the puzzling server!\n"");","//FormAI DATASET v1.0 Category: Client Server Application ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT 8080

void *handle_client(void *socket_desc);

int main() {
    int socket_desc, new_socket, c;
    struct sockaddr_in server, client;

    // Create socket
    socket_desc = socket(AF_INET, SOCK_STREAM, 0);
    if (socket_desc == -1) {
        perror(""Could not create socket"");
        return 1;
    }
    puts(""Socket created!"");

    // Prepare server sockaddr_in structure
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    // Bind
    if (bind(socket_desc, (struct sockaddr*)&server, sizeof(server)) < 0) {
        perror(""Bind failed"");
        return 1;
    }
    puts(""Bind done!"");

    // Listen
    listen(socket_desc, 3);

    // Accept and incoming connection
    puts(""Waiting for incoming connections..."");
    c = sizeof(struct sockaddr_in);
    while (new_socket = accept(socket_desc, (struct sockaddr*)&client, (socklen_t*)&c)) {
        pthread_t thread_id;
        printf(""Connection accepted from %s:%d\n"", inet_ntoa(client.sin_addr), ntohs(client.sin_port));
        if (pthread_create(&thread_id, NULL, handle_client, (void*)&new_socket) < 0) {
            perror(""Could not create thread"");
            return 1;
        }
        printf(""Handler assigned to thread %ld\n"", thread_id);
    }

    if (new_socket < 0) {
        perror(""Accept failed"");
        return 1;
    }
    return 0;
}

void *handle_client(void *socket_desc) {
    int sock = *(int*)socket_desc;
    int read_size;
    char message[1024], client_message[1024];

    // Send welcome message to the client
    strcpy(message, ""Welcome to the puzzling server!\n"");
    send(sock, message, strlen(message), 0);

    // Receive client's message repeatedly until the client disconnects
    while ((read_size = recv(sock, client_message, 1024, 0)) > 0) {
        // Handle the client's message
        if (strncmp(client_message, ""What is the answer to life, the universe, and everything?"", 53) == 0) {
            strcpy(message, ""The answer to life, the universe, and everything is 42\n"");
        } else {
            strcpy(message, ""I'm sorry, I cannot answer that question\n"");
        }
        // Send the response to the client
        send(sock, message, strlen(message), 0);
        // Clear the buffer
        memset(client_message, 0, sizeof(client_message));
    }

    if (read_size == 0) {
        puts(""Client disconnected"");
    } else if (read_size == -1) {
        perror(""Receive failed"");
        return (void*)1;
    }

    // Free the socket descriptor
    free(socket_desc);

    return 0;
}",95,5.5
VULNERABLE,falcon180b-66431.c,yes,17,5,handle_client,"
  file falcon180b-66431.c line 17 column 5 function handle_client
","
  c:@F@handle_client at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `client_socket'",dereference failure: accessed expired variable pointer,"
int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);","//Falcon-180B DATASET v1.0 Category: Smart home light control ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAX_CLIENTS 10
#define PORT 8888

int clients[MAX_CLIENTS];
int num_clients = 0;

void *handle_client(void *arg) {
    int client_socket = *(int *) arg;
    char buffer[1024];

    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);

        if (bytes_received <= 0) {
            close(client_socket);
            clients[num_clients] = 0;
            num_clients--;
            break;
        }

        printf(""Client %d: %s\n"", client_socket, buffer);

        if (strncmp(buffer, ""on"", 3) == 0) {
            system(""echo 1 > /sys/class/leds/led1/brightness"");
        } else if (strncmp(buffer, ""off"", 4) == 0) {
            system(""echo 0 > /sys/class/leds/led1/brightness"");
        }
    }

    return NULL;
}

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;

    bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr));

    listen(server_socket, 3);

    printf(""Server started on port %d\n"", PORT);

    while (1) {
        int client_socket = accept(server_socket, NULL, NULL);

        if (num_clients >= MAX_CLIENTS) {
            close(client_socket);
            printf(""Maximum clients reached\n"");
            continue;
        }

        clients[num_clients] = client_socket;
        num_clients++;

        pthread_t thread_id;
        pthread_create(&thread_id, NULL, handle_client, (void *) &client_socket);
    }

    return 0;
}",75,4.0
VULNERABLE,falcon180b-43702.c,yes,34,5,ghost_thread,"
  file falcon180b-43702.c line 34 column 5 function ghost_thread
","
  c:@F@ghost_thread at file pthread_lib.c line 164 column 20 function pthread_trampoline
  dereference failure: accessed expired variable pointer `i'",dereference failure: accessed expired variable pointer,"    {""Bedroom Ghost"", 2},
    {""Bathroom Ghost"", 3}
};

void *ghost_thread(void *arg) {
    int index = *(int *)arg;
    struct ghost *ghost = &ghosts[index];

    printf(""Ghost %s is haunting the %s.\n"", ghost->name, rooms[ghost->room_index].name);

    for (int i = 0; i < 5; i++) {","//Falcon-180B DATASET v1.0 Category: Haunted House Simulator ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

#define NUM_ROOMS 4

struct room {
    char *name;
    int num_ghosts;
};

struct ghost {
    char *name;
    int room_index;
};

struct room rooms[NUM_ROOMS] = {
    {""Living Room"", 0},
    {""Kitchen"", 0},
    {""Bedroom"", 0},
    {""Bathroom"", 0}
};

struct ghost ghosts[NUM_ROOMS] = {
    {""Living Room Ghost"", 0},
    {""Kitchen Ghost"", 1},
    {""Bedroom Ghost"", 2},
    {""Bathroom Ghost"", 3}
};

void *ghost_thread(void *arg) {
    int index = *(int *)arg;
    struct ghost *ghost = &ghosts[index];

    printf(""Ghost %s is haunting the %s.\n"", ghost->name, rooms[ghost->room_index].name);

    for (int i = 0; i < 5; i++) {
        printf(""Boo! "");
        sleep(1);
    }

    pthread_exit(0);
}

int main() {
    srand(time(0));

    for (int i = 0; i < NUM_ROOMS; i++) {
        rooms[i].num_ghosts = rand() % 3 + 1;
    }

    pthread_t threads[NUM_ROOMS];

    for (int i = 0; i < NUM_ROOMS; i++) {
        pthread_create(&threads[i], NULL, ghost_thread, &i);
    }

    for (int i = 0; i < NUM_ROOMS; i++) {
        pthread_join(threads[i], NULL);
    }

    return 0;
}",65,3.0
VULNERABLE,falcon180b-45300.c,yes,32,5,main,"
  file string.c line 30 column 10 function strcpy
","
  c:@F@strcpy at file falcon180b-45300.c line 32 column 5 function main
  c:@F@main
  dereference failure: accessed expired variable pointer `output_date'",dereference failure: accessed expired variable pointer,"    if (!is_valid_date(date)) {
        printf(""Invalid date.\n"");
        return 1;
    }

    strcpy(output_date, format_date(date, format_string));
    printf(""Output date: %s\n"", output_date);

    return 0;
}
","//Falcon-180B DATASET v1.0 Category: Natural Language Date Converter ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#define MAX_STRING_LENGTH 100

struct tm parse_date(char* date_string);
int is_valid_date(struct tm date);
char* format_date(struct tm date, char* format_string);

int main() {
    char input_date[MAX_STRING_LENGTH];
    char output_date[MAX_STRING_LENGTH];
    char format_string[MAX_STRING_LENGTH];

    printf(""Enter a date (YYYY-MM-DD): "");
    scanf(""%s"", input_date);

    printf(""Enter an output format (YYYY-MM-DD): "");
    scanf(""%s"", format_string);

    struct tm date = parse_date(input_date);

    if (!is_valid_date(date)) {
        printf(""Invalid date.\n"");
        return 1;
    }

    strcpy(output_date, format_date(date, format_string));
    printf(""Output date: %s\n"", output_date);

    return 0;
}

struct tm parse_date(char* date_string) {
    struct tm date = {0};
    int year, month, day;

    if (sscanf(date_string, ""%d-%d-%d"", &year, &month, &day)!= 3) {
        return date;
    }

    date.tm_year = year - 1900;
    date.tm_mon = month - 1;
    date.tm_mday = day;

    return date;
}

int is_valid_date(struct tm date) {
    time_t timestamp = mktime(&date);

    if (timestamp == -1) {
        return 0;
    }

    return 1;
}

char* format_date(struct tm date, char* format_string) {
    char output_date[MAX_STRING_LENGTH] = {0};
    strftime(output_date, MAX_STRING_LENGTH, format_string, &date);

    return output_date;
}",68,1.75
