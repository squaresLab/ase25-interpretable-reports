category,file_name,verification_finished,vulnerable_line,column,function,violated_property,stack_trace,error_type,code_snippet,source_code,num_lines,cyclomatic_complexity
VULNERABLE,gemma7b-17190.c,yes,65,5,csvReader_getLine,"
  file gemma7b-17190.c line 65 column 5 function csvReader_getLine
","
  c:@F@csvReader_getLine at file gemma7b-17190.c line 78 column 22 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"int csvReader_getColumnNumber(CSVReader* reader) {
    return reader->columnNumber;
}

char* csvReader_getLine(CSVReader* reader) {
    return reader->buffer[reader->lineNumber - 1];
}

int main() {
    CSVReader* reader = csvReader_init(""example.csv"");
","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
    FILE* file;
    char** buffer;
    int bufferSize;
    int lineNumber;
    int columnNumber;
} CSVReader;

CSVReader* csvReader_init(char* filename) {
    CSVReader* reader = (CSVReader*)malloc(sizeof(CSVReader));
    reader->file = fopen(filename, ""r"");
    reader->buffer = NULL;
    reader->bufferSize = 0;
    reader->lineNumber = 0;
    reader->columnNumber = 0;
    return reader;
}

void csvReader_free(CSVReader* reader) {
    fclose(reader->file);
    free(reader->buffer);
    free(reader);
}

int csvReader_readNextLine(CSVReader* reader) {
    char* line = NULL;
    int lineLength = 0;

    reader->lineNumber++;

    // Allocate memory for the line
    line = (char*)malloc(MAX_BUFFER_SIZE);

    // Read the line from the file
    lineLength = fgets(line, MAX_BUFFER_SIZE, reader->file);

    // Check if the line was read successfully
    if (lineLength == -1) {
        return -1;
    }

    // Store the line in the buffer
    reader->buffer = (char**)realloc(reader->buffer, (reader->bufferSize + 1) * sizeof(char*));
    reader->buffer[reader->bufferSize++] = line;

    return 0;
}

int csvReader_getLineNumber(CSVReader* reader) {
    return reader->lineNumber;
}

int csvReader_getColumnNumber(CSVReader* reader) {
    return reader->columnNumber;
}

char* csvReader_getLine(CSVReader* reader) {
    return reader->buffer[reader->lineNumber - 1];
}

int main() {
    CSVReader* reader = csvReader_init(""example.csv"");

    // Read the next line from the CSV file
    if (csvReader_readNextLine(reader) == 0) {
        // Get the line number and column number
        int lineNumber = csvReader_getLineNumber(reader);
        int columnNumber = csvReader_getColumnNumber(reader);

        // Get the line
        char* line = csvReader_getLine(reader);

        // Print the line
        printf(""Line %d, Column %d: %s\n"", lineNumber, columnNumber, line);
    }

    // Free the CSV reader
    csvReader_free(reader);

    return 0;
}",88,1.286
VULNERABLE,gemma7b-29493.c,yes,22,9,dealCards,"
  file gemma7b-29493.c line 22 column 9 function dealCards
","
  c:@F@dealCards at file gemma7b-29493.c line 40 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    int numCards;
} Player;

void dealCards(Player *players, int numPlayers) {
    for (int i = 0; i < numPlayers; i++) {
        for (int j = 0; j < players[i].numCards; j++) {
            players[i].hand[j].suit = 'H' + rand() % 4;
            players[i].hand[j].number = rand() % 13 + 1;
        }
    }
}","//Gemma-7B DATASET v1.0 Category: Table Game ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_Players 4
#define MAX_Cards 10

typedef struct Card {
    char suit;
    int number;
} Card;

typedef struct Player {
    char name[20];
    Card hand[MAX_Cards];
    int numCards;
} Player;

void dealCards(Player *players, int numPlayers) {
    for (int i = 0; i < numPlayers; i++) {
        for (int j = 0; j < players[i].numCards; j++) {
            players[i].hand[j].suit = 'H' + rand() % 4;
            players[i].hand[j].number = rand() % 13 + 1;
        }
    }
}

int compareCards(Card a, Card b) {
    return a.suit - b.suit * 10 + a.number - b.number;
}

int main() {
    Player players[MAX_Players];
    for (int i = 0; i < MAX_Players; i++) {
        players[i].numCards = 5;
        players[i].name[0] = 'A' + i;
    }

    dealCards(players, MAX_Players);

    int winner = -1;
    for (int i = 0; i < MAX_Players; i++) {
        for (int j = 0; j < players[i].numCards; j++) {
            for (int k = 0; k < MAX_Players; k++) {
                if (k != i && compareCards(players[i].hand[j], players[k].hand[0]) < 0) {
                    winner = i;
                }
            }
        }
    }

    printf(""The winner is: %s"", players[winner].name);

    return 0;
}",56,3.667
VULNERABLE,gemini_pro-18225.c,yes,35,9,calculate_checksum,"
  file gemini_pro-18225.c line 35 column 9 function calculate_checksum
","
  c:@F@calculate_checksum at file gemini_pro-18225.c line 56 column 24 function create_icmp_echo_request
  c:@F@create_icmp_echo_request at file gemini_pro-18225.c line 157 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    uint16_t sum = 0;
    uint16_t *words = (uint16_t *)buffer;
    int words_count = len / sizeof(uint16_t);

    for (int i = 0; i < words_count; i++) {
        sum += words[i];
    }

    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }","//GEMINI-pro DATASET v1.0 Category: Network Ping Test ; Style: surprised
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <time.h>

#define ICMP_ECHO_REQUEST 8
#define ICMP_ECHO_REPLY 0
#define ICMP_ECHO_HEADER_LEN 8

// Surprise! This program implements a basic ICMP ping utility in C.
// It allows you to send ICMP echo requests to a specified IP address
// and measure the time it takes to receive a response.

// Structure to represent an ICMP echo request header.
struct icmp_echo_header {
    uint8_t type;
    uint8_t code;
    uint16_t checksum;
    uint16_t identifier;
    uint16_t sequence_number;
    uint32_t timestamp;
};

// Function to calculate the checksum of an ICMP packet.
uint16_t calculate_checksum(void *buffer, size_t len) {
    uint16_t sum = 0;
    uint16_t *words = (uint16_t *)buffer;
    int words_count = len / sizeof(uint16_t);
    
    for (int i = 0; i < words_count; i++) {
        sum += words[i];
    }
    
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    
    return ~sum;
}

// Function to create an ICMP echo request packet.
void create_icmp_echo_request(struct icmp_echo_header *header, uint16_t identifier, uint16_t sequence_number) {
    // Initialize the header fields.
    header->type = ICMP_ECHO_REQUEST;
    header->code = 0;
    header->checksum = 0;
    header->identifier = identifier;
    header->sequence_number = sequence_number;
    header->timestamp = time(NULL);
    
    // Calculate the checksum.
    header->checksum = calculate_checksum(header, ICMP_ECHO_HEADER_LEN);
}

// Function to send an ICMP echo request packet to a specified IP address.
int send_icmp_echo_request(struct sockaddr_in *addr, struct icmp_echo_header *header) {
    // Create a raw socket for sending ICMP packets.
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0) {
        perror(""socket"");
        return -1;
    }
    
    // Set the socket options to allow sending ICMP packets.
    int on = 1;
    if (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
        perror(""setsockopt"");
        return -1;
    }
    
    // Send the ICMP echo request packet.
    if (sendto(sockfd, header, ICMP_ECHO_HEADER_LEN, 0, (struct sockaddr *)addr, sizeof(*addr)) < 0) {
        perror(""sendto"");
        return -1;
    }
    
    close(sockfd);
    return 0;
}

// Function to receive an ICMP echo reply packet.
int receive_icmp_echo_reply(struct sockaddr_in *addr, struct icmp_echo_header *header) {
    // Create a raw socket for receiving ICMP packets.
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0) {
        perror(""socket"");
        return -1;
    }
    
    // Set a timeout on the socket so that it doesn't block forever.
    struct timeval timeout;
    timeout.tv_sec = 1;
    timeout.tv_usec = 0;
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
        perror(""setsockopt"");
        return -1;
    }
    
    // Receive the ICMP echo reply packet.
    socklen_t addr_len = sizeof(*addr);
    if (recvfrom(sockfd, header, ICMP_ECHO_HEADER_LEN, 0, (struct sockaddr *)addr, &addr_len) < 0) {
        perror(""recvfrom"");
        return -1;
    }
    
    close(sockfd);
    return 0;
}

// Function to calculate the round-trip time for an ICMP echo request.
double calculate_round_trip_time(struct icmp_echo_header *request, struct icmp_echo_header *reply) {
    // Convert the timestamp to milliseconds.
    double request_timestamp = (double)request->timestamp * 1000.0;
    double reply_timestamp = (double)reply->timestamp * 1000.0;
    
    // Calculate the round-trip time.
    return reply_timestamp - request_timestamp;
}

// Function to print the results of a ping test.
void print_ping_results(struct sockaddr_in *addr, double round_trip_time) {
    // Convert the IP address to a string.
    char ip_address[INET_ADDRSTRLEN];
    if (inet_ntop(AF_INET, &addr->sin_addr, ip_address, sizeof(ip_address)) == NULL) {
        perror(""inet_ntop"");
        return;
    }
    
    // Print the results.
    printf(""Ping %s (%s):\n"", ip_address, inet_ntoa(addr->sin_addr));
    printf(""  Round-trip time: %.3f ms\n"", round_trip_time);
    printf(""\n"");
}

// Main function.
int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf(""Usage: %s <IP address>\n"", argv[0]);
        return 1;
    }
    
    // Parse the IP address.
    struct sockaddr_in addr;
    if (inet_pton(AF_INET, argv[1], &addr.sin_addr) != 1) {
        printf(""Invalid IP address: %s\n"", argv[1]);
        return 1;
    }
    
    addr.sin_family = AF_INET;
    
    // Create an ICMP echo request header.
    struct icmp_echo_header request;
    create_icmp_echo_request(&request, 0, 0);
    
    // Send the ICMP echo request packet.
    if (send_icmp_echo_request(&addr, &request) < 0) {
        return 1;
    }
    
    // Receive the ICMP echo reply packet.
    struct icmp_echo_header reply;
    if (receive_icmp_echo_reply(&addr, &reply) < 0) {
        return 1;
    }
    
    // Calculate the round-trip time.
    double round_trip_time = calculate_round_trip_time(&request, &reply);
    
    // Print the results.
    print_ping_results(&addr, round_trip_time);
    
    return 0;
}",177,2.857
VULNERABLE,gemma7b-14247.c,yes,36,9,csv_reader_read,"
  file gemma7b-14247.c line 36 column 9 function csv_reader_read
","
  c:@F@csv_reader_read at file gemma7b-14247.c line 51 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    char *line = NULL;

    while (getline(reader->fp, line, MAX_BUFFER_SIZE) > 0)
    {
        reader->buffer = realloc(reader->buffer, (reader->size + 1) * sizeof(char *));
        reader->buffer[reader->size++] = line;
    }
}

void csv_reader_close(CSVReader *reader)
{","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader
{
    char **buffer;
    int size;
    int pos;
    FILE *fp;
} CSVReader;

CSVReader *csv_reader_init(FILE *fp)
{
    CSVReader *reader = malloc(sizeof(CSVReader));

    reader->buffer = NULL;
    reader->size = 0;
    reader->pos = 0;
    reader->fp = fp;

    return reader;
}

void csv_reader_read(CSVReader *reader)
{
    int line_size = 0;
    char *line = NULL;

    while (getline(reader->fp, line, MAX_BUFFER_SIZE) > 0)
    {
        reader->buffer = realloc(reader->buffer, (reader->size + 1) * sizeof(char *));
        reader->buffer[reader->size++] = line;
    }
}

void csv_reader_close(CSVReader *reader)
{
    free(reader->buffer);
    fclose(reader->fp);
    free(reader);
}

int main()
{
    FILE *fp = fopen(""data.csv"", ""r"");
    CSVReader *reader = csv_reader_init(fp);
    csv_reader_read(reader);
    csv_reader_close(reader);

    return 0;
}",55,1.25
VULNERABLE,gemini_pro-12710.c,yes,77,9,main,"
  file gemini_pro-12710.c line 77 column 9 function main
","
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    printf(""How many potions desirest thou? Enter the quantity:\n"");
    scanf(""%d"", &quantity);

    // Check if our humble abode has enough stock.
    if (quantity > medicine->quantity) {
        printf(""We apologize, but we have but %d of %s in stock.\n"", medicine->quantity, medicine->name);
        return 0;
    }

    // Rejoice! We have the medicine and the quantity they desire.
    printf(""Thy request has been granted, good sir or madam!\n"");","//GEMINI-pro DATASET v1.0 Category: Medical Store Management System ; Style: medieval
// Hark! Ye seekers of medicinal remedies, gather 'round!

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Huzzah! Our humble apothecary, where healing herbs and elixirs reside.
typedef struct {
    char *name;
    char *description;
    int quantity;
} Medicine;

// Lo, our trusty list of medicines, ready at thy behest.
Medicine medicines[] = {
    {""Healing Salve"", ""A balm for thy wounds, gentle and soothing"", 20},
    {""Strength Potion"", ""Quenches thy thirst for vigor, grants thee power"", 15},
    {""Mana Elixir"", ""Invigorates thy mind, sharpens thy wit"", 10},
    {""Antivenom"", ""Counteracts the venom's bite, saves thee from death's door"", 5},
    {""Rejuvenation Potion"", ""Restores thy youth, banishes aches and pains"", 3}
};

// A ledger to track our transactions, for the eyes of the realm's healers.
typedef struct {
    char *patientName;
    Medicine *medicine;
    int quantity;
    char *date;
} Transaction;

// Now, let us begin our noble quest to manage the medical store.
int main() {
    // Greet our worthy patrons.
    printf(""Welcome to the Medical Store of Ye Olde Apothecary!\n"");

    // Allow them to peruse our wares.
    printf(""Behold, our humble offerings:\n"");
    for (int i = 0; i < sizeof(medicines) / sizeof(Medicine); i++) {
        printf(""%s:\n"", medicines[i].name);
        printf(""    %s\n"", medicines[i].description);
        printf(""    Quantity: %d\n\n"", medicines[i].quantity);
    }

    // Lend them an ear, asking for their needs.
    char patientName[100];
    Medicine *medicine;
    int quantity;
    printf(""What ails thee, good sir or madam? Enter thy name:\n"");
    scanf(""%s"", patientName);

    // Determine the medicine they seek.
    char medicineName[100];
    printf(""What medicine dost thou require? Enter its name:\n"");
    scanf(""%s"", medicineName);

    // Search our humble abode for the desired elixir.
    for (int i = 0; i < sizeof(medicines) / sizeof(Medicine); i++) {
        if (strcmp(medicineName, medicines[i].name) == 0) {
            medicine = &medicines[i];
            break;
        }
    }

    // Alas, if the medicine is not found, we must lament.
    if (medicine == NULL) {
        printf(""Alas! We regret to inform thee that we lack the medicine thou seekest.\n"");
        return 0;
    }

    // Confirm the quantity they desire.
    printf(""How many potions desirest thou? Enter the quantity:\n"");
    scanf(""%d"", &quantity);

    // Check if our humble abode has enough stock.
    if (quantity > medicine->quantity) {
        printf(""We apologize, but we have but %d of %s in stock.\n"", medicine->quantity, medicine->name);
        return 0;
    }

    // Rejoice! We have the medicine and the quantity they desire.
    printf(""Thy request has been granted, good sir or madam!\n"");

    // Deduct the quantity from our stock.
    medicine->quantity -= quantity;

    // Record the transaction for posterity.
    Transaction transaction;
    transaction.patientName = malloc(strlen(patientName) + 1);
    strcpy(transaction.patientName, patientName);
    transaction.medicine = medicine;
    transaction.quantity = quantity;
    transaction.date = malloc(11);
    strcpy(transaction.date, ""Ye Olde Date""); // Thou shalt fill this in later, fair scribe.

    // Bid farewell to our esteemed patron.
    printf(""May thy ailments be cast away! Fare thee well!\n"");

    // Release our resources, for the realm's healers await our aid.
    free(transaction.patientName);
    free(transaction.date);

    return 0;
}",104,6.0
VULNERABLE,gemma7b-44190.c,yes,21,5,dealCards,"
  file gemma7b-44190.c line 21 column 5 function dealCards
","
  c:@F@dealCards at file gemma7b-44190.c line 48 column 3 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"  Card cards[MAX_NUM_CARDS];
} Player;

void dealCards(Player *players, int numPlayers) {
  for (int i = 0; i < numPlayers; i++) {
    for (int j = 0; j < players[i].numCards; j++) {
      players[i].cards[j].number = rand() % MAX_NUM_CARDS + 1;
      players[i].cards[j].suit = 'H' + rand() % 4;
    }
  }
}","//Gemma-7B DATASET v1.0 Category: Poker Game ; Style: configurable
#include <stdio.h>
#include <stdlib.h>

#define MAX_NUM_PLAYERS 5
#define MAX_NUM_CARDS 52

typedef struct Card {
  int number;
  char suit;
} Card;

typedef struct Player {
  char name[20];
  int numCards;
  Card cards[MAX_NUM_CARDS];
} Player;

void dealCards(Player *players, int numPlayers) {
  for (int i = 0; i < numPlayers; i++) {
    for (int j = 0; j < players[i].numCards; j++) {
      players[i].cards[j].number = rand() % MAX_NUM_CARDS + 1;
      players[i].cards[j].suit = 'H' + rand() % 4;
    }
  }
}

void showCards(Player *players, int numPlayers) {
  for (int i = 0; i < numPlayers; i++) {
    printf(""%s:"", players[i].name);
    for (int j = 0; j < players[i].numCards; j++) {
      printf("" (%d %c)"", players[i].cards[j].number, players[i].cards[j].suit);
    }
    printf(""\n"");
  }
}

int main() {
  Player players[MAX_NUM_PLAYERS];
  int numPlayers = 2;

  // Initialize players
  for (int i = 0; i < numPlayers; i++) {
    players[i].numCards = 5;
  }

  // Deal cards
  dealCards(players, numPlayers);

  // Show cards
  showCards(players, numPlayers);

  return 0;
}",54,2.667
VULNERABLE,falcon180b-6553.c,yes,20,5,addLink,"
  file falcon180b-6553.c line 20 column 5 function addLink
","
  c:@F@addLink at file falcon180b-6553.c line 81 column 17 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"};

//Function to add a link to the node
void addLink(struct node *node, struct node *link){
    node->num_links++;
    node->links[node->num_links-1] = link;
}

//Function to display the topology
void displayTopology(struct node *nodes){
    int i;","//Falcon-180B DATASET v1.0 Category: Network Topology Mapper ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODES 100
#define MAX_LINKS 100

//Node structure
struct node{
    int id;
    char name[20];
    int num_links;
    struct node *links[MAX_LINKS];
};

//Function to add a link to the node
void addLink(struct node *node, struct node *link){
    node->num_links++;
    node->links[node->num_links-1] = link;
}

//Function to display the topology
void displayTopology(struct node *nodes){
    int i;
    printf(""Topology:\n"");
    for(i=0;i<MAX_NODES;i++){
        if(nodes[i].id!= -1){
            printf(""Node %d: %s\n"",nodes[i].id,nodes[i].name);
            printf(""Links:\n"");
            int j;
            for(j=0;j<nodes[i].num_links;j++){
                printf(""\t%d\n"",nodes[i].links[j]->id);
            }
        }
    }
}

//Function to create a new node
struct node* createNode(int id, char *name){
    struct node *node = (struct node*)malloc(sizeof(struct node));
    node->id = id;
    strcpy(node->name,name);
    node->num_links = 0;
    int i;
    for(i=0;i<MAX_LINKS;i++){
        node->links[i] = NULL;
    }
    return node;
}

//Main function
int main(){
    struct node nodes[MAX_NODES];
    int num_nodes = 0;
    int choice;
    char name[20];
    do{
        printf(""Enter 1 to add a node\n"");
        printf(""Enter 2 to add a link\n"");
        printf(""Enter 3 to display topology\n"");
        printf(""Enter 4 to exit\n"");
        scanf(""%d"",&choice);
        switch(choice){
            case 1:
                printf(""Enter node ID: "");
                scanf(""%d"",&nodes[num_nodes].id);
                printf(""Enter node name: "");
                scanf(""%s"",nodes[num_nodes].name);
                num_nodes++;
                break;
            case 2:
                printf(""Enter source node ID: "");
                scanf(""%d"",&nodes[num_nodes-1].id);
                printf(""Enter source node name: "");
                scanf(""%s"",nodes[num_nodes-1].name);
                printf(""Enter destination node ID: "");
                scanf(""%d"",&nodes[num_nodes].id);
                printf(""Enter destination node name: "");
                scanf(""%s"",nodes[num_nodes].name);
                addLink(&nodes[num_nodes-1],&nodes[num_nodes]);
                num_nodes++;
                break;
            case 3:
                displayTopology(nodes);
                break;
            case 4:
                exit(0);
            default:
                printf(""Invalid choice\n"");
        }
    }while(choice!= 4);
    return 0;
}",94,3.25
VULNERABLE,codellama_13b-4549.c,yes,30,5,turn_device_on_off,"
  file codellama_13b-4549.c line 30 column 5 function turn_device_on_off
","
  c:@F@turn_device_on_off at file codellama_13b-4549.c line 37 column 5 function turn_component_on_off
  c:@F@turn_component_on_off at file codellama_13b-4549.c line 65 column 13 function simulate_smart_home_system
  c:@F@simulate_smart_home_system at file codellama_13b-4549.c line 92 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"SmartComponent components[5];

// Function to turn a device on or off
void turn_device_on_off(SmartDevice *device, bool on) {
    device->is_on = on;
    printf(""Device %s is now %s\n"", device->name, on ? ""on"" : ""off"");
}

// Function to turn a component on or off
void turn_component_on_off(SmartComponent *component, bool on) {
    component->is_on = on;","//Code Llama-13B DATASET v1.0 Category: Smart home automation ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Structures to represent the different components of the smart home system
typedef struct {
    int id;
    char *name;
    int power;
    bool is_on;
} SmartDevice;

typedef struct {
    int id;
    char *name;
    int type; // 0 = light, 1 = temperature, 2 = security
    int power;
    bool is_on;
    SmartDevice *device;
} SmartComponent;

// Array to store the components of the smart home system
SmartComponent components[5];

// Function to turn a device on or off
void turn_device_on_off(SmartDevice *device, bool on) {
    device->is_on = on;
    printf(""Device %s is now %s\n"", device->name, on ? ""on"" : ""off"");
}

// Function to turn a component on or off
void turn_component_on_off(SmartComponent *component, bool on) {
    component->is_on = on;
    printf(""Component %s is now %s\n"", component->name, on ? ""on"" : ""off"");
    turn_device_on_off(component->device, on);
}

// Function to simulate the smart home system
void simulate_smart_home_system() {
    // Initialize the smart home system
    SmartDevice devices[3] = {
        {1, ""Living Room Light"", 10, false},
        {2, ""Kitchen Light"", 20, false},
        {3, ""Security Camera"", 5, false}
    };
    SmartComponent components[5] = {
        {1, ""Living Room Light"", 0, 10, false, &devices[0]},
        {2, ""Kitchen Light"", 0, 20, false, &devices[1]},
        {3, ""Security Camera"", 0, 5, false, &devices[2]},
        {4, ""Temperature Sensor"", 1, 10, false, NULL},
        {5, ""Motion Sensor"", 2, 5, false, NULL}
    };

    // Simulate the smart home system
    for (int i = 0; i < 10; i++) {
        // Check if the temperature sensor is triggered
        if (components[4].is_on) {
            turn_component_on_off(&components[4], false);
        }

        // Check if the motion sensor is triggered
        if (components[5].is_on) {
            turn_component_on_off(&components[5], false);
        }

        // Check if the security camera is triggered
        if (components[3].is_on) {
            turn_component_on_off(&components[3], false);
        }

        // Check if the lights are turned on
        if (components[0].is_on && components[1].is_on) {
            turn_component_on_off(&components[0], false);
            turn_component_on_off(&components[1], false);
        }

        // Check if the lights are turned off
        if (!components[0].is_on && !components[1].is_on) {
            turn_component_on_off(&components[0], true);
            turn_component_on_off(&components[1], true);
        }

        // Simulate a delay between iterations
        sleep(1);
    }
}

int main() {
    // Simulate the smart home system
    simulate_smart_home_system();

    return 0;
}",95,3.5
VULNERABLE,falcon180b-11955.c,yes,45,9,insert_row,"
  file falcon180b-11955.c line 45 column 9 function insert_row
","
  c:@F@insert_row at file falcon180b-11955.c line 67 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    fclose(fp);
}

void insert_row(FILE *fp, int num_cols, char **values) {
    for (int i = 0; i < num_cols; i++) {
        fprintf(fp, ""%s\t"", values[i]);
    }
    fprintf(fp, ""\n"");
}

void print_table(FILE *fp) {","//Falcon-180B DATASET v1.0 Category: Database simulation ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ROWS 100
#define MAX_COLS 100

typedef struct {
    char *name;
    int age;
    float salary;
} Employee;

typedef struct {
    char *name;
    float balance;
} Account;

typedef struct {
    char *name;
    int num_employees;
    float revenue;
} Company;

typedef struct {
    char *name;
    int num_accounts;
    float total_balance;
} Bank;

void create_table(char *filename, int num_rows, int num_cols) {
    FILE *fp = fopen(filename, ""w"");
    for (int i = 0; i < num_rows; i++) {
        for (int j = 0; j < num_cols; j++) {
            fprintf(fp, ""%s\t"", """");
        }
        fprintf(fp, ""\n"");
    }
    fclose(fp);
}

void insert_row(FILE *fp, int num_cols, char **values) {
    for (int i = 0; i < num_cols; i++) {
        fprintf(fp, ""%s\t"", values[i]);
    }
    fprintf(fp, ""\n"");
}

void print_table(FILE *fp) {
    char line[1024];
    while (fgets(line, sizeof(line), fp)!= NULL) {
        printf(""%s"", line);
    }
}

int main() {
    Employee employees[] = {{""John Doe"", 30, 50000}, {""Jane Smith"", 28, 60000}, {""Jim Brown"", 35, 70000}};
    Account accounts[] = {{""Checking"", 10000}, {""Savings"", 20000}};
    Company companies[] = {{""Acme Corp"", 50, 1000000}, {""Widget Inc"", 75, 2000000}};
    Bank banks[] = {{""Bank of America"", 2, 30000}, {""Chase Bank"", 3, 50000}};

    create_table(""employees.txt"", 3, 3);
    insert_row(""employees.txt"", 3, (char **)employees);

    create_table(""accounts.txt"", 2, 2);
    insert_row(""accounts.txt"", 2, (char **)accounts);

    create_table(""companies.txt"", 2, 3);
    insert_row(""companies.txt"", 3, (char **)companies);

    create_table(""banks.txt"", 2, 3);
    insert_row(""banks.txt"", 3, (char **)banks);

    print_table(""employees.txt"");
    print_table(""accounts.txt"");
    print_table(""companies.txt"");
    print_table(""banks.txt"");

    return 0;
}",81,2.0
VULNERABLE,gpt35-31261.c,yes,45,9,init_circuit,"
  file gpt35-31261.c line 45 column 9 function init_circuit
","
  c:@F@init_circuit at file gpt35-31261.c line 137 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
// Initialize circuit
void init_circuit(circuit *c, double time_step) {
    for (int i = 0; i < MAX_NODES; i++) {
        c->nodes[i].index = i;
        c->nodes[i].voltage = 0.0;
    }
    c->num_nodes = 0;
    c->num_components = 0;
    c->time_step = time_step;
}","//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_NODES 1000
#define MAX_VALUE 1000000

// Define circuit components
typedef enum {
    RESISTOR,
    CAPACITOR,
    INDUCTOR,
    VOLTAGE_SOURCE,
    CURRENT_SOURCE
} component_type;

// Define circuit node
typedef struct {
    int index;
    double voltage;
} node;

// Define circuit component
typedef struct {
    component_type type;
    int node1;
    int node2;
    double value;
} component;

// Define circuit simulation
typedef struct {
    node nodes[MAX_NODES];
    component components[MAX_NODES];
    int num_nodes;
    int num_components;
    double time_step;
} circuit;

// Initialize circuit
void init_circuit(circuit *c, double time_step) {
    for (int i = 0; i < MAX_NODES; i++) {
        c->nodes[i].index = i;
        c->nodes[i].voltage = 0.0;
    }
    c->num_nodes = 0;
    c->num_components = 0;
    c->time_step = time_step;
}

// Add node to circuit
void add_node(circuit *c) {
    c->num_nodes++;
}

// Add component to circuit
void add_component(circuit *c, component_type type, int node1, int node2, double value) {
    c->components[c->num_components].type = type;
    c->components[c->num_components].node1 = node1;
    c->components[c->num_components].node2 = node2;
    c->components[c->num_components].value = value;
    c->num_components++;
}

// Perform simulation
void simulate(circuit *c, double simulation_time) {
    int num_time_steps = (int) (simulation_time / c->time_step);
    double *voltage_previous = (double *) malloc(sizeof(double) * c->num_nodes);
    for (int i = 0; i < c->num_nodes; i++) {
        voltage_previous[i] = 0.0;
    }
    for (int i = 0; i < num_time_steps; i++) {
        // Update component values
        for (int j = 0; j < c->num_components; j++) {
            switch (c->components[j].type) {
                case RESISTOR:
                    break;
                case CAPACITOR:
                    break;
                case INDUCTOR:
                    break;
                case VOLTAGE_SOURCE:
                    c->nodes[c->components[j].node1].voltage = c->components[j].value;
                    c->nodes[c->components[j].node2].voltage = -c->components[j].value;
                    break;
                case CURRENT_SOURCE:
                    break;
            }
        }
        // Update node voltages
        for (int j = 0; j < c->num_nodes; j++) {
            double voltage = 0.0;
            for (int k = 0; k < c->num_components; k++) {
                if (c->components[k].node1 == j) {
                    switch (c->components[k].type) {
                        case RESISTOR:
                            voltage += (voltage_previous[c->components[k].node1] - voltage_previous[c->components[k].node2]) / c->components[k].value;
                            break;
                        case CAPACITOR:
                            voltage += (c->nodes[c->components[k].node1].voltage - c->nodes[c->components[k].node2].voltage) * c->time_step / c->components[k].value;
                            break;
                        case INDUCTOR:
                            voltage += (c->nodes[c->components[k].node1].voltage - c->nodes[c->components[k].node2].voltage) * c->time_step * c->components[k].value;
                            break;
                        case VOLTAGE_SOURCE:
                            break;
                        case CURRENT_SOURCE:
                            break;
                    }
                } else if (c->components[k].node2 == j) {
                    switch (c->components[k].type) {
                        case RESISTOR:
                            voltage += (voltage_previous[c->components[k].node2] - voltage_previous[c->components[k].node1]) / c->components[k].value;
                            break;
                        case CAPACITOR:
                            voltage += (c->nodes[c->components[k].node2].voltage - c->nodes[c->components[k].node1].voltage) * c->time_step / c->components[k].value;
                            break;
                        case INDUCTOR:
                            voltage += (c->nodes[c->components[k].node2].voltage - c->nodes[c->components[k].node1].voltage) * c->time_step * c->components[k].value;
                            break;
                        case VOLTAGE_SOURCE:
                            break;
                        case CURRENT_SOURCE:
                            break;
                    }
                }
            }
            voltage_previous[j] = c->nodes[j].voltage;
            c->nodes[j].voltage = voltage;
        }
    }
}

int main() {
    circuit c;
    init_circuit(&c, 0.1);
    add_node(&c);
    add_node(&c);
    add_node(&c);
    add_component(&c, VOLTAGE_SOURCE, 0, 1, 1.0);
    add_component(&c, RESISTOR, 1, 2, 1.0);
    simulate(&c, 1.0);
    printf(""%f\n"", c.nodes[0].voltage);
    printf(""%f\n"", c.nodes[1].voltage);
    printf(""%f\n"", c.nodes[2].voltage);
    return 0;
}",148,5.6
VULNERABLE,gemma7b-2760.c,yes,39,13,csv_reader_parse,"
  file gemma7b-2760.c line 39 column 13 function csv_reader_parse
","
  c:@F@csv_reader_parse at file gemma7b-2760.c line 50 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
        reader->cols = 0;
        data[reader->rows - 1] = strdup(line);
        while (line[i] != '\n') {
            reader->cols++;
            data[reader->rows - 1] = realloc(data[reader->rows - 1], (reader->cols + 1) * sizeof(char));
            data[reader->rows - 1][reader->cols] = line[i];
            i++;
        }
    }
","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: happy
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
    FILE* file;
    char** buffer;
    int rows;
    int cols;
} CSVReader;

CSVReader* csv_reader_init(char* filename) {
    CSVReader* reader = malloc(sizeof(CSVReader));
    reader->file = fopen(filename, ""r"");
    reader->buffer = NULL;
    reader->rows = 0;
    reader->cols = 0;

    return reader;
}

void csv_reader_parse(CSVReader* reader) {
    char line[MAX_BUFFER_SIZE];
    char** data = NULL;
    int i = 0;

    while (fgets(line, MAX_BUFFER_SIZE, reader->file) != NULL) {
        reader->rows++;
        data = realloc(reader->buffer, reader->rows * sizeof(char*));
        reader->buffer = data;

        reader->cols = 0;
        data[reader->rows - 1] = strdup(line);
        while (line[i] != '\n') {
            reader->cols++;
            data[reader->rows - 1] = realloc(data[reader->rows - 1], (reader->cols + 1) * sizeof(char));
            data[reader->rows - 1][reader->cols] = line[i];
            i++;
        }
    }

    fclose(reader->file);
}

int main() {
    CSVReader* reader = csv_reader_init(""data.csv"");
    csv_reader_parse(reader);

    printf(""Number of rows: %d\n"", reader->rows);
    printf(""Number of columns: %d\n"", reader->cols);

    for (int i = 0; i < reader->rows; i++) {
        printf(""Row %d: %s\n"", i + 1, reader->buffer[i]);
    }

    free(reader->buffer);
    free(reader);

    return 0;
}",63,2.0
VULNERABLE,gpt35-22526.c,yes,83,9,print_circuit,"
  file gpt35-22526.c line 83 column 9 function print_circuit
","
  c:@F@print_circuit at file gpt35-22526.c line 112 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    for (int i = 0; i < circuit->num_nodes; i++) {
        printf(""\tNode %d: voltage=%lf\n"", circuit->nodes[i].id, circuit->nodes[i].voltage);
    }
    printf(""Edges:\n"");
    for (int i = 0; i < circuit->num_edges; i++) {
        printf(""\tEdge %d: source=%d, destination=%d, resistance=%lf\n"", circuit->edges[i].id, circuit->edges[i].source->id, circuit->edges[i].destination->id, circuit->edges[i].resistance);
    }
}

/*
 * Main function to simulate a simple circuit.","//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: Linus Torvalds
/*
 * classical_circuit_simulator.c - A classical circuit simulator example program
 * based on Kirchhoff's laws.
 * 
 * Copyright (C) [Year] [Your Name]
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 10 // Maximum number of nodes in the circuit
#define MAX_EDGES 20 // Maximum number of edges in the circuit

/*
 * A node in the circuit can have potential difference associated with it.
 * The potential difference between two nodes gives the voltage across the edge
 * connecting them.
 */
struct Node {
    int id;
    double voltage;
};

/*
 * An edge connects two nodes in the circuit and can have a resistance
 * associated with it.
 */
struct Edge {
    int id;
    struct Node *source;
    struct Node *destination;
    double resistance;
};

/*
 * A circuit contains an array of nodes and an array of edges between
 * those nodes.
 */
struct Circuit {
    struct Node nodes[MAX_NODES];
    struct Edge edges[MAX_EDGES];
    int num_nodes;
    int num_edges;
};
 
/*
 * Returns the node with the given id in the circuit.
 */
struct Node *get_node_by_id(struct Circuit *circuit, int node_id) {
    for (int i = 0; i < circuit->num_nodes; i++) {
        if (circuit->nodes[i].id == node_id) {
            return &circuit->nodes[i];
        }
    }
    return NULL;
}

/*
 * Prints the circuit details.
 */
void print_circuit(struct Circuit *circuit) {
    printf(""Circuit: %d nodes, %d edges\n"", circuit->num_nodes, circuit->num_edges);
    printf(""Nodes:\n"");
    for (int i = 0; i < circuit->num_nodes; i++) {
        printf(""\tNode %d: voltage=%lf\n"", circuit->nodes[i].id, circuit->nodes[i].voltage);
    }
    printf(""Edges:\n"");
    for (int i = 0; i < circuit->num_edges; i++) {
        printf(""\tEdge %d: source=%d, destination=%d, resistance=%lf\n"", circuit->edges[i].id, circuit->edges[i].source->id, circuit->edges[i].destination->id, circuit->edges[i].resistance);
    }
}

/*
 * Main function to simulate a simple circuit.
 */
int main() {
    struct Circuit circuit;
    circuit.num_nodes = 2;
    circuit.num_edges = 1;
    circuit.nodes[0].id = 0;
    circuit.nodes[0].voltage = 10.0;
    circuit.nodes[1].id = 1;
    circuit.nodes[1].voltage = 0.0;
    circuit.edges[0].id = 0;
    circuit.edges[0].source = get_node_by_id(&circuit, 0);
    circuit.edges[0].destination = get_node_by_id(&circuit, 1);
    circuit.edges[0].resistance = 10.0;

    printf(""Initial circuit:\n"");
    print_circuit(&circuit);

    // Simulate the circuit
    double current = (circuit.nodes[0].voltage - circuit.nodes[1].voltage) / circuit.edges[0].resistance;
    circuit.nodes[0].voltage -= current * circuit.edges[0].resistance;
    circuit.nodes[1].voltage += current * circuit.edges[0].resistance;

    printf(""Final circuit:\n"");
    print_circuit(&circuit);

    return 0;
}",115,2.333
VULNERABLE,gemini_pro-20707.c,yes,32,9,initialize_game,"
  file gemini_pro-20707.c line 32 column 9 function initialize_game
","
  c:@F@initialize_game at file gemini_pro-20707.c line 108 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"} Game;

void initialize_game(Game *game) {
    // Initialize the players
    for (int i = 0; i < 2; i++) {
        game->players[i].turn = i;
    }

    // Initialize the pieces
    for (int i = 0; i < 16; i++) {
        // Set the type of the piece","//GEMINI-pro DATASET v1.0 Category: Chess engine ; Style: multiplayer
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BOARD_SIZE 8

typedef struct {
    int x;
    int y;
} Position;

typedef struct {
    char type;
    char color;
    Position position;
} Piece;

typedef struct {
    Piece pieces[16];
    int turn;
} Player;

typedef struct {
    Player players[2];
    Piece board[BOARD_SIZE][BOARD_SIZE];
} Game;

void initialize_game(Game *game) {
    // Initialize the players
    for (int i = 0; i < 2; i++) {
        game->players[i].turn = i;
    }

    // Initialize the pieces
    for (int i = 0; i < 16; i++) {
        // Set the type of the piece
        if (i < 8) {
            game->players[0].pieces[i].type = 'p';
        } else {
            game->players[1].pieces[i].type = 'P';
        }

        // Set the color of the piece
        if (i < 8) {
            game->players[0].pieces[i].color = 'w';
        } else {
            game->players[1].pieces[i].color = 'b';
        }

        // Set the position of the piece
        if (i < 8) {
            game->players[0].pieces[i].position.x = 1;
            game->players[0].pieces[i].position.y = i;
        } else {
            game->players[1].pieces[i].position.x = 6;
            game->players[1].pieces[i].position.y = i;
        }
    }

    // Initialize the board
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            game->board[i][j].type = ' ';
            game->board[i][j].color = ' ';
            game->board[i][j].position.x = i;
            game->board[i][j].position.y = j;
        }
    }

    // Place the pieces on the board
    for (int i = 0; i < 16; i++) {
        game->board[game->players[0].pieces[i].position.x][game->players[0].pieces[i].position.y] = game->players[0].pieces[i];
        game->board[game->players[1].pieces[i].position.x][game->players[1].pieces[i].position.y] = game->players[1].pieces[i];
    }
}

void print_board(Game *game) {
    // Print the top border
    printf(""   +---+---+---+---+---+---+---+---+\n"");

    // Print the rows
    for (int i = 0; i < BOARD_SIZE; i++) {
        // Print the row number
        printf("" %d |"", i + 1);

        // Print the columns
        for (int j = 0; j < BOARD_SIZE; j++) {
            // Print the piece
            if (game->board[i][j].type == ' ') {
                printf(""   |"");
            } else {
                printf("" %c%c |"", game->board[i][j].type, game->board[i][j].color);
            }
        }

        // Print the bottom border
        printf(""\n   +---+---+---+---+---+---+---+---+\n"");
    }

    // Print the bottom border
    printf(""   +---+---+---+---+---+---+---+---+\n"");
}

int main() {
    // Initialize the game
    Game game;
    initialize_game(&game);

    // Print the board
    print_board(&game);

    // Get the move from the player
    char move[5];
    printf(""Enter your move: "");
    scanf(""%s"", move);

    // Parse the move
    Position from;
    Position to;
    from.x = move[0] - 'a';
    from.y = move[1] - '1';
    to.x = move[2] - 'a';
    to.y = move[3] - '1';

    // Make the move
    game.board[to.x][to.y] = game.board[from.x][from.y];
    game.board[from.x][from.y].type = ' ';
    game.board[from.x][from.y].color = ' ';

    // Print the board
    print_board(&game);

    return 0;
}",135,4.667
VULNERABLE,gemma7b-14423.c,yes,25,5,place_piece,"
  file gemma7b-14423.c line 25 column 5 function place_piece
","
  c:@F@place_piece at file gemma7b-14423.c line 60 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"void place_piece(Board *board, int x, int y, char piece) {
    if (board->board[x] != -1) {
        return;
    }
    board->board[x] = y;
    board->board[x + MAX_BOARD_SIZE] = piece;
}

char get_winner(Board *board) {
    // Check rows
    for (int r = 0; r < MAX_BOARD_SIZE; r++) {","//Gemma-7B DATASET v1.0 Category: Chess engine ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BOARD_SIZE 64

typedef struct Board {
    int board[MAX_BOARD_SIZE];
    int turn;
    char winner;
} Board;

void initialize_board(Board *board) {
    board->board[64] = -1;
    board->turn = 0;
    board->winner = '\0';
}

void place_piece(Board *board, int x, int y, char piece) {
    if (board->board[x] != -1) {
        return;
    }
    board->board[x] = y;
    board->board[x + MAX_BOARD_SIZE] = piece;
}

char get_winner(Board *board) {
    // Check rows
    for (int r = 0; r < MAX_BOARD_SIZE; r++) {
        if (board->board[r] == board->board[r + MAX_BOARD_SIZE] && board->board[r] != -1) {
            return board->board[r];
        }
    }

    // Check columns
    for (int c = 0; c < MAX_BOARD_SIZE; c++) {
        if (board->board[c] == board->board[c + MAX_BOARD_SIZE] && board->board[c] != -1) {
            return board->board[c];
        }
    }

    // Check diagonals
    for (int d = 0; d < MAX_BOARD_SIZE; d++) {
        if (board->board[d] == board->board[d + MAX_BOARD_SIZE] && board->board[d] != -1) {
            return board->board[d];
        }
    }

    // No winner
    return '\0';
}

int main() {
    Board board;
    initialize_board(&board);

    // Place pieces
    place_piece(&board, 0, 0, 'a');
    place_piece(&board, 1, 0, 'b');
    place_piece(&board, 2, 0, 'c');
    place_piece(&board, 3, 0, 'd');

    // Get winner
    char winner = get_winner(&board);

    // Print winner
    if (winner != '\0') {
        printf(""Winner: %c\n"", winner);
    } else {
        printf(""No winner\n"");
    }

    return 0;
}",75,3.75
VULNERABLE,gpt35-38507.c,yes,63,17,generate_map,"
  file gpt35-38507.c line 63 column 17 function generate_map
","
  c:@F@generate_map at file gpt35-38507.c line 116 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"        rooms[i].x = rand() % (MAP_WIDTH - rooms[i].w - 2) + 1;
        rooms[i].y = rand() % (MAP_HEIGHT - rooms[i].h - 2) + 1;

        for (j = rooms[i].x; j < rooms[i].x + rooms[i].w; j++) {
            for (k = rooms[i].y; k < rooms[i].y + rooms[i].h; k++) {
                state->map[j][k] = 1;
            }
        }
    }

    for (i = 0; i < MAX_ROOMS - 1; i++) {","//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAP_WIDTH 30
#define MAP_HEIGHT 20
#define MAX_ROOMS 6
#define MAX_MONSTERS 10

typedef struct {
    int x, y;
    char symbol;
} Entity;

typedef struct {
    int x, y, w, h;
} Room;

typedef struct {
    int map[MAP_WIDTH][MAP_HEIGHT];
    Entity player;
    Entity monsters[MAX_MONSTERS];
    int monster_count;
} GameState;

void draw_map(GameState *state) {
    int x, y;

    for (y = 0; y < MAP_HEIGHT; y++) {
        for (x = 0; x < MAP_WIDTH; x++) {
            printf(""%c"", state->map[x][y] ? '#' : ' ');
        }
        printf(""\n"");
    }
}

void place_entity(GameState *state, Entity *entity) {
    int x, y;

    do {
        x = rand() % MAP_WIDTH;
        y = rand() % MAP_HEIGHT;
    } while (state->map[x][y]);

    entity->x = x;
    entity->y = y;
    state->map[x][y] = entity->symbol;
}

void generate_map(GameState *state) {
    int i, j, k;
    Room rooms[MAX_ROOMS];

    for (i = 0; i < MAX_ROOMS; i++) {
        rooms[i].w = rand() % 6 + 5;
        rooms[i].h = rand() % 4 + 3;
        rooms[i].x = rand() % (MAP_WIDTH - rooms[i].w - 2) + 1;
        rooms[i].y = rand() % (MAP_HEIGHT - rooms[i].h - 2) + 1;

        for (j = rooms[i].x; j < rooms[i].x + rooms[i].w; j++) {
            for (k = rooms[i].y; k < rooms[i].y + rooms[i].h; k++) {
                state->map[j][k] = 1;
            }
        }
    }

    for (i = 0; i < MAX_ROOMS - 1; i++) {
        int x1 = rooms[i].x + rooms[i].w / 2;
        int y1 = rooms[i].y + rooms[i].h / 2;
        int x2 = rooms[i+1].x + rooms[i+1].w / 2;
        int y2 = rooms[i+1].y + rooms[i+1].h / 2;

        while (x1 != x2 || y1 != y2) {
            if (x1 < x2) x1++;
            else if (x1 > x2) x1--;
            else if (y1 < y2) y1++;
            else if (y1 > y2) y1--;

            state->map[x1][y1] = 1;
        }
    }

    state->monster_count = MAX_MONSTERS;
    for (i = 0; i < state->monster_count; i++) {
        state->monsters[i].symbol = 'm';
        place_entity(state, &state->monsters[i]);
    }

    state->player.symbol = '@';
    place_entity(state, &state->player);
}

void update(GameState *state) {
    int i;

    for (i = 0; i < state->monster_count; i++) {
        int dx = rand() % 3 - 1;
        int dy = rand() % 3 - 1;

        if (dx || dy) {
            if (!state->map[state->monsters[i].x+dx][state->monsters[i].y+dy]) {
                state->map[state->monsters[i].x][state->monsters[i].y] = 0;
                state->monsters[i].x += dx;
                state->monsters[i].y += dy;
                state->map[state->monsters[i].x][state->monsters[i].y] = state->monsters[i].symbol;
            }
        }
    }
}

int main() {
    GameState state;
    srand(time(NULL));

    generate_map(&state);
    draw_map(&state);

    while (1) {
        char input;

        printf(""Enter a command (w/a/s/d): "");
        scanf("" %c"", &input);

        if (input == 'w' && !state.map[state.player.x][state.player.y-1]) {
            state.map[state.player.x][state.player.y] = 0;
            state.player.y--;
            state.map[state.player.x][state.player.y] = state.player.symbol;
        }
        else if (input == 's' && !state.map[state.player.x][state.player.y+1]) {
            state.map[state.player.x][state.player.y] = 0;
            state.player.y++;
            state.map[state.player.x][state.player.y] = state.player.symbol;
        }
        else if (input == 'a' && !state.map[state.player.x-1][state.player.y]) {
            state.map[state.player.x][state.player.y] = 0;
            state.player.x--;
            state.map[state.player.x][state.player.y] = state.player.symbol;
        }
        else if (input == 'd' && !state.map[state.player.x+1][state.player.y]) {
            state.map[state.player.x][state.player.y] = 0;
            state.player.x++;
            state.map[state.player.x][state.player.y] = state.player.symbol;
        }

        update(&state);
        draw_map(&state);
    }

    return 0;
}",151,6.6
VULNERABLE,gemma7b-5691.c,yes,21,9,clusterKnights,"
  file gemma7b-5691.c line 21 column 9 function clusterKnights
","
  c:@F@clusterKnights at file gemma7b-5691.c line 48 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    return dx + dy;
}

void clusterKnights(Knight **knights, int numKnights) {
    for (int i = 0; i < numKnights; i++) {
        Knight *knight = knights[i];
        int minDistance = MAX_DISTANCE;
        int minKnightIndex = -1;
        for (int j = 0; j < numKnights; j++) {
            if (i != j) {
                Knight *otherKnight = knights[j];","//Gemma-7B DATASET v1.0 Category: Clustering Algorithm Implementation ; Style: medieval
#include <stdio.h>
#include <stdlib.h>

#define MAX_DISTANCE 10

typedef struct Knight {
    int x;
    int y;
    int loyalty;
} Knight;

int distance(Knight *a, Knight *b) {
    int dx = abs(a->x - b->x);
    int dy = abs(a->y - b->y);
    return dx + dy;
}

void clusterKnights(Knight **knights, int numKnights) {
    for (int i = 0; i < numKnights; i++) {
        Knight *knight = knights[i];
        int minDistance = MAX_DISTANCE;
        int minKnightIndex = -1;
        for (int j = 0; j < numKnights; j++) {
            if (i != j) {
                Knight *otherKnight = knights[j];
                int currentDistance = distance(knight, otherKnight);
                if (currentDistance < minDistance) {
                    minDistance = currentDistance;
                    minKnightIndex = j;
                }
            }
        }
        knight->loyalty = minKnightIndex;
    }
}

int main() {
    Knight knights[] = {
        {1, 2, 0},
        {3, 2, 0},
        {2, 4, 0},
        {4, 4, 0},
        {3, 4, 0}
    };
    int numKnights = 5;

    clusterKnights(knights, numKnights);

    for (int i = 0; i < numKnights; i++) {
        printf(""Knight %d's loyalty is %d\n"", i, knights[i].loyalty);
    }

    return 0;
}",55,2.667
VULNERABLE,falcon180b-14057.c,yes,67,9,simulateCircuit,"
  file falcon180b-14057.c line 67 column 9 function simulateCircuit
","
  c:@F@simulateCircuit at file falcon180b-14057.c line 53 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
//Simulate Circuit Function
void simulateCircuit(CircuitProperties *circuit, double dt) {
    int i, j;
    for (i = 0; i < circuit->numNodes; i++) {
        circuit->nodes[i].voltage += dt * circuit->nodes[i].current;
    }
}

//Print Circuit Function
void printCircuit(CircuitProperties *circuit) {","//Falcon-180B DATASET v1.0 Category: Classical Circuit Simulator ; Style: futuristic
//C Classical Circuit Simulator in a Futuristic Style

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>

#define MAX_COMPONENTS 100
#define MAX_NODES 1000
#define PI 3.14159265358979323846

//Define Component Types
typedef enum {
    RESISTOR = 1,
    CAPACITOR,
    INDUCTOR,
    VOLTAGE_SOURCE,
    CURRENT_SOURCE
} ComponentType;

//Define Component Properties
typedef struct {
    ComponentType type;
    double value;
} ComponentProperties;

//Define Node Properties
typedef struct {
    double voltage;
    double current;
} NodeProperties;

//Define Circuit Properties
typedef struct {
    int numComponents;
    int numNodes;
    ComponentProperties components[MAX_COMPONENTS];
    NodeProperties nodes[MAX_NODES];
} CircuitProperties;

//Define Functions
void buildCircuit(CircuitProperties *circuit);
void simulateCircuit(CircuitProperties *circuit, double dt);
void printCircuit(CircuitProperties *circuit);

//Main Function
int main() {
    srand(time(NULL));
    CircuitProperties circuit;
    buildCircuit(&circuit);
    simulateCircuit(&circuit, 0.01);
    printCircuit(&circuit);
    return 0;
}

//Build Circuit Function
void buildCircuit(CircuitProperties *circuit) {
    //Add components and nodes here
}

//Simulate Circuit Function
void simulateCircuit(CircuitProperties *circuit, double dt) {
    int i, j;
    for (i = 0; i < circuit->numNodes; i++) {
        circuit->nodes[i].voltage += dt * circuit->nodes[i].current;
    }
}

//Print Circuit Function
void printCircuit(CircuitProperties *circuit) {
    int i, j;
    printf(""Circuit:\n"");
    for (i = 0; i < circuit->numComponents; i++) {
        printf(""Component %d: "", i + 1);
        switch (circuit->components[i].type) {
            case RESISTOR:
                printf(""Resistor\n"");
                break;
            case CAPACITOR:
                printf(""Capacitor\n"");
                break;
            case INDUCTOR:
                printf(""Inductor\n"");
                break;
            case VOLTAGE_SOURCE:
                printf(""Voltage Source\n"");
                break;
            case CURRENT_SOURCE:
                printf(""Current Source\n"");
                break;
            default:
                printf(""Unknown Component\n"");
        }
    }
    printf(""Nodes:\n"");
    for (i = 0; i < circuit->numNodes; i++) {
        printf(""Node %d: Voltage = %.4f V, Current = %.4f A\n"", i + 1, circuit->nodes[i].voltage, circuit->nodes[i].current);
    }
}",101,3.0
VULNERABLE,gpt35-6971.c,yes,43,13,init_board,"
  file gpt35-6971.c line 43 column 13 function init_board
","
  c:@F@init_board at file gpt35-6971.c line 179 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"// Function to initialize the chess board
void init_board(ChessBoard* board) {
    // Set up each square with an empty piece
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            board->squares[x][y].x = x;
            board->squares[x][y].y = y;
            board->squares[x][y].piece.type = EMPTY;
            board->squares[x][y].piece.symbol = ' ';
        }
    }","//FormAI DATASET v1.0 Category: Chess AI ; Style: retro
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BOARD_SIZE 8

// Chess Piece Types
typedef enum PieceType {
    EMPTY,
    PAWN,
    KNIGHT,
    BISHOP,
    ROOK,
    QUEEN,
    KING
} PieceType;

// Chess Pieces
typedef struct ChessPiece {
    char symbol;
    PieceType type;
} ChessPiece;

// Chess Board Square
typedef struct ChessSquare {
    int x, y;
    ChessPiece piece;
} ChessSquare;

// Chess Board
typedef struct ChessBoard {
    ChessSquare squares[BOARD_SIZE][BOARD_SIZE];
    ChessPiece white_pieces[16];
    ChessPiece black_pieces[16];
} ChessBoard;

// Function to initialize the chess board
void init_board(ChessBoard* board) {
    // Set up each square with an empty piece
    for (int x = 0; x < BOARD_SIZE; x++) {
        for (int y = 0; y < BOARD_SIZE; y++) {
            board->squares[x][y].x = x;
            board->squares[x][y].y = y;
            board->squares[x][y].piece.type = EMPTY;
            board->squares[x][y].piece.symbol = ' ';
        }
    }

    // Set up the starting position for each piece
    for (int i = 0; i < 8; i++) {
        board->squares[i][1].piece.type = PAWN;
        board->squares[i][1].piece.symbol = 'P';
        board->white_pieces[i].type = PAWN;
        board->white_pieces[i].symbol = 'P';
    }

    board->squares[0][0].piece.type = ROOK;
    board->squares[0][0].piece.symbol = 'R';
    board->white_pieces[8].type = ROOK;
    board->white_pieces[8].symbol = 'R';

    board->squares[1][0].piece.type = KNIGHT;
    board->squares[1][0].piece.symbol = 'N';
    board->white_pieces[9].type = KNIGHT;
    board->white_pieces[9].symbol = 'N';

    board->squares[2][0].piece.type = BISHOP;
    board->squares[2][0].piece.symbol = 'B';
    board->white_pieces[10].type = BISHOP;
    board->white_pieces[10].symbol = 'B';

    board->squares[3][0].piece.type = QUEEN;
    board->squares[3][0].piece.symbol = 'Q';
    board->white_pieces[11].type = QUEEN;
    board->white_pieces[11].symbol = 'Q';

    board->squares[4][0].piece.type = KING;
    board->squares[4][0].piece.symbol = 'K';
    board->white_pieces[12].type = KING;
    board->white_pieces[12].symbol = 'K';

    board->squares[5][0].piece.type = BISHOP;
    board->squares[5][0].piece.symbol = 'B';
    board->white_pieces[13].type = BISHOP;
    board->white_pieces[13].symbol = 'B';

    board->squares[6][0].piece.type = KNIGHT;
    board->squares[6][0].piece.symbol = 'N';
    board->white_pieces[14].type = KNIGHT;
    board->white_pieces[14].symbol = 'N';

    board->squares[7][0].piece.type = ROOK;
    board->squares[7][0].piece.symbol = 'R';
    board->white_pieces[15].type = ROOK;
    board->white_pieces[15].symbol = 'R';

    for (int i = 0; i < 8; i++) {
        board->squares[i][6].piece.type = PAWN;
        board->squares[i][6].piece.symbol = 'p';
        board->black_pieces[i].type = PAWN;
        board->black_pieces[i].symbol = 'p';
    }

    board->squares[0][7].piece.type = ROOK;
    board->squares[0][7].piece.symbol = 'r';
    board->black_pieces[8].type = ROOK;
    board->black_pieces[8].symbol = 'r';

    board->squares[1][7].piece.type = KNIGHT;
    board->squares[1][7].piece.symbol = 'n';
    board->black_pieces[9].type = KNIGHT;
    board->black_pieces[9].symbol = 'n';

    board->squares[2][7].piece.type = BISHOP;
    board->squares[2][7].piece.symbol = 'b';
    board->black_pieces[10].type = BISHOP;
    board->black_pieces[10].symbol = 'b';

    board->squares[3][7].piece.type = QUEEN;
    board->squares[3][7].piece.symbol = 'q';
    board->black_pieces[11].type = QUEEN;
    board->black_pieces[11].symbol = 'q';

    board->squares[4][7].piece.type = KING;
    board->squares[4][7].piece.symbol = 'k';
    board->black_pieces[12].type = KING;
    board->black_pieces[12].symbol = 'k';

    board->squares[5][7].piece.type = BISHOP;
    board->squares[5][7].piece.symbol = 'b';
    board->black_pieces[13].type = BISHOP;
    board->black_pieces[13].symbol = 'b';

    board->squares[6][7].piece.type = KNIGHT;
    board->squares[6][7].piece.symbol = 'n';
    board->black_pieces[14].type = KNIGHT;
    board->black_pieces[14].symbol = 'n';

    board->squares[7][7].piece.type = ROOK;
    board->squares[7][7].piece.symbol = 'r';
    board->black_pieces[15].type = ROOK;
    board->black_pieces[15].symbol = 'r';
}

// Function to display the chess board
void display_board(ChessBoard* board) {
    printf(""\n   A  B  C  D  E  F  G  H\n"");
    printf(""  -------------------------\n"");

    for (int y = 7; y >= 0; y--) {
        printf(""%d |"", y + 1);
        for (int x = 0; x < 8; x++) {
            printf(""%c |"", board->squares[x][y].piece.symbol);
        }
        printf("" %d\n"", y + 1);
        printf(""  -------------------------\n"");
    }

    printf(""   A  B  C  D  E  F  G  H\n"");
}

// Function to get the user input of the move
void get_move_input(int* from_x, int* from_y, int* to_x, int* to_y) {
    printf(""Enter move (ex. 'e2 e4'): "");
    scanf(""%d %d %d %d"", from_x, from_y, to_x, to_y);
    printf(""\n"");
}

// Function to make a move on the chess board
void make_move(ChessBoard* board, int from_x, int from_y, int to_x, int to_y) {
    board->squares[to_x][to_y].piece = board->squares[from_x][from_y].piece;
    board->squares[from_x][from_y].piece.type = EMPTY;
    board->squares[from_x][from_y].piece.symbol = ' ';
}

int main() {
    ChessBoard board;
    init_board(&board);
    display_board(&board);

    int from_x, from_y, to_x, to_y;

    while (1) {
        get_move_input(&from_x, &from_y, &to_x, &to_y);
        if ((from_x < 1 || from_x > 8) || (to_x < 1 || to_x > 8) || (from_y < 1 || from_y > 8) || (to_y < 1 || to_y > 8)) {
            printf(""Invalid move!!!\n"");
            continue;
        }
        make_move(&board, from_x - 1, from_y - 1, to_x - 1, to_y - 1);
        display_board(&board);
    }
    return 0;
}",194,4.0
VULNERABLE,gemma7b-4471.c,yes,61,3,csvReader_getColumn,"
  file gemma7b-4471.c line 61 column 3 function csvReader_getColumn
","
  c:@F@csvReader_getColumn at file gemma7b-4471.c line 70 column 25 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"  if (reader->currentColumn >= reader->bufferSize - 1) {
    reader->bufferSize *= 2;
    reader->buffer = realloc(reader->buffer, reader->bufferSize * MAX_BUFFER_SIZE);
  }

  columnData = reader->buffer[reader->currentLine - 1] + column;

  return columnData;
}

int main() {","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
  FILE *fp;
  char **buffer;
  int bufferSize;
  int currentLine;
  int currentColumn;
} CSVReader;

CSVReader *csvReader_init(const char *filename) {
  CSVReader *reader = malloc(sizeof(CSVReader));
  reader->fp = fopen(filename, ""r"");
  reader->buffer = NULL;
  reader->bufferSize = 0;
  reader->currentLine = 0;
  reader->currentColumn = 0;

  return reader;
}

void csvReader_free(CSVReader *reader) {
  fclose(reader->fp);
  free(reader->buffer);
  free(reader);
}

int csvReader_readNextLine(CSVReader *reader) {
  char *line = NULL;
  int lineSize = 0;

  if (reader->currentLine >= reader->bufferSize - 1) {
    reader->bufferSize *= 2;
    reader->buffer = realloc(reader->buffer, reader->bufferSize * MAX_BUFFER_SIZE);
  }

  line = fgets(reader->buffer, MAX_BUFFER_SIZE, reader->fp);

  if (line) {
    reader->currentLine++;
    return 1;
  } else {
    return 0;
  }
}

char **csvReader_getColumn(CSVReader *reader, int column) {
  char **columnData = NULL;
  int columnDataIndex = 0;

  if (reader->currentColumn >= reader->bufferSize - 1) {
    reader->bufferSize *= 2;
    reader->buffer = realloc(reader->buffer, reader->bufferSize * MAX_BUFFER_SIZE);
  }

  columnData = reader->buffer[reader->currentLine - 1] + column;

  return columnData;
}

int main() {
  CSVReader *reader = csvReader_init(""example.csv"");

  if (csvReader_readNextLine(reader) > 0) {
    char **columnData = csvReader_getColumn(reader, 2);

    for (int i = 0; columnData[i] != NULL; i++) {
      printf(""%s\n"", columnData[i]);
    }
  }

  csvReader_free(reader);

  return 0;
}",80,2.0
VULNERABLE,falcon180b-33596.c,yes,18,9,error_context_init,"
  file falcon180b-33596.c line 18 column 9 function error_context_init
","
  c:@F@error_context_init at file falcon180b-33596.c line 56 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"} error_context_t;

void error_context_init(error_context_t *ctx) {
    ctx->error_count = 0;
    for (int i = 0; i < MAX_ERRORS; i++) {
        ctx->errors[i] = NULL;
    }
}

void error_context_destroy(error_context_t *ctx) {
    for (int i = 0; i < ctx->error_count; i++) {","//Falcon-180B DATASET v1.0 Category: Error handling ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <setjmp.h>

#define MAX_ERRORS 10

typedef struct {
    jmp_buf env;
    int error_count;
    char *errors[MAX_ERRORS];
} error_context_t;

void error_context_init(error_context_t *ctx) {
    ctx->error_count = 0;
    for (int i = 0; i < MAX_ERRORS; i++) {
        ctx->errors[i] = NULL;
    }
}

void error_context_destroy(error_context_t *ctx) {
    for (int i = 0; i < ctx->error_count; i++) {
        free(ctx->errors[i]);
    }
}

void error_context_add_error(error_context_t *ctx, const char *format,...) {
    if (ctx->error_count >= MAX_ERRORS) {
        return;
    }

    va_list args;
    va_start(args, format);
    ctx->errors[ctx->error_count] = malloc(1024);
    vsnprintf(ctx->errors[ctx->error_count], 1024, format, args);
    ctx->error_count++;
    va_end(args);
}

void error_context_print_errors(error_context_t *ctx) {
    for (int i = 0; i < ctx->error_count; i++) {
        printf(""%s\n"", ctx->errors[i]);
    }
}

void error_context_clear_errors(error_context_t *ctx) {
    for (int i = 0; i < ctx->error_count; i++) {
        free(ctx->errors[i]);
    }
    ctx->error_count = 0;
}

int main() {
    error_context_t ctx;
    error_context_init(&ctx);

    int result = setjmp(ctx.env);

    if (result == 0) {
        int a = 10;
        int b = 0;
        int c = a / b;
    } else {
        error_context_print_errors(&ctx);
        error_context_clear_errors(&ctx);
        printf(""Recovered from error\n"");
    }

    return 0;
}",71,2.0
VULNERABLE,codellama_13b-8362.c,yes,61,9,movePlates,"
  file codellama_13b-8362.c line 61 column 9 function movePlates
","
  c:@F@movePlates at file codellama_13b-8362.c line 70 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
// Function to move a list of plates from one pole to another
void movePlates(Plate *plates[], int numPlates, int fromPole, int toPole) {
    // Move each plate in the list
    for (int i = 0; i < numPlates; i++) {
        movePlate(plates[i], fromPole, toPole);
    }
}

int main() {
    // Define the plates","//Code Llama-13B DATASET v1.0 Category: Tower of Hanoi Problem ; Style: thoughtful
/*
 * Tower of Hanoi Problem
 *
 * Description:
 *  - Move a stack of plates from one pole to another using a third pole.
 *  - The rules are as follows:
 *    + Only one plate can be moved at a time.
 *    + No plate can be placed on top of a smaller plate.
 *
 * Input:
 *  - A list of plates in the order they need to be moved.
 *
 * Output:
 *  - The order in which the plates are moved.
 *
 * Author: [Your Name]
 */

#include <stdio.h>
#include <stdlib.h>

// Structure to represent a plate
typedef struct {
    int height;
} Plate;

// Function to move a plate from one pole to another
void movePlate(Plate *plate, int fromPole, int toPole) {
    // Check if the plate is already on the destination pole
    if (plate->height == toPole) {
        return;
    }

    // Check if the plate is already on the same pole
    if (plate->height == fromPole) {
        plate->height = toPole;
        return;
    }

    // Check if the plate is smaller than the current plate on the destination pole
    if (plate->height < toPole) {
        // Move the plate to the destination pole
        plate->height = toPole;

        // Move the current plate on the destination pole to the temporary pole
        movePlate(plate, toPole, 3);

        // Move the plate to the destination pole
        plate->height = toPole;

        // Move the current plate on the temporary pole to the destination pole
        movePlate(plate, 3, toPole);
    }
}

// Function to move a list of plates from one pole to another
void movePlates(Plate *plates[], int numPlates, int fromPole, int toPole) {
    // Move each plate in the list
    for (int i = 0; i < numPlates; i++) {
        movePlate(plates[i], fromPole, toPole);
    }
}

int main() {
    // Define the plates
    Plate plates[3] = {{1}, {2}, {3}};

    // Move the plates from pole 1 to pole 2
    movePlates(plates, 3, 1, 2);

    // Move the plates from pole 2 to pole 3
    movePlates(plates, 3, 2, 3);

    // Move the plates from pole 3 to pole 1
    movePlates(plates, 3, 3, 1);

    // Print the order in which the plates are moved
    printf(""Plates moved: "");
    for (int i = 0; i < 3; i++) {
        printf(""%d "", plates[i].height);
    }
    printf(""\n"");

    return 0;
}",86,2.667
VULNERABLE,gemma7b-26983.c,yes,43,19,csvReader_getColumnValue,"
  file gemma7b-26983.c line 43 column 19 function csvReader_getColumnValue
","
  c:@F@csvReader_getColumnValue at file gemma7b-26983.c line 61 column 19 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    strcpy(reader->buffer[reader->currentLineNo - 1], line);
    reader->currentColNo = 0;
}

char *csvReader_getColumnValue(CSVReader *reader, int colNo) {
    char *value = strchr(reader->buffer[reader->currentLineNo - 1], ',') + 1;

    reader->currentColNo++;

    return value;
}","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
    FILE *fp;
    char **buffer;
    int bufferSize;
    int currentLineNo;
    int currentColNo;
} CSVReader;

CSVReader *csvReader_init(char *fileName) {
    CSVReader *reader = malloc(sizeof(CSVReader));
    reader->fp = fopen(fileName, ""r"");
    reader->buffer = NULL;
    reader->bufferSize = 0;
    reader->currentLineNo = 0;
    reader->currentColNo = 0;

    return reader;
}

void csvReader_readCSV(CSVReader *reader) {
    char line[MAX_BUFFER_SIZE];
    reader->currentLineNo++;

    if (fgets(line, MAX_BUFFER_SIZE, reader->fp) == NULL) {
        return;
    }

    reader->bufferSize++;
    reader->buffer = realloc(reader->buffer, reader->bufferSize * MAX_BUFFER_SIZE);

    strcpy(reader->buffer[reader->currentLineNo - 1], line);
    reader->currentColNo = 0;
}

char *csvReader_getColumnValue(CSVReader *reader, int colNo) {
    char *value = strchr(reader->buffer[reader->currentLineNo - 1], ',') + 1;

    reader->currentColNo++;

    return value;
}

void csvReader_free(CSVReader *reader) {
    fclose(reader->fp);
    free(reader->buffer);
    free(reader);
}

int main() {
    CSVReader *reader = csvReader_init(""data.csv"");

    csvReader_readCSV(reader);

    char *value = csvReader_getColumnValue(reader, 2);

    printf(""%s"", value);

    csvReader_free(reader);

    return 0;
}",68,1.2
VULNERABLE,gpt35-61822.c,yes,39,9,initializeRooms,"
  file gpt35-61822.c line 39 column 9 function initializeRooms
","
  c:@F@initializeRooms at file gpt35-61822.c line 140 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    for(i = 0; i < MAX_ROOMS; i++) {
        hotel->rooms[i].room_number = i + 1;
        hotel->rooms[i].capacity = (i % 4) + 1;
        hotel->rooms[i].price = (i % 4) * 50 + 100;
        hotel->rooms[i].is_available = 1;
        hotel->rooms[i].customer = NULL;
    }
    hotel->num_rooms = MAX_ROOMS;
}

int findCustomer(struct Hotel *hotel, char *name) {","//FormAI DATASET v1.0 Category: Hotel Management System ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ROOMS 100
#define MAX_CUSTOMERS 200

struct Customer {
    char name[50];
    int age;
    char address[100];
    char phone_number[20];
    int room_number;
};

struct Room {
    int room_number;
    int capacity;
    int price;
    int is_available;
    struct Customer *customer;
};

struct Hotel {
    struct Room rooms[MAX_ROOMS];
    struct Customer customers[MAX_CUSTOMERS];
    int num_rooms;
    int num_customers;
};

void initializeRooms(struct Hotel *hotel) {
    int i;
    for(i = 0; i < MAX_ROOMS; i++) {
        hotel->rooms[i].room_number = i + 1;
        hotel->rooms[i].capacity = (i % 4) + 1;
        hotel->rooms[i].price = (i % 4) * 50 + 100;
        hotel->rooms[i].is_available = 1;
        hotel->rooms[i].customer = NULL;
    }
    hotel->num_rooms = MAX_ROOMS;
}

int findCustomer(struct Hotel *hotel, char *name) {
    int i;
    for(i = 0; i < hotel->num_customers; i++) {
        if(strcmp(hotel->customers[i].name, name) == 0) {
            return i;
        }
    }
    return -1;
}

struct Customer* addCustomer(struct Hotel *hotel) {
    struct Customer customer;
    printf(""Enter customer's name: "");
    scanf(""%s"", customer.name);
    printf(""Enter customer's age: "");
    scanf(""%d"", &customer.age);
    printf(""Enter customer's address: "");
    scanf(""%s"", customer.address);
    printf(""Enter customer's phone number: "");
    scanf(""%s"", customer.phone_number);
    printf(""Enter customer's room number: "");
    scanf(""%d"", &customer.room_number);
    if(customer.room_number < 1 || customer.room_number > hotel->num_rooms) {
        printf(""Invalid room number!\n"");
        return NULL;
    }
    if(hotel->rooms[customer.room_number-1].is_available == 0) {
        printf(""Room is not available!\n"");
        return NULL;
    }
    hotel->rooms[customer.room_number-1].is_available = 0;
    struct Customer *new_customer = &hotel->customers[hotel->num_customers];
    strcpy(new_customer->name, customer.name);
    new_customer->age = customer.age;
    strcpy(new_customer->address, customer.address);
    strcpy(new_customer->phone_number, customer.phone_number);
    new_customer->room_number = customer.room_number;
    hotel->rooms[customer.room_number-1].customer = new_customer;
    hotel->num_customers++;
    printf(""Customer added successfully.\n"");
    return new_customer;
}

void printCustomer(struct Customer *customer) {
    printf(""Name: %s\n"", customer->name);
    printf(""Age: %d\n"", customer->age);
    printf(""Address: %s\n"", customer->address);
    printf(""Phone Number: %s\n"", customer->phone_number);
    printf(""Room Number: %d\n"", customer->room_number);
}

void searchCustomer(struct Hotel *hotel) {
    char search_name[50];
    printf(""Enter name to search: "");
    scanf(""%s"", search_name);
    int i = findCustomer(hotel, search_name);
    if(i == -1) {
        printf(""Customer not found!\n"");
        return;
    }
    printCustomer(&hotel->customers[i]);
}

void printRooms(struct Hotel *hotel) {
    int i;
    printf(""Room\tCapacity\tPrice\tStatus\n"");
    for(i = 0; i < hotel->num_rooms; i++) {
        printf(""%d\t%d\t\t%d\t"", hotel->rooms[i].room_number, hotel->rooms[i].capacity, hotel->rooms[i].price);
        if(hotel->rooms[i].is_available == 1) {
            printf(""Available\n"");
        } else {
            printf(""Occupied by %s\n"", hotel->rooms[i].customer->name);
        }
    }
}

void checkout(struct Hotel *hotel) {
    int room_number;
    printf(""Enter room number: "");
    scanf(""%d"", &room_number);
    if(room_number < 1 || room_number > hotel->num_rooms) {
        printf(""Invalid room number!\n"");
        return;
    }
    if(hotel->rooms[room_number-1].is_available == 1) {
        printf(""Room is not occupied!\n"");
        return;
    }
    struct Customer *customer = hotel->rooms[room_number-1].customer;
    hotel->rooms[room_number-1].is_available = 1;
    hotel->rooms[room_number-1].customer = NULL;
    printf(""Customer %s has checked out of room %d.\n"", customer->name, room_number);
}

int main() {
    struct Hotel hotel;
    initializeRooms(&hotel);
    while(1) {
        printf(""\nAvailable options:\n1. Add customer\n2. Search customer\n3. Print available rooms\n4. Checkout\n5. Exit\n"");
        int option;
        printf(""Enter option: "");
        scanf(""%d"", &option);
        switch(option) {
            case 1:
                addCustomer(&hotel);
                break;
            case 2:
                searchCustomer(&hotel);
                break;
            case 3:
                printRooms(&hotel);
                break;
            case 4:
                checkout(&hotel);
                break;
            case 5:
                printf(""Thank you for using the hotel management system.\n"");
                exit(0);
                break;
            default:
                printf(""Invalid option!\n"");
        }
    }
    return 0;
}",168,3.25
VULNERABLE,gpt35-40226.c,yes,35,13,toggle_device,"
  file gpt35-40226.c line 35 column 13 function toggle_device
","
  c:@F@toggle_device at file gpt35-40226.c line 85 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    }
}

void toggle_device(struct house* h, char* room_name, char* device_name) {
    for (int i = 0; i < h->n_rooms; i++) {
        if (strcmp(h->rooms[i].name, room_name) == 0) {
            for (int j = 0; j < h->rooms[i].n_devices; j++) {
                if (strcmp(h->rooms[i].devices[j].name, device_name) == 0) {
                    h->rooms[i].devices[j].state = !h->rooms[i].devices[j].state;
                    return;
                }","//FormAI DATASET v1.0 Category: Smart home automation ; Style: dynamic
#include <stdio.h>
#include <string.h>

#define MAX_ROOMS 5
#define MAX_DEVICES 10

struct device {
    char* name;
    int state;
};

struct room {
    char* name;
    struct device devices[MAX_DEVICES];
    int n_devices;
};

struct house {
    struct room rooms[MAX_ROOMS];
    int n_rooms;
};

void print_house(struct house h) {
    for (int i = 0; i < h.n_rooms; i++) {
        printf(""%s:\n"", h.rooms[i].name);
        for (int j = 0; j < h.rooms[i].n_devices; j++) {
            printf(""\t%s: %s\n"", h.rooms[i].devices[j].name, h.rooms[i].devices[j].state ? ""ON"" : ""OFF"");
        }
    }
}

void toggle_device(struct house* h, char* room_name, char* device_name) {
    for (int i = 0; i < h->n_rooms; i++) {
        if (strcmp(h->rooms[i].name, room_name) == 0) {
            for (int j = 0; j < h->rooms[i].n_devices; j++) {
                if (strcmp(h->rooms[i].devices[j].name, device_name) == 0) {
                    h->rooms[i].devices[j].state = !h->rooms[i].devices[j].state;
                    return;
                }
            }
        }
    }
}

int main() {
    struct house my_house = {
        .rooms = {
            {
                .name = ""Living Room"",
                .devices = {
                    {
                        .name = ""TV"",
                        .state = 0
                    },
                    {
                        .name = ""Lamp"",
                        .state = 0
                    }
                },
                .n_devices = 2
            },
            {
                .name = ""Bedroom"",
                .devices = {
                    {
                        .name = ""Bed Lamp"",
                        .state = 0
                    },
                    {
                        .name = ""Alarm"",
                        .state = 0
                    }
                },
                .n_devices = 2
            }
        }, 
        .n_rooms = 2
    };

    printf(""Initial state of the house:\n"");
    print_house(my_house);

    printf(""\nToggling TV in Living Room...\n"");
    toggle_device(&my_house, ""Living Room"", ""TV"");
    print_house(my_house);

    printf(""\nToggling Alarm in Bedroom...\n"");
    toggle_device(&my_house, ""Bedroom"", ""Alarm"");
    print_house(my_house);

    return 0;
}",93,3.333
VULNERABLE,gemma7b-14237.c,yes,33,9,csv_reader_parse,"
  file gemma7b-14237.c line 33 column 9 function csv_reader_parse
","
  c:@F@csv_reader_parse at file gemma7b-14237.c line 48 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    while (fgets(line, 1024, reader->file) != NULL) {
        reader->rows++;
        token = strtok(line, "","");
        reader->cols = (token ? atoi(token) : 0) + 1;
        reader->data = realloc(reader->data, reader->rows * sizeof(char*));
        reader->data[reader->rows - 1] = malloc(reader->cols * sizeof(char));
        strcpy(reader->data[reader->rows - 1], line);
        i = 0;
        token = strtok(line, "","");
        while (token) {
            reader->data[reader->rows - 1][i++] = token;","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct CSV_Reader {
    FILE* file;
    char** data;
    int rows;
    int cols;
} CSV_Reader;

CSV_Reader* csv_reader_init(char* filename) {
    CSV_Reader* reader = (CSV_Reader*)malloc(sizeof(CSV_Reader));
    reader->file = fopen(filename, ""r"");
    reader->data = NULL;
    reader->rows = 0;
    reader->cols = 0;

    return reader;
}

void csv_reader_parse(CSV_Reader* reader) {
    char line[1024];
    char* token;
    int i = 0;

    while (fgets(line, 1024, reader->file) != NULL) {
        reader->rows++;
        token = strtok(line, "","");
        reader->cols = (token ? atoi(token) : 0) + 1;
        reader->data = realloc(reader->data, reader->rows * sizeof(char*));
        reader->data[reader->rows - 1] = malloc(reader->cols * sizeof(char));
        strcpy(reader->data[reader->rows - 1], line);
        i = 0;
        token = strtok(line, "","");
        while (token) {
            reader->data[reader->rows - 1][i++] = token;
            token = strtok(NULL, "","");
        }
    }

    fclose(reader->file);
}

int main() {
    CSV_Reader* reader = csv_reader_init(""data.csv"");
    csv_reader_parse(reader);

    printf(""Number of rows: %d\n"", reader->rows);
    printf(""Number of columns: %d\n"", reader->cols);

    for (int r = 0; r < reader->rows; r++) {
        for (int c = 0; c < reader->cols; c++) {
            printf(""%s "", reader->data[r][c]);
        }
        printf(""\n"");
    }

    free(reader->data);
    free(reader);

    return 0;
}",64,2.667
VULNERABLE,gpt35-25058.c,yes,84,9,print_circuit,"
  file gpt35-25058.c line 84 column 9 function print_circuit
","
  c:@F@print_circuit at file gpt35-25058.c line 72 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
void print_circuit(circuit* circ){
    printf(""Circuit Nodes:\n"");
    printf(""ID\tVoltage\tCurrent\n"");
    for(int i=0; i<circ->num_nodes; i++){
        printf(""%d\t%.2f\t%.2f\n"", circ->nodes[i].node_id,
        circ->nodes[i].voltage, circ->nodes[i].current);
    }

    printf(""Circuit Sources:\n"");
    printf(""ID\tVoltage\tResistance\n"");","//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: complete
#include <stdio.h>
#include <stdlib.h>

//Define Constants
#define MAX_NODES 100
#define MAX_SOURCES 20
#define MAX_PROBES 20

//Define Structs
typedef struct circuit_node{
    int node_id;
    double voltage;
    double current;
} circuit_node;

typedef struct circuit_source{
    int source_id;
    double voltage;
    double resistance;
} circuit_source;

typedef struct circuit_probe{
    int probe_id;
    circuit_node* node;
} circuit_probe;

typedef struct circuit{
    int num_nodes;
    int num_sources;
    int num_probes;
    circuit_node nodes[MAX_NODES];
    circuit_source sources[MAX_SOURCES];
    circuit_probe probes[MAX_PROBES];
} circuit;

//Function Declarations
void print_circuit(circuit* circ);
void simulate_circuit(circuit* circ);

int main(){
    //Create Circuit
    circuit my_circuit;
    my_circuit.num_nodes = 4;
    my_circuit.num_sources = 1;
    my_circuit.num_probes = 2;

    //Set Node IDs
    my_circuit.nodes[0].node_id = 0;
    my_circuit.nodes[1].node_id = 1;
    my_circuit.nodes[2].node_id = 2;
    my_circuit.nodes[3].node_id = 3;

    //Set Source ID
    my_circuit.sources[0].source_id = 0;

    //Connect Sources to Nodes
    my_circuit.nodes[0].current = 0.0;
    my_circuit.nodes[1].current = 0.0;
    my_circuit.sources[0].voltage = 5.0;
    my_circuit.sources[0].resistance = 2.0;
    my_circuit.nodes[0].voltage = my_circuit.sources[0].voltage;
    my_circuit.nodes[1].voltage = 0.0;

    //Set Probes
    my_circuit.probes[0].probe_id = 0;
    my_circuit.probes[0].node = &my_circuit.nodes[0];
    my_circuit.probes[1].probe_id = 1;
    my_circuit.probes[1].node = &my_circuit.nodes[1];

    //Print Circuit
    print_circuit(&my_circuit);

    //Simulate Circuit
    simulate_circuit(&my_circuit);

    return 0;
}

void print_circuit(circuit* circ){
    printf(""Circuit Nodes:\n"");
    printf(""ID\tVoltage\tCurrent\n"");
    for(int i=0; i<circ->num_nodes; i++){
        printf(""%d\t%.2f\t%.2f\n"", circ->nodes[i].node_id,
        circ->nodes[i].voltage, circ->nodes[i].current);
    }

    printf(""Circuit Sources:\n"");
    printf(""ID\tVoltage\tResistance\n"");
    for(int i=0; i<circ->num_sources; i++){
        printf(""%d\t%.2f\t%.2f\n"", circ->sources[i].source_id,
        circ->sources[i].voltage, circ->sources[i].resistance);
    }

    printf(""Circuit Probes:\n"");
    printf(""ID\tConnected to Node ID\tVoltage\n"");
    for(int i=0; i<circ->num_probes; i++){
        printf(""%d\t%d\t%.2f\n"", circ->probes[i].probe_id, 
        circ->probes[i].node->node_id, circ->probes[i].node->voltage);
    }
}

void simulate_circuit(circuit* circ){
    //Initialize Circuit
    for(int i=0; i<circ->num_nodes; i++){
        circ->nodes[i].voltage = 0.0;
        circ->nodes[i].current = 0.0;
    }

    //Calculate Current
    double current = circ->sources[0].voltage / circ->sources[0].resistance;
    circ->nodes[0].current = -current;
    circ->nodes[1].current = current;

    //Calculate Node Voltages
    double resistance = circ->sources[0].resistance;
    double voltage_drop = current * resistance;
    circ->nodes[0].voltage = circ->sources[0].voltage;
    circ->nodes[1].voltage = circ->sources[0].voltage - voltage_drop;

    //Print Final Values
    print_circuit(circ);
}",123,2.333
VULNERABLE,gpt35-59361.c,yes,43,9,initialize_rooms,"
  file gpt35-59361.c line 43 column 9 function initialize_rooms
","
  c:@F@initialize_rooms at file gpt35-59361.c line 70 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"        {""gem"", 25},
        {""book"", 5}
    };

    for (int i = 0; i < NUM_ROOMS; i++) {
        rooms[i].name = ""Room"";
        rooms[i].num_items = rand() % MAX_ITEMS;
        for (int j = 0; j < rooms[i].num_items; j++) {
            int index = rand() % 6;
            rooms[i].items[j] = items[index];
        }","//FormAI DATASET v1.0 Category: Game ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define NUM_ROOMS 20 // number of rooms on the map
#define MAX_ITEMS 5 // maximum number of items per room
#define MAX_PLAYERS 10 // maximum number of players in the game

// item struct to represent items on map
typedef struct Item {
    char* name; // name of item
    int value; // value of item
} Item;

// room struct to represent rooms on map
typedef struct Room {
    char* name; // name of room
    Item items[MAX_ITEMS]; // array of items in room
    int num_items; // number of items currently in room
} Room;

// player struct to represent each player in the game
typedef struct Player {
    char* name; // name of player
    int score; // score of player
    Room* current_room; // current room the player is in
} Player;

// initialize all rooms on map with random items
void initialize_rooms(Room* rooms) {
    Item items[] = {
        {""sword"", 20},
        {""potion"", 10},
        {""shield"", 15},
        {""key"", 5},
        {""gem"", 25},
        {""book"", 5}
    };

    for (int i = 0; i < NUM_ROOMS; i++) {
        rooms[i].name = ""Room"";
        rooms[i].num_items = rand() % MAX_ITEMS;
        for (int j = 0; j < rooms[i].num_items; j++) {
            int index = rand() % 6;
            rooms[i].items[j] = items[index];
        }
    }
}

// print out all items in a room
void print_items(Room room) {
    printf(""Items in %s:\n"", room.name);
    for (int i = 0; i < room.num_items; i++) {
        printf(""- %s (%d points)\n"", room.items[i].name, room.items[i].value);
    }
}

// move player to a new room
void move_player(Player* player, Room* new_room) {
    printf(""%s moved from %s to %s\n"", player->name, player->current_room->name, new_room->name);
    player->current_room = new_room;
}

int main() {
    srand(time(NULL)); // seed random number generator

    Room rooms[NUM_ROOMS];
    initialize_rooms(rooms);

    // create array of players
    Player players[MAX_PLAYERS];
    int num_players = 0;

    // ask for player names until user enters ""done""
    char name[20];
    while (true) {
        printf(""Enter player name (or \""done\"" to finish): "");
        scanf(""%s"", name);
        if (strcmp(name, ""done"") == 0) {
            break;
        }
        Player player;
        player.name = name;
        player.score = 0;
        player.current_room = &rooms[0];
        players[num_players++] = player;
    }

    // game loop
    bool game_over = false;
    while (!game_over) {
        // print out map and all items in current room
        printf(""\nMap:\n"");
        for (int i = 0; i < NUM_ROOMS; i++) {
            printf(""%s%d: "", rooms[i].name, i);
            for (int j = 0; j < rooms[i].num_items; j++) {
                printf(""%s "", rooms[i].items[j].name);
            }
            printf(""\n"");
        }
        printf(""\n"");

        // print out all player stats
        printf(""Players:\n"");
        for (int i = 0; i < num_players; i++) {
            printf(""%s: score %d, in %s\n"", players[i].name, players[i].score, players[i].current_room->name);
        }

        // ask player which direction they want to move in
        char direction[10];
        printf(""\nWhich direction do you want to move in? (north, south, east, or west): "");
        scanf(""%s"", direction);

        // if player enters ""quit"", end game
        if (strcmp(direction, ""quit"") == 0) {
            game_over = true;
            printf(""Thanks for playing!\n"");
            break;
        }

        // randomly select a room in the direction entered by the player
        Room* new_room = NULL;
        int current_room_index = players[0].current_room - rooms;
        if (strcmp(direction, ""north"") == 0) {
            if (current_room_index >= 5) {
                new_room = &rooms[current_room_index - 5];
            }
        } else if (strcmp(direction, ""south"") == 0) {
            if (current_room_index <= 14) {
                new_room = &rooms[current_room_index + 5];
            }
        } else if (strcmp(direction, ""east"") == 0) {
            if (current_room_index % 5 != 4) {
                new_room = &rooms[current_room_index + 1];
            }
        } else if (strcmp(direction, ""west"") == 0) {
            if (current_room_index % 5 != 0) {
                new_room = &rooms[current_room_index - 1];
            }
        }

        if (new_room == NULL) {
            printf(""Invalid direction entered!\n"");
        } else {
            // update all players current rooms, print out items in new room
            for (int i = 0; i < num_players; i++) {
                move_player(&players[i], new_room);
            }
            print_items(*new_room);

            // ask each player if they want to pick up any items in the room
            for (int i = 0; i < num_players; i++) {
                printf(""%s, do you want to pick up any items? (enter item name or \""none\""): "", players[i].name);
                char item_name[20];
                scanf(""%s"", item_name);
                if (strcmp(item_name, ""none"") != 0) {
                    for (int j = 0; j < new_room->num_items; j++) {
                        if (strcmp(item_name, new_room->items[j].name) == 0) {
                            players[i].score += new_room->items[j].value;
                            printf(""%s picked up %s (+%d points)!\n"", players[i].name, new_room->items[j].name, new_room->items[j].value);
                            // remove item from room
                            for (int k = j; k < new_room->num_items-1; k++) {
                                new_room->items[k] = new_room->items[k+1];
                            }
                            new_room->num_items--;
                            break;
                        }
                    }
                }
            }
        }
    }

    return 0;
}",177,7.25
VULNERABLE,gpt35-59184.c,yes,55,9,print_graph,"
  file gpt35-59184.c line 55 column 9 function print_graph
","
  c:@F@print_graph at file gpt35-59184.c line 84 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"}

void print_graph(struct graph* g) {
    printf(""Nodes:\n"");
    for (int i = 0; i < g->num_nodes; i++) {
        printf(""%d: %s\n"", g->nodes[i].id, g->nodes[i].name);
    }

    printf(""Edges:\n"");
    for (int i = 0; i < g->num_edges; i++) {
        printf(""%d -> %d (%d)\n"", g->edges[i].from, g->edges[i].to, g->edges[i].weight);","//FormAI DATASET v1.0 Category: Network Topology Mapper ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODES 100 // Maximum number of nodes in the network
#define MAX_EDGES 500 // Maximum number of edges in the network

struct node {
    char* name; // Node name
    int id; // Node ID
};

struct edge {
    int from; // ID of the node the edge is coming from
    int to; // ID of the node the edge is going to
    int weight; // Weight of the edge
};

struct graph {
    struct node nodes[MAX_NODES];
    struct edge edges[MAX_EDGES];
    int num_nodes;
    int num_edges;
};

void add_node(struct graph* g, char* name) {
    if (g->num_nodes < MAX_NODES) {
        struct node n;
        n.name = strdup(name);
        n.id = g->num_nodes;
        g->nodes[g->num_nodes++] = n;
    }
    else {
        printf(""Error: Maximum number of nodes reached.\n"");
    }
}

void add_edge(struct graph* g, int from, int to, int weight) {
    if (g->num_edges < MAX_EDGES) {
        struct edge e;
        e.from = from;
        e.to = to;
        e.weight = weight;
        g->edges[g->num_edges++] = e;
    }
    else {
        printf(""Error: Maximum number of edges reached.\n"");
    }
}

void print_graph(struct graph* g) {
    printf(""Nodes:\n"");
    for (int i = 0; i < g->num_nodes; i++) {
        printf(""%d: %s\n"", g->nodes[i].id, g->nodes[i].name);
    }

    printf(""Edges:\n"");
    for (int i = 0; i < g->num_edges; i++) {
        printf(""%d -> %d (%d)\n"", g->edges[i].from, g->edges[i].to, g->edges[i].weight);
    }
}

int main() {
    // Sample graph
    struct graph g;
    g.num_nodes = 0;
    g.num_edges = 0;

    // Add nodes
    add_node(&g, ""Server1"");
    add_node(&g, ""Server2"");
    add_node(&g, ""Switch1"");
    add_node(&g, ""Switch2"");
    add_node(&g, ""Router"");

    // Add edges
    add_edge(&g, 0, 2, 10); // Server1 -> Switch1
    add_edge(&g, 1, 2, 15); // Server2 -> Switch1
    add_edge(&g, 2, 3, 5);  // Switch1 -> Switch2
    add_edge(&g, 3, 4, 20); // Switch2 -> Router

    // Print the graph
    print_graph(&g);

    return 0;
}",87,2.0
VULNERABLE,gemini_pro-17786.c,yes,63,9,init_simulation,"
  file gemini_pro-17786.c line 63 column 9 function init_simulation
","
  c:@F@init_simulation at file gemini_pro-17786.c line 218 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"void init_simulation(traffic_flow_simulation_t *sim) {
    // Initialize the road segments
    for (int i = 0; i < 4; i++) {
        sim->road_segments[i].length = ROAD_LENGTH;
        sim->road_segments[i].num_cars = 0;
        sim->road_segments[i].cars = NULL;
    }

    // Initialize the traffic lights
    for (int i = 0; i < 4; i++) {
        sim->traffic_lights[i].state = RED;","//GEMINI-pro DATASET v1.0 Category: Traffic Flow Simulation ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define the traffic light states
#define RED 0
#define YELLOW 1
#define GREEN 2

// Define the road segments
#define NORTHBOUND 0
#define EASTBOUND 1
#define SOUTHBOUND 2
#define WESTBOUND 3

// Define the car types
#define CAR 0
#define TRUCK 1
#define BUS 2

// Define the road lengths
#define ROAD_LENGTH 100

// Define the traffic light durations
#define RED_DURATION 10
#define YELLOW_DURATION 5
#define GREEN_DURATION 15

// Create a struct to represent a car
typedef struct car {
    int type; // The type of car (car, truck, bus)
    int speed; // The speed of the car
    int position; // The position of the car on the road
} car_t;

// Create a struct to represent a road segment
typedef struct road_segment {
    int length; // The length of the road segment
    int num_cars; // The number of cars on the road segment
    car_t *cars; // An array of cars on the road segment
} road_segment_t;

// Create a struct to represent a traffic light
typedef struct traffic_light {
    int state; // The state of the traffic light (red, yellow, green)
    int duration; // The duration of the traffic light state
} traffic_light_t;

// Create a struct to represent the traffic flow simulation
typedef struct traffic_flow_simulation {
    road_segment_t road_segments[4]; // An array of road segments
    traffic_light_t traffic_lights[4]; // An array of traffic lights
    int num_cars; // The number of cars in the simulation
} traffic_flow_simulation_t;

// Create a function to initialize the traffic flow simulation
void init_simulation(traffic_flow_simulation_t *sim) {
    // Initialize the road segments
    for (int i = 0; i < 4; i++) {
        sim->road_segments[i].length = ROAD_LENGTH;
        sim->road_segments[i].num_cars = 0;
        sim->road_segments[i].cars = NULL;
    }

    // Initialize the traffic lights
    for (int i = 0; i < 4; i++) {
        sim->traffic_lights[i].state = RED;
        sim->traffic_lights[i].duration = RED_DURATION;
    }

    // Initialize the cars
    sim->num_cars = 0;
}

// Create a function to update the traffic flow simulation
void update_simulation(traffic_flow_simulation_t *sim) {
    // Update the traffic lights
    for (int i = 0; i < 4; i++) {
        // Decrement the duration of the traffic light state
        sim->traffic_lights[i].duration--;

        // If the duration of the traffic light state has reached 0, change the state of the traffic light
        if (sim->traffic_lights[i].duration == 0) {
            switch (sim->traffic_lights[i].state) {
                case RED:
                    sim->traffic_lights[i].state = GREEN;
                    sim->traffic_lights[i].duration = GREEN_DURATION;
                    break;
                case GREEN:
                    sim->traffic_lights[i].state = YELLOW;
                    sim->traffic_lights[i].duration = YELLOW_DURATION;
                    break;
                case YELLOW:
                    sim->traffic_lights[i].state = RED;
                    sim->traffic_lights[i].duration = RED_DURATION;
                    break;
            }
        }
    }

    // Update the cars
    for (int i = 0; i < 4; i++) {
        // Loop through the cars on the road segment
        for (int j = 0; j < sim->road_segments[i].num_cars; j++) {
            // Get the car
            car_t *car = &sim->road_segments[i].cars[j];

            // If the car is at the end of the road segment, remove the car from the road segment
            if (car->position >= sim->road_segments[i].length) {
                sim->road_segments[i].num_cars--;
                for (int k = j; k < sim->road_segments[i].num_cars; k++) {
                    sim->road_segments[i].cars[k] = sim->road_segments[i].cars[k + 1];
                }
                j--;
                continue;
            }

            // If the car is stopped by a red traffic light, do not update the car's position
            if (sim->traffic_lights[i].state == RED && car->position < sim->traffic_lights[i].duration) {
                continue;
            }

            // Update the car's position
            car->position += car->speed;
        }
    }
}

// Create a function to draw the traffic flow simulation
void draw_simulation(traffic_flow_simulation_t *sim) {
    // Clear the screen
    printf(""\033[2J"");

    // Draw the road segments
    for (int i = 0; i < 4; i++) {
        // Draw the road segment
        for (int j = 0; j < sim->road_segments[i].length; j++) {
            // If there is a car on the road segment, draw the car
            if (sim->road_segments[i].num_cars > 0) {
                for (int k = 0; k < sim->road_segments[i].num_cars; k++) {
                    // Get the car
                    car_t *car = &sim->road_segments[i].cars[k];

                    // If the car is at the current position, draw the car
                    if (car->position == j) {
                        switch (car->type) {
                            case CAR:
                                printf(""C"");
                                break;
                            case TRUCK:
                                printf(""T"");
                                break;
                            case BUS:
                                printf(""B"");
                                break;
                        }
                    }
                }
            } else {
                printf("" "");
            }
        }

        // Draw the traffic light
        switch (sim->traffic_lights[i].state) {
            case RED:
                printf(""R"");
                break;
            case YELLOW:
                printf(""Y"");
                break;
            case GREEN:
                printf(""G"");
                break;
        }

        // Draw a newline character
        printf(""\n"");
    }
}

// Create a function to run the traffic flow simulation
void run_simulation(traffic_flow_simulation_t *sim) {
    // Initialize the random number generator
    srand(time(NULL));

    // Create a car
    car_t car;
    car.type = rand() % 3;
    car.speed = rand() % 5 + 1;
    car.position = 0;

    // Add the car to the road segment
    sim->road_segments[NORTHBOUND].cars = realloc(sim->road_segments[NORTHBOUND].cars, (sim->road_segments[NORTHBOUND].num_cars + 1) * sizeof(car_t));
    sim->road_segments[NORTHBOUND].cars[sim->road_segments[NORTHBOUND].num_cars] = car;
    sim->road_segments[NORTHBOUND].num_cars++;

    // Run the simulation loop
    while (1) {
        // Update the simulation
        update_simulation(sim);

        // Draw the simulation
        draw_simulation(sim);

        // Sleep for 100 milliseconds
        usleep(100000);
    }
}

// Main function
int main() {
    // Create a traffic flow simulation
    traffic_flow_simulation_t sim;

    // Initialize the traffic flow simulation
    init_simulation(&sim);

    // Run the traffic flow simulation
    run_simulation(&sim);

    return 0;
}",224,6.0
VULNERABLE,gemma7b-16958.c,yes,29,9,insertAtTail,"
  file gemma7b-16958.c line 29 column 9 function insertAtTail
","
  c:@F@insertAtTail at file gemma7b-16958.c line 52 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    {
        list->head = newNode;
    }
    else
    {
        list->head[list->size] = newNode;
        list->size++;
    }
}

void traverse(struct DecentralizedList* list)","//Gemma-7B DATASET v1.0 Category: Data structures visualization ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>

#define MAX 10

struct Node {
    int data;
    struct Node* next;
};

struct DecentralizedList {
    struct Node** head;
    int size;
};

void insertAtTail(struct DecentralizedList* list, int data)
{
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;

    if (list->head == NULL)
    {
        list->head = newNode;
    }
    else
    {
        list->head[list->size] = newNode;
        list->size++;
    }
}

void traverse(struct DecentralizedList* list)
{
    struct Node* current = list->head[0];
    while (current)
    {
        printf(""%d "", current->data);
        current = current->next;
    }
    printf(""\n"");
}

int main()
{
    struct DecentralizedList* list = (struct DecentralizedList*)malloc(sizeof(struct DecentralizedList));
    list->head = NULL;
    list->size = 0;

    insertAtTail(list, 10);
    insertAtTail(list, 20);
    insertAtTail(list, 30);
    insertAtTail(list, 40);

    traverse(list);

    return 0;
}",59,1.667
VULNERABLE,gpt35-25307.c,yes,35,5,add_edge,"
  file gpt35-25307.c line 35 column 5 function add_edge
","
  c:@F@add_edge at file gpt35-25307.c line 100 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    }
}

/* Add an edge between two vertices */
void add_edge(vertex vertices[], int u, int v) {
    vertices[u].adj_vertices[vertices[u].num_adj_vertices++] = v;
    vertices[v].adj_vertices[vertices[v].num_adj_vertices++] = u;
}

/* Check if assigning a given color to a vertex is valid */
int is_valid_color(vertex v, vertex_color color) {","//FormAI DATASET v1.0 Category: Graph Coloring Problem ; Style: calm
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 100

/* Each vertex is represented by a color */
typedef enum {
    RED,
    GREEN,
    BLUE,
    YELLOW
} vertex_color;

/* Each vertex in the graph has a unique name */
typedef struct {
    char name;
    vertex_color color;
    int num_adj_vertices; /* number of adjacent vertices */
    int adj_vertices[MAX_VERTICES]; /* indices of adjacent vertices */
} vertex;

/* Initialize the vertices in the input graph */
void init_vertices(vertex vertices[], int num_vertices) {
    for (int i = 0; i < num_vertices; i++) {
        printf(""Enter the name of vertex %d: "", i+1);
        scanf("" %c"", &vertices[i].name);
        vertices[i].color = RED; /* set default color to red */
        vertices[i].num_adj_vertices = 0; /* initialize adjacents to 0 */
    }
}

/* Add an edge between two vertices */
void add_edge(vertex vertices[], int u, int v) {
    vertices[u].adj_vertices[vertices[u].num_adj_vertices++] = v;
    vertices[v].adj_vertices[vertices[v].num_adj_vertices++] = u;
}

/* Check if assigning a given color to a vertex is valid */
int is_valid_color(vertex v, vertex_color color) {
    for (int i = 0; i < v.num_adj_vertices; i++) {
        if (v.adj_vertices[i] != -1 && v.color == color) {
            return 0; /* color already used by adjacent vertex */
        }
    }
    return 1;
}

/* Assign colors to each vertex in the graph */
void color_graph(vertex vertices[], int num_vertices) {
    int i, j;
    for (i = 0; i < num_vertices; i++) {
        for (j = 0; j < 4; j++) {
            if (is_valid_color(vertices[i], j)) {
                /* assign color and move on to next vertex */
                vertices[i].color = j;
                break;
            }
        }
        if (j == 4) { /* couldn't find a valid color */
            printf(""Error: no color available for vertex %c\n"", vertices[i].name);
            exit(1);
        }
    }
}

/* Print the colors of each vertex */
void print_colors(vertex vertices[], int num_vertices) {
    printf(""The colors assigned to each vertex are:\n"");
    for (int i = 0; i < num_vertices; i++) {
        printf(""%c: "", vertices[i].name);
        switch (vertices[i].color) {
            case RED:
                printf(""red\n"");
                break;
            case GREEN:
                printf(""green\n"");
                break;
            case BLUE:
                printf(""blue\n"");
                break;
            case YELLOW:
                printf(""yellow\n"");
                break;
        }
    }
}

int main() {
    int num_vertices, num_edges, u, v;
    printf(""Enter the number of vertices: "");
    scanf(""%d"", &num_vertices);
    vertex vertices[num_vertices];
    init_vertices(vertices, num_vertices);
    printf(""Enter the number of edges: "");
    scanf(""%d"", &num_edges);
    for (int i = 0; i < num_edges; i++) {
        printf(""Enter the indices of edge %d: "", i+1);
        scanf(""%d %d"", &u, &v);
        add_edge(vertices, u, v);
    }
    color_graph(vertices, num_vertices);
    print_colors(vertices, num_vertices);
    
    return 0;
}",106,3.333
VULNERABLE,gpt35-24384.c,yes,44,9,print_graph,"
  file gpt35-24384.c line 44 column 9 function print_graph
","
  c:@F@print_graph at file gpt35-24384.c line 73 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"}

void print_graph(struct graph *g) {
    printf(""Nodes:\n"");
    for (int i = 0; i < g->num_nodes; i++) {
        printf(""%d: %s\n"", g->nodes[i].id, g->nodes[i].name);
    }
    printf(""Edges:\n"");
    for (int i = 0; i < g->num_edges; i++) {
        printf(""%d -> %d (%d)\n"", g->edges[i].from, g->edges[i].to, g->edges[i].weight);
    }","//FormAI DATASET v1.0 Category: Network Topology Mapper ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODES 100
#define MAX_EDGES 1000

struct node {
    int id;
    char *name;
};

struct edge {
    int from, to;
    int weight;
};

struct graph {
    int num_nodes;
    struct node nodes[MAX_NODES];
    int num_edges;
    struct edge edges[MAX_EDGES];
};

void add_node(struct graph *g, int id, char *name) {
    struct node n;
    n.id = id;
    n.name = strdup(name);
    g->nodes[g->num_nodes++] = n;
}

void add_edge(struct graph *g, int from, int to, int weight) {
    struct edge e;
    e.from = from;
    e.to = to;
    e.weight = weight;
    g->edges[g->num_edges++] = e;
}

void print_graph(struct graph *g) {
    printf(""Nodes:\n"");
    for (int i = 0; i < g->num_nodes; i++) {
        printf(""%d: %s\n"", g->nodes[i].id, g->nodes[i].name);
    }
    printf(""Edges:\n"");
    for (int i = 0; i < g->num_edges; i++) {
        printf(""%d -> %d (%d)\n"", g->edges[i].from, g->edges[i].to, g->edges[i].weight);
    }
}

int main() {
    struct graph g;
    g.num_nodes = 0;
    g.num_edges = 0;

    add_node(&g, 1, ""Router1"");
    add_node(&g, 2, ""Switch1"");
    add_node(&g, 3, ""Router2"");
    add_node(&g, 4, ""Switch2"");
    add_node(&g, 5, ""Router3"");
    add_node(&g, 6, ""Server1"");
    add_node(&g, 7, ""Server2"");

    add_edge(&g, 1, 2, 1);
    add_edge(&g, 2, 3, 2);
    add_edge(&g, 2, 4, 4);
    add_edge(&g, 3, 5, 1);
    add_edge(&g, 4, 5, 3);
    add_edge(&g, 4, 6, 2);
    add_edge(&g, 4, 7, 1);

    print_graph(&g);

    return 0;
}",76,1.5
VULNERABLE,codellama_13b-4829.c,yes,68,9,initGameState,"
  file codellama_13b-4829.c line 68 column 9 function initGameState
","
  c:@F@initGameState at file codellama_13b-4829.c line 148 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    state->level = 1;

    // Initialize the ships
    for (int i = 0; i < MAX_SHIPS; i++) {
        state->ships[i].x = WIDTH / 2;
        state->ships[i].y = HEIGHT - 1;
        state->ships[i].symbol = 'O';
    }

    // Initialize the bullets
    for (int i = 0; i < MAX_BULLETS; i++) {","//Code Llama-13B DATASET v1.0 Category: Space Invaders Game Clone ; Style: complex
/*
 * Space Invaders Game Clone Example Program
 *
 * This program is a simple example of a Space Invaders game clone written in C.
 * It is not a complete or optimized implementation, but it shows the basic
 * structure and functionality of the game.
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define the game constants
#define WIDTH 80
#define HEIGHT 25
#define MAX_SHIPS 10
#define MAX_BULLETS 10
#define MAX_INVADERS 100
#define MAX_POWERUPS 10

// Define the game structs
typedef struct {
    int x;
    int y;
    char symbol;
} Ship;

typedef struct {
    int x;
    int y;
    char symbol;
} Bullet;

typedef struct {
    int x;
    int y;
    char symbol;
} Invader;

typedef struct {
    int x;
    int y;
    char symbol;
} Powerup;

// Define the game state
typedef struct {
    Ship ships[MAX_SHIPS];
    Bullet bullets[MAX_BULLETS];
    Invader invaders[MAX_INVADERS];
    Powerup powerups[MAX_POWERUPS];
    int score;
    int lives;
    int level;
} GameState;

// Define the game functions
void initGameState(GameState *state) {
    // Initialize the game state
    state->score = 0;
    state->lives = 3;
    state->level = 1;

    // Initialize the ships
    for (int i = 0; i < MAX_SHIPS; i++) {
        state->ships[i].x = WIDTH / 2;
        state->ships[i].y = HEIGHT - 1;
        state->ships[i].symbol = 'O';
    }

    // Initialize the bullets
    for (int i = 0; i < MAX_BULLETS; i++) {
        state->bullets[i].x = 0;
        state->bullets[i].y = 0;
        state->bullets[i].symbol = '*';
    }

    // Initialize the invaders
    for (int i = 0; i < MAX_INVADERS; i++) {
        state->invaders[i].x = i % 10;
        state->invaders[i].y = i / 10;
        state->invaders[i].symbol = 'I';
    }

    // Initialize the powerups
    for (int i = 0; i < MAX_POWERUPS; i++) {
        state->powerups[i].x = i % 10;
        state->powerups[i].y = i / 10;
        state->powerups[i].symbol = '+';
    }
}

void updateGameState(GameState *state) {
    // Update the ships
    for (int i = 0; i < MAX_SHIPS; i++) {
        state->ships[i].x += 1;
    }

    // Update the bullets
    for (int i = 0; i < MAX_BULLETS; i++) {
        state->bullets[i].x += 1;
    }

    // Update the invaders
    for (int i = 0; i < MAX_INVADERS; i++) {
        state->invaders[i].x += 1;
    }

    // Update the powerups
    for (int i = 0; i < MAX_POWERUPS; i++) {
        state->powerups[i].x += 1;
    }
}

void drawGameState(GameState *state) {
    // Draw the ships
    for (int i = 0; i < MAX_SHIPS; i++) {
        printf(""%c "", state->ships[i].symbol);
    }
    printf(""\n"");

    // Draw the bullets
    for (int i = 0; i < MAX_BULLETS; i++) {
        printf(""%c "", state->bullets[i].symbol);
    }
    printf(""\n"");

    // Draw the invaders
    for (int i = 0; i < MAX_INVADERS; i++) {
        printf(""%c "", state->invaders[i].symbol);
    }
    printf(""\n"");

    // Draw the powerups
    for (int i = 0; i < MAX_POWERUPS; i++) {
        printf(""%c "", state->powerups[i].symbol);
    }
    printf(""\n"");

    // Draw the score and lives
    printf(""Score: %d Lives: %d\n"", state->score, state->lives);
}

int main() {
    // Initialize the game state
    GameState state;
    initGameState(&state);

    // Update the game state
    updateGameState(&state);

    // Draw the game state
    drawGameState(&state);

    return 0;
}",157,4.0
VULNERABLE,gemini_pro-11823.c,yes,44,9,shuffle_deck,"
  file gemini_pro-11823.c line 44 column 9 function shuffle_deck
","
  c:@F@shuffle_deck at file gemini_pro-11823.c line 73 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    printf(""\n"");
}

void shuffle_deck(Game *game) {
    for (int i = 0; i < MAX_CARDS; i++) {
        game->deck[i].value = i % 13 + 2;
        game->deck[i].suit = 'C' + i / 13;
    }

    for (int i = 0; i < MAX_CARDS; i++) {
        int j = rand() % MAX_CARDS;","//GEMINI-pro DATASET v1.0 Category: Table Game ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PLAYERS 4
#define MAX_CARDS 52
#define MAX_HAND_SIZE 13

typedef struct {
    int value;
    char suit;
} Card;

typedef struct {
    Card cards[MAX_HAND_SIZE];
    int num_cards;
} Hand;

typedef struct {
    Hand hands[MAX_PLAYERS];
    int num_players;
    int current_player;
    Card deck[MAX_CARDS];
    int num_cards_in_deck;
} Game;

void print_card(Card card) {
    char *suits[] = {""C"", ""D"", ""H"", ""S""};
    char *values[] = {""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10"", ""J"", ""Q"", ""K"", ""A""};
    printf(""%s%s"", values[card.value - 2], suits[card.suit - 'C']);
}

void print_hand(Hand hand) {
    for (int i = 0; i < hand.num_cards; i++) {
        print_card(hand.cards[i]);
        printf("" "");
    }
    printf(""\n"");
}

void shuffle_deck(Game *game) {
    for (int i = 0; i < MAX_CARDS; i++) {
        game->deck[i].value = i % 13 + 2;
        game->deck[i].suit = 'C' + i / 13;
    }

    for (int i = 0; i < MAX_CARDS; i++) {
        int j = rand() % MAX_CARDS;
        Card temp = game->deck[i];
        game->deck[i] = game->deck[j];
        game->deck[j] = temp;
    }

    game->num_cards_in_deck = MAX_CARDS;
}

void deal_cards(Game *game) {
    for (int i = 0; i < game->num_players; i++) {
        for (int j = 0; j < MAX_HAND_SIZE; j++) {
            game->hands[i].cards[j] = game->deck[game->num_cards_in_deck - 1];
            game->num_cards_in_deck--;
            game->hands[i].num_cards++;
        }
    }
}

int main() {
    Game game;
    game.num_players = 2;
    game.current_player = 0;

    shuffle_deck(&game);
    deal_cards(&game);

    print_hand(game.hands[0]);
    print_hand(game.hands[1]);

    return 0;
}",80,2.0
VULNERABLE,gpt35-4002.c,yes,39,13,init_map,"
  file gpt35-4002.c line 39 column 13 function init_map
","
  c:@F@init_map at file gpt35-4002.c line 111 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
void init_map(map_t* map) {
    // initialize cells
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            map->cells[i][j].visited = false;
            map->cells[i][j].occupied = false;
        }
    }

    // place player in center","//FormAI DATASET v1.0 Category: Rogue-like Game with Procedural Generation ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define WIDTH 40
#define HEIGHT 20

void wait_for_enter() {
    while (getchar() != '\n');
}

typedef struct {
    int x;
    int y;
} position_t;

typedef struct {
    position_t pos;
    char chr;
} entity_t;

typedef struct {
    bool visited;
    bool occupied;
} cell_t;

typedef struct {
    cell_t cells[HEIGHT][WIDTH];
    entity_t player;
    entity_t enemies[5];
} map_t;

void init_map(map_t* map) {
    // initialize cells
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            map->cells[i][j].visited = false;
            map->cells[i][j].occupied = false;
        }
    }
    
    // place player in center
    map->player.pos.x = WIDTH/2;
    map->player.pos.y = HEIGHT/2;
    map->player.chr = '@';
    map->cells[map->player.pos.y][map->player.pos.x].occupied = true;
    
    // place enemies
    srand(time(NULL));
    for (int i = 0; i < 5; i++) {
        int x = rand() % WIDTH;
        int y = rand() % HEIGHT;
        // check if occupied, if so, try again
        while (map->cells[y][x].occupied) {
            x = rand() % WIDTH;
            y = rand() % HEIGHT;
        }
        map->enemies[i].pos.x = x;
        map->enemies[i].pos.y = y;
        map->enemies[i].chr = 'E';
        map->cells[y][x].occupied = true;
    }
}

void print_map(map_t map) {
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            if (map.cells[i][j].occupied) {
                bool print_entity = false;
                char entity_chr = ' ';
                if (i == map.player.pos.y && j == map.player.pos.x) {
                    print_entity = true;
                    entity_chr = map.player.chr;
                } else {
                    for (int k = 0; k < 5; k++) {
                        if (i == map.enemies[k].pos.y && j == map.enemies[k].pos.x) {
                            print_entity = true;
                            entity_chr = map.enemies[k].chr;
                            break;
                        }
                    }
                }
                if (print_entity) {
                    printf(""%c"", entity_chr);
                } else {
                    printf(""#"");
                }
            } else {
                printf(""."");
            }
        }
        printf(""\n"");
    }
}

void move_player(map_t* map, int dx, int dy) {
    int new_x = map->player.pos.x + dx;
    int new_y = map->player.pos.y + dy;
    if (new_x >= 0 && new_x < WIDTH && new_y >= 0 && new_y < HEIGHT && !map->cells[new_y][new_x].occupied) {
        map->cells[map->player.pos.y][map->player.pos.x].occupied = false;
        map->player.pos.x = new_x;
        map->player.pos.y = new_y;
        map->cells[map->player.pos.y][map->player.pos.x].occupied = true;
    }
}

int main() {
    map_t map;
    init_map(&map);
    print_map(map);
    
    char input;
    while (true) {
        input = getchar();
        switch (input) {
            case 'w':
                move_player(&map, 0, -1);
                break;
            case 'a':
                move_player(&map, -1, 0);
                break;
            case 's':
                move_player(&map, 0, 1);
                break;
            case 'd':
                move_player(&map, 1, 0);
                break;
            default:
                continue;
        }
        printf(""\033[H\033[J"");
        print_map(map);
    }
    
    return 0;
}",138,5.8
VULNERABLE,gemini_pro-14062.c,yes,97,5,start_server,"
  file gemini_pro-14062.c line 97 column 5 function start_server
","
  c:@F@start_server at file gemini_pro-14062.c line 45 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    }

    // Set up the server state
    ServerState state;
    state.num_clients = 0;
    FD_ZERO(&state.rfds);
    FD_SET(server_socket, &state.rfds);

    // Main server loop
    while (1) {
        // Wait for activity on any of the sockets","//GEMINI-pro DATASET v1.0 Category: Chat server ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_CLIENTS 10
#define MAX_MSG_SIZE 1024

// Server configuration options
typedef struct {
    int port;
    int backlog;
    int timeout;
} ServerConfig;

// Client information
typedef struct {
    int socket;
    struct sockaddr_in addr;
    char name[32];
} Client;

// Server state
typedef struct {
    int num_clients;
    Client clients[MAX_CLIENTS];
    fd_set rfds;
} ServerState;

// Function prototypes
ServerConfig load_config(const char *filename);
void start_server(ServerConfig config);
void handle_client(ServerState *state, int client_index);

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s <config_file>\n"", argv[0]);
        return EXIT_FAILURE;
    }

    ServerConfig config = load_config(argv[1]);
    start_server(config);

    return EXIT_SUCCESS;
}

ServerConfig load_config(const char *filename) {
    ServerConfig config;

    FILE *fp = fopen(filename, ""r"");
    if (fp == NULL) {
        perror(""fopen"");
        exit(EXIT_FAILURE);
    }

    fscanf(fp, ""port %d\nbacklog %d\ntimeout %d"", &config.port, &config.backlog, &config.timeout);
    fclose(fp);

    return config;
}

void start_server(ServerConfig config) {
    int server_socket;
    struct sockaddr_in server_addr;

    // Create a server socket
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Set server address and port
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(config.port);

    // Bind the server socket to the address
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, config.backlog) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    // Set up the server state
    ServerState state;
    state.num_clients = 0;
    FD_ZERO(&state.rfds);
    FD_SET(server_socket, &state.rfds);

    // Main server loop
    while (1) {
        // Wait for activity on any of the sockets
        fd_set rfds_copy = state.rfds;
        struct timeval tv;
        tv.tv_sec = config.timeout;
        tv.tv_usec = 0;
        int activity = select(FD_SETSIZE, &rfds_copy, NULL, NULL, &tv);

        if (activity == -1) {
            perror(""select"");
            exit(EXIT_FAILURE);
        } else if (activity == 0) {
            // Timeout
            continue;
        }

        // Accept new connections
        if (FD_ISSET(server_socket, &rfds_copy)) {
            struct sockaddr_in client_addr;
            socklen_t client_addr_len = sizeof(client_addr);
            int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_len);
            if (client_socket == -1) {
                perror(""accept"");
                continue;
            }

            // Add the new client to the server state
            if (state.num_clients < MAX_CLIENTS) {
                Client client;
                client.socket = client_socket;
                client.addr = client_addr;
                strcpy(client.name, ""Anonymous"");
                state.clients[state.num_clients++] = client;
                FD_SET(client_socket, &state.rfds);
            } else {
                // Too many clients connected
                send(client_socket, ""Server is full\n"", 15, 0);
                close(client_socket);
            }
        }

        // Handle activity on existing clients
        for (int i = 0; i < state.num_clients; i++) {
            if (FD_ISSET(state.clients[i].socket, &rfds_copy)) {
                handle_client(&state, i);
            }
        }
    }
}

void handle_client(ServerState *state, int client_index) {
    Client *client = &state->clients[client_index];

    char buffer[MAX_MSG_SIZE];
    int bytes_received = recv(client->socket, buffer, MAX_MSG_SIZE - 1, 0);
    if (bytes_received == -1) {
        perror(""recv"");
        close(client->socket);
        FD_CLR(client->socket, &state->rfds);
        state->num_clients--;
        return;
    } else if (bytes_received == 0) {
        // Client closed the connection
        close(client->socket);
        FD_CLR(client->socket, &state->rfds);
        state->num_clients--;
        return;
    }

    buffer[bytes_received] = '\0';

    // Process the client's message
    if (strncmp(buffer, ""/name "", 6) == 0) {
        // Client is setting their name
        strcpy(client->name, buffer + 6);
        send(client->socket, ""Name set\n"", 9, 0);
    } else if (strncmp(buffer, ""/quit"", 5) == 0) {
        // Client is quitting
        send(client->socket, ""Goodbye\n"", 8, 0);
        close(client->socket);
        FD_CLR(client->socket, &state->rfds);
        state->num_clients--;
    } else {
        // Client is sending a message
        char message[MAX_MSG_SIZE];
        snprintf(message, MAX_MSG_SIZE, ""%s: %s"", client->name, buffer);
        for (int i = 0; i < state->num_clients; i++) {
            if (i != client_index) {
                send(state->clients[i].socket, message, strlen(message), 0);
            }
        }
    }
}",193,5.75
VULNERABLE,gemini_pro-9135.c,yes,32,9,calculate_checksum,"
  file gemini_pro-9135.c line 32 column 9 function calculate_checksum
","
  c:@F@calculate_checksum at file gemini_pro-9135.c line 57 column 23 function send_ping
  c:@F@send_ping at file gemini_pro-9135.c line 125 column 13 function ping
  c:@F@ping at file gemini_pro-9135.c line 168 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    unsigned int sum = 0;
    int i;

    // Calculate the sum of all the 16-bit words in the header
    for (i = 0; i < sizeof(struct icmp_header) / sizeof(unsigned short); i++) {
        sum += words[i];
    }

    // Add the carry-over from the previous sum
    while (sum >> 16) {
        sum = (sum >> 16) + (sum & 0xFFFF);","//GEMINI-pro DATASET v1.0 Category: Network Ping Test ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <time.h>

// Define the maximum number of hops for the ICMP packet
#define MAX_HOPS 30

// Define the ICMP header structure
struct icmp_header {
    unsigned char type; // Message type (8 for echo request)
    unsigned char code; // Error code (0 for echo request)
    unsigned short checksum; // Checksum of the header and data
    unsigned short identifier; // Identifier of the request
    unsigned short sequence_number; // Sequence number of the request
    char data[52]; // Data portion of the packet
};

// Calculate the checksum of the ICMP packet
unsigned short calculate_checksum(struct icmp_header *header) {
    unsigned short *words = (unsigned short *)header;
    unsigned int sum = 0;
    int i;

    // Calculate the sum of all the 16-bit words in the header
    for (i = 0; i < sizeof(struct icmp_header) / sizeof(unsigned short); i++) {
        sum += words[i];
    }

    // Add the carry-over from the previous sum
    while (sum >> 16) {
        sum = (sum >> 16) + (sum & 0xFFFF);
    }

    // Return the one's complement of the sum
    return ~sum;
}

// Send an ICMP echo request packet
int send_ping(int sockfd, struct sockaddr_in *addr, int ttl) {
    struct icmp_header header;

    // Set the ICMP header fields
    header.type = 8; // Echo request
    header.code = 0; // Error code
    header.checksum = 0; // Calculate the checksum later
    header.identifier = getpid(); // Process ID
    header.sequence_number = 0; // Sequence number
    memset(header.data, 0, sizeof(header.data)); // Clear the data portion

    // Calculate the checksum of the header
    header.checksum = calculate_checksum(&header);

    // Set the TTL of the packet
    setsockopt(sockfd, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl));

    // Send the ICMP packet
    if (sendto(sockfd, &header, sizeof(header), 0, (struct sockaddr *)addr, sizeof(*addr)) < 0) {
        perror(""sendto"");
        return -1;
    }

    return 0;
}

// Receive an ICMP echo reply packet
int receive_ping(int sockfd, struct sockaddr_in *addr, int *ttl) {
    struct icmp_header header;
    struct sockaddr_in from_addr;
    socklen_t from_len = sizeof(from_addr);

    // Receive the ICMP packet
    if (recvfrom(sockfd, &header, sizeof(header), 0, (struct sockaddr *)&from_addr, &from_len) < 0) {
        perror(""recvfrom"");
        return -1;
    }

    // Get the TTL of the packet
    getsockopt(sockfd, IPPROTO_IP, IP_TTL, ttl, &from_len);

    // Check if the ICMP packet is an echo reply
    if (header.type != 0) {
        return -1;
    }

    // Check if the ICMP packet is from the correct source address
    if (strcmp(inet_ntoa(addr->sin_addr), inet_ntoa(from_addr.sin_addr)) != 0) {
        return -1;
    }

    return 0;
}

// Perform a ping test
int ping(char *hostname, int ttl) {
    struct sockaddr_in addr;
    int sockfd, i, ttl_received;
    struct timeval start, end;
    long elapsed_time;

    // Create a raw socket for sending and receiving ICMP packets
    if ((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0) {
        perror(""socket"");
        return -1;
    }

    // Resolve the hostname to an IP address
    if (inet_aton(hostname, &addr.sin_addr) == 0) {
        perror(""inet_aton"");
        return -1;
    }

    // Set the IP address and port of the destination address
    addr.sin_family = AF_INET;
    addr.sin_port = 0;

    // Send ICMP echo request packets
    for (i = 0; i < 3; i++) {
        // Send the ICMP echo request packet
        if (send_ping(sockfd, &addr, ttl) < 0) {
            close(sockfd);
            return -1;
        }

        // Get the start time
        gettimeofday(&start, NULL);

        // Receive the ICMP echo reply packet
        if (receive_ping(sockfd, &addr, &ttl_received) < 0) {
            close(sockfd);
            return -1;
        }

        // Get the end time
        gettimeofday(&end, NULL);

        // Calculate the elapsed time
        elapsed_time = (end.tv_sec - start.tv_sec) * 1000 + (end.tv_usec - start.tv_usec) / 1000;

        // Print the ping statistics
        printf(""Ping: %s (%s) ttl=%d elapsed_time=%ld ms\n"", hostname, inet_ntoa(addr.sin_addr), ttl_received, elapsed_time);
    }

    // Close the socket
    close(sockfd);

    return 0;
}

int main(int argc, char *argv[]) {
    int ttl;

    // Check if the hostname and TTL are specified
    if (argc != 3) {
        fprintf(stderr, ""Usage: %s hostname ttl\n"", argv[0]);
        return 1;
    }

    // Get the TTL
    ttl = atoi(argv[2]);

    // Perform the ping test
    if (ping(argv[1], ttl) < 0) {
        return 1;
    }

    return 0;
}",173,3.6
VULNERABLE,gpt35-41833.c,yes,62,9,main,"
  file gpt35-41833.c line 62 column 9 function main
","
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
    // Compute the IP header checksum
    uint32_t sum = 0;
    uint16_t* s = (uint16_t*) &ip_header;
    for (int i = 0; i < sizeof(ip_header) / 2; i++) {
        sum += s[i];
    }
    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }
    ip_header.checksum = ~htons(sum);","//FormAI DATASET v1.0 Category: Network Topology Mapper ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_PACKET_SIZE 65536

struct ip_hdr {
    uint8_t version_ihl;
    uint8_t tos;
    uint16_t len;
    uint16_t id;
    uint16_t frag_off;
    uint8_t ttl;
    uint8_t protocol;
    uint16_t checksum;
    uint32_t src_addr;
    uint32_t dst_addr;
};

int main(int argc, char* argv[]) {
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s <IP address>\n"", argv[0]);
        return 1;
    }

    // Create a raw socket to interact with IP headers
    int sock_fd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sock_fd < 0) {
        perror(""socket()"");
        return 1;
    }

    // Set the IP_HDRINCL option to include the IP header
    int one = 1;
    if (setsockopt(sock_fd, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one)) < 0) {
        perror(""setsockopt()"");
        return 1;
    }

    // Create an IP header
    struct ip_hdr ip_header;
    memset(&ip_header, 0, sizeof(ip_header));
    ip_header.version_ihl = 0x45;
    ip_header.tos = 0;
    ip_header.len = htons(sizeof(ip_header));
    ip_header.id = htons(54321);
    ip_header.frag_off = htons(0);
    ip_header.ttl = 255;
    ip_header.protocol = IPPROTO_ICMP;
    ip_header.src_addr = inet_addr(""192.168.0.1"");
    ip_header.dst_addr = inet_addr(argv[1]);
    ip_header.checksum = 0;

    // Compute the IP header checksum
    uint32_t sum = 0;
    uint16_t* s = (uint16_t*) &ip_header;
    for (int i = 0; i < sizeof(ip_header) / 2; i++) {
        sum += s[i];
    }
    while (sum >> 16) {
        sum = (sum & 0xffff) + (sum >> 16);
    }
    ip_header.checksum = ~htons(sum);

    // Send the packet
    struct sockaddr_in sin;
    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = 0;
    sin.sin_addr.s_addr = ip_header.dst_addr;

    if (sendto(sock_fd, &ip_header, sizeof(ip_header), 0, (struct sockaddr*)&sin, sizeof(sin)) < 0) {
        perror(""sendto()"");
        return 1;
    }

    // Receive the packet
    uint8_t buffer[MAX_PACKET_SIZE];
    ssize_t n = recv(sock_fd, buffer, sizeof(buffer), 0);
    if (n < 0) {
        perror(""recv()"");
        return 1;
    }

    // Analyze the packet
    struct ip_hdr* received_ip_header = (struct ip_hdr*) buffer;
    printf(""ICMP reply from %s\n"", inet_ntoa(*(struct in_addr*)&received_ip_header->src_addr));

    return 0;
}",94,8.0
VULNERABLE,gpt35-48884.c,yes,33,13,initCircuit,"
  file gpt35-48884.c line 33 column 13 function initCircuit
","
  c:@F@initCircuit at file gpt35-48884.c line 109 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"        for(int j=0; j<2; j++) {
            circuit->nodes[i].nodes[j] = -1;
        }
        circuit->voltage[i] = 0.0;
        for(int j=0; j<MAX_NODES; j++) {
            circuit->matrix[i][j] = 0.0;
        }
    }
}

// Function to add a node to the circuit","//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: all-encompassing
#include<stdio.h>
#include<stdlib.h>

#define MAX_NODES 1000 // Maximum number of nodes in the circuit

// Structure to represent a node in the circuit
typedef struct {
    char type; // Node type: V for voltage source, R for resistor, C for capacitor
    float value; // Node value: voltage, resistance or capacitance depending on the type
    int nodes[2]; // The nodes connected to the component
} Node;

// Structure to represent the circuit
typedef struct {
    Node nodes[MAX_NODES]; // Array of all nodes in the circuit
    int numNodes; // The number of nodes in the circuit
    float voltage[MAX_NODES]; // Array to store voltage values for each node
    float matrix[MAX_NODES][MAX_NODES]; // The circuit matrix
} Circuit;

// Function to initialize the circuit
void initCircuit(Circuit *circuit) {
    circuit->numNodes = 0;
    for(int i=0; i<MAX_NODES; i++) {
        circuit->nodes[i].type = '\0';
        circuit->nodes[i].value = 0.0;
        for(int j=0; j<2; j++) {
            circuit->nodes[i].nodes[j] = -1;
        }
        circuit->voltage[i] = 0.0;
        for(int j=0; j<MAX_NODES; j++) {
            circuit->matrix[i][j] = 0.0;
        }
    }
}

// Function to add a node to the circuit
void addNode(Circuit *circuit, char type, float value, int n1, int n2) {
    Node node;
    node.type = type;
    node.value = value;
    node.nodes[0] = n1;
    node.nodes[1] = n2;

    circuit->nodes[circuit->numNodes] = node;
    circuit->numNodes++;
}

// Function to build the circuit matrix
void buildMatrix(Circuit *circuit) {
    for(int i=0; i<circuit->numNodes; i++) {
        Node node = circuit->nodes[i];

        if(node.type == 'V') {
            circuit->matrix[i][node.nodes[0]] = 1.0;
            circuit->matrix[i][node.nodes[1]] = -1.0;
            circuit->matrix[circuit->numNodes][i] = node.value;
        }
        else if(node.type == 'R') {
            circuit->matrix[i][i] = 1.0/node.value;
            circuit->matrix[i][node.nodes[0]] = -1.0/node.value;
            circuit->matrix[i][node.nodes[1]] = -1.0/node.value;
        }
        else if(node.type == 'C') {
            circuit->matrix[i][i] = node.value;
            circuit->matrix[i][node.nodes[0]] = -1.0;
            circuit->matrix[i][node.nodes[1]] = 1.0;
        }
    }
}

// Function to solve the circuit using Gauss-Jordan elimination
void solveCircuit(Circuit *circuit) {
    for(int i=0; i<circuit->numNodes-1; i++) {
        float max = circuit->matrix[i][i];
        int maxRow = i;
        for(int j=i+1; j<circuit->numNodes; j++) {
            if(circuit->matrix[j][i] > max) {
                max = circuit->matrix[j][i];
                maxRow = j;
            }
        }
        if(maxRow != i) {
            for(int k=0; k<=circuit->numNodes; k++) {
                float temp = circuit->matrix[i][k];
                circuit->matrix[i][k] = circuit->matrix[maxRow][k];
                circuit->matrix[maxRow][k] = temp;
            }
        }
        for(int j=i+1; j<circuit->numNodes; j++) {
            float scale = circuit->matrix[j][i]/circuit->matrix[i][i];
            for(int k=i; k<=circuit->numNodes; k++) {
                circuit->matrix[j][k] -= scale*circuit->matrix[i][k];
            }
        }
    }
    for(int i=circuit->numNodes-1; i>=0; i--) {
        circuit->voltage[i] = circuit->matrix[i][circuit->numNodes]/circuit->matrix[i][i];
        for(int j=i-1; j>=0; j--) {
            circuit->matrix[j][circuit->numNodes] -= circuit->matrix[j][i]*circuit->voltage[i];
            circuit->matrix[j][i] = 0.0;
        }
    }
}

int main() {
    Circuit circuit;
    initCircuit(&circuit);

    // Add nodes to the circuit
    addNode(&circuit, 'V', 12.0, 0, 1);
    addNode(&circuit, 'R', 100.0, 1, 2);
    addNode(&circuit, 'C', 0.001, 2, 3);
    addNode(&circuit, 'R', 150.0, 3, 0);

    // Build the circuit matrix
    buildMatrix(&circuit);

    // Solve the circuit and print the results
    solveCircuit(&circuit);
    printf(""Voltage at node 0: %f\n"", circuit.voltage[0]);
    printf(""Voltage at node 1: %f\n"", circuit.voltage[1]);
    printf(""Voltage at node 2: %f\n"", circuit.voltage[2]);
    printf(""Voltage at node 3: %f\n"", circuit.voltage[3]);

    return 0;
}",128,4.2
VULNERABLE,gemma7b-20082.c,yes,46,12,csvReader_getLine,"
  file gemma7b-20082.c line 46 column 12 function csvReader_getLine
","
  c:@F@csvReader_getLine at file gemma7b-20082.c line 61 column 12 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    {
        reader->buffer = realloc(reader->buffer, MAX_BUFFER_SIZE * (reader->size + 1));
        reader->size++;
    }

    line = fgets(reader->buffer[reader->currentLine], MAX_BUFFER_SIZE, reader->file);

    if (line)
    {
        reader->currentLine++;
        return lineSize = strlen(line) + 1;","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader
{
    FILE *file;
    char **buffer;
    int size;
    int currentLine;
} CSVReader;

CSVReader *csvReader_init(char *filename)
{
    CSVReader *reader = malloc(sizeof(CSVReader));

    reader->file = fopen(filename, ""r"");
    reader->buffer = NULL;
    reader->size = 0;
    reader->currentLine = 0;

    return reader;
}

void csvReader_free(CSVReader *reader)
{
    fclose(reader->file);
    free(reader->buffer);
    free(reader);
}

int csvReader_getLine(CSVReader *reader)
{
    char *line = NULL;
    int lineSize = 0;

    if (reader->currentLine >= reader->size)
    {
        reader->buffer = realloc(reader->buffer, MAX_BUFFER_SIZE * (reader->size + 1));
        reader->size++;
    }

    line = fgets(reader->buffer[reader->currentLine], MAX_BUFFER_SIZE, reader->file);

    if (line)
    {
        reader->currentLine++;
        return lineSize = strlen(line) + 1;
    }

    return 0;
}

int main()
{
    CSVReader *reader = csvReader_init(""example.csv"");

    while (csvReader_getLine(reader) > 0)
    {
        // Process the line
    }

    csvReader_free(reader);

    return 0;
}",69,1.75
VULNERABLE,gpt35-47711.c,yes,37,9,init_graph,"
  file gpt35-47711.c line 37 column 9 function init_graph
","
  c:@F@init_graph at file gpt35-47711.c line 122 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    g->num_nodes = num_nodes;
    g->num_edges = num_edges;
    for (int i = 0; i < num_nodes; i++) {
        g->nodes[i].id = i;
        g->nodes[i].lat = (double) rand() / RAND_MAX * 180.0 - 90.0;
        g->nodes[i].lon = (double) rand() / RAND_MAX * 360.0 - 180.0;
    }
    for (int i = 0; i < num_edges; i++) {
        g->edges[i].src = rand() % num_nodes;
        g->edges[i].dest = rand() % num_nodes;
        g->edges[i].weight = (double) rand() / RAND_MAX * 100000.0 + 1.0;","//FormAI DATASET v1.0 Category: GPS Navigation Simulation ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 100 // Maximum number of Nodes
#define INF 0x3f3f3f3f // Macro for infinity

// Structure representing a node in the graph
typedef struct Node {
    int id;
    double lat;
    double lon;
} Node;

// Structure representing an edge in the graph
typedef struct Edge {
    int src;
    int dest;
    double weight;
} Edge;

// Structure representing the graph
typedef struct Graph {
    int num_nodes;
    int num_edges;
    Node nodes[MAX_NODES];
    Edge edges[MAX_NODES * MAX_NODES];
} Graph;

// Function to initialize the graph
void init_graph(Graph *g, int num_nodes, int num_edges) {
    g->num_nodes = num_nodes;
    g->num_edges = num_edges;
    for (int i = 0; i < num_nodes; i++) {
        g->nodes[i].id = i;
        g->nodes[i].lat = (double) rand() / RAND_MAX * 180.0 - 90.0;
        g->nodes[i].lon = (double) rand() / RAND_MAX * 360.0 - 180.0;
    }
    for (int i = 0; i < num_edges; i++) {
        g->edges[i].src = rand() % num_nodes;
        g->edges[i].dest = rand() % num_nodes;
        g->edges[i].weight = (double) rand() / RAND_MAX * 100000.0 + 1.0;
    }
}

// Function to print the graph
void print_graph(Graph *g) {
    printf(""Nodes:\n"");
    for (int i = 0; i < g->num_nodes; i++) {
        printf(""%d: (%f, %f)\n"", g->nodes[i].id, g->nodes[i].lat, g->nodes[i].lon);
    }
    printf(""Edges:\n"");
    for (int i = 0; i < g->num_edges; i++) {
        printf(""%d -> %d: %f\n"", g->edges[i].src, g->edges[i].dest, g->edges[i].weight);
    }
}

// Function to find the shortest path from source node to destination node using Dijkstra's algorithm
void shortest_path(Graph *g, int src, int dest) {
    double dist[MAX_NODES];
    int prev[MAX_NODES];
    int visited[MAX_NODES];
    for (int i = 0; i < g->num_nodes; i++) {
        dist[i] = INF;
        prev[i] = -1;
        visited[i] = 0;
    }
    dist[src] = 0;
    for (int i = 0; i < g->num_nodes; i++) {
        int u = -1;
        double min_dist = INF;
        for (int j = 0; j < g->num_nodes; j++) {
            if (!visited[j] && dist[j] < min_dist) {
                u = j;
                min_dist = dist[j];
            }
        }
        if (u == -1 || u == dest) {
            break;
        }
        visited[u] = 1;
        for (int j = 0; j < g->num_edges; j++) {
            if (g->edges[j].src == u) {
                int v = g->edges[j].dest;
                double weight = g->edges[j].weight;
                double alt = dist[u] + weight;
                if (alt < dist[v]) {
                    dist[v] = alt;
                    prev[v] = u;
                }
            }
        }
    }
    // Print the shortest path
    printf(""Shortest path from Node %d to Node %d:\n"", src, dest);
    if (prev[dest] == -1) {
        printf(""No path found.\n"");
        return;
    }
    int path[MAX_NODES];
    int path_len = 0;
    int node = dest;
    while (node != -1) {
        path[path_len++] = node;
        node = prev[node];
    }
    for (int i = path_len - 1; i >= 0; i--) {
        printf(""%d"", path[i]);
        if (i != 0) {
            printf("" -> "");
        }
    }
    printf("", distance: %f\n"", dist[dest]);
}

// Main function to run the program
int main() {
    srand(42); // Seed the random number generator
    Graph g;
    int num_nodes = 10;
    int num_edges = 20;
    init_graph(&g, num_nodes, num_edges);
    print_graph(&g);
    shortest_path(&g, 0, 5);
    shortest_path(&g, 3, 7);
    shortest_path(&g, 8, 6);
    return 0;
}",128,5.5
VULNERABLE,gpt35-57862.c,yes,83,13,createThreads,"
  file gpt35-57862.c line 83 column 13 function createThreads
","
  c:@F@createThreads at file gpt35-57862.c line 119 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
    for (int i = 0; i < MAX_THREADS; i++) {
        datas[i].n = n;
        datas[i].idx = i;
        for (int j = 0; j < n; j++) {
            datas[i].nodes[j] = nodes[j];
        }
    }

    for (int i = 0; i < MAX_THREADS; i++) {
        pthread_create(&threads[i], NULL, dfs, &datas[i]);","//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: distributed
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <pthread.h>

#define MAX_NODES 100
#define MAX_THREADS 10

typedef struct {
    int x, y, val;
} Node;

typedef struct {
    int idx;
    int n;
    Node *nodes[MAX_NODES];
} ThreadData;

// Global variables
int maze[MAX_NODES][MAX_NODES];
int n, m;
bool visited[MAX_NODES][MAX_NODES] = { false };
Node *path[MAX_NODES * MAX_NODES];
int path_len = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void *dfs(void *arg) {
    ThreadData *data = (ThreadData *) arg;

    int idx = data->idx;
    int start = idx * (data->n / MAX_THREADS);
    int end = (idx + 1) * (data->n / MAX_THREADS);

    if (idx == MAX_THREADS - 1) {
        end = data->n;
    }

    for (int i = start; i < end; i++) {
        for (int j = 0; j < m; j++) {
            if (maze[i][j] == 0 && !visited[i][j]) {
                visited[i][j] = true;
                path[path_len++] = data->nodes[i * m + j];

                if (i == n - 1 && j == m - 1) {
                    // We have reached the end of the maze
                    return NULL;
                }

                dfs(arg);

                if (path_len > 0) {
                    path_len--;
                }
                visited[i][j] = false;
            }
        }
    }

    return NULL;
}

void inputMaze() {
    scanf(""%i %i"", &n, &m);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int val;
            scanf(""%i"", &val);
            maze[i][j] = val;
        }
    }
}

void createThreads(Node *nodes[MAX_NODES], int n) {
    pthread_t threads[MAX_THREADS];
    ThreadData datas[MAX_THREADS];

    for (int i = 0; i < MAX_THREADS; i++) {
        datas[i].n = n;
        datas[i].idx = i;
        for (int j = 0; j < n; j++) {
            datas[i].nodes[j] = nodes[j];
        }
    }

    for (int i = 0; i < MAX_THREADS; i++) {
        pthread_create(&threads[i], NULL, dfs, &datas[i]);
    }

    for (int i = 0; i < MAX_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
}

void printPath() {
    printf(""Path: "");
    for (int i = 0; i < path_len; i++) {
        printf(""(%d,%d)"", path[i]->x, path[i]->y);
        if (i < path_len - 1) {
            printf("" -> "");
        }
    }
    printf(""\n"");
}

int main() {
    inputMaze();

    Node nodes[MAX_NODES * MAX_NODES];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            nodes[i * m + j].x = i;
            nodes[i * m + j].y = j;
            nodes[i * m + j].val = maze[i][j];
        }
    }

    createThreads(nodes, n * m);

    if (path_len > 0) {
        printPath();
    } else {
        printf(""No path found\n"");
    }

    return 0;
}",128,4.8
VULNERABLE,falcon180b-59800.c,yes,28,9,getLineWords,"
  file falcon180b-59800.c line 28 column 9 function getLineWords
","
  c:@F@getLineWords at file falcon180b-59800.c line 54 column 23 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    char *word;
    int count = 0;

    word = strtok(line, "" "");
    while (word!= NULL) {
        words[count] = word;
        count++;
        word = strtok(NULL, "" "");
    }

    return count;","//Falcon-180B DATASET v1.0 Category: Log analysis ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LOG_SIZE 1000
#define MAX_WORD_LENGTH 50
#define MAX_LINE_LENGTH 1000

typedef struct {
    char *word;
    int count;
} WordCount;

int compareWords(const void *a, const void *b) {
    WordCount *wc1 = (WordCount *)a;
    WordCount *wc2 = (WordCount *)b;
    
    return strcmp(wc1->word, wc2->word);
}

int getLineWords(char *line, char *words[]) {
    char *word;
    int count = 0;
    
    word = strtok(line, "" "");
    while (word!= NULL) {
        words[count] = word;
        count++;
        word = strtok(NULL, "" "");
    }
    
    return count;
}

int main() {
    FILE *logFile;
    char logLine[MAX_LINE_LENGTH];
    char *word;
    int lineCount = 0;
    int totalWords = 0;
    WordCount wordsCount[MAX_WORD_LENGTH];
    int numWords = 0;
    
    logFile = fopen(""logfile.txt"", ""r"");
    
    if (logFile == NULL) {
        printf(""Error: Could not open log file.\n"");
        return 1;
    }
    
    while (fgets(logLine, MAX_LINE_LENGTH, logFile)!= NULL) {
        lineCount++;
        totalWords += getLineWords(logLine, wordsCount);
    }
    
    fclose(logFile);
    
    qsort(wordsCount, numWords, sizeof(WordCount), compareWords);
    
    printf(""Total lines: %d\n"", lineCount);
    printf(""Total words: %d\n"", totalWords);
    
    for (int i = 0; i < numWords; i++) {
        printf(""%s: %d\n"", wordsCount[i].word, wordsCount[i].count);
    }
    
    return 0;
}",69,2.333
VULNERABLE,gemma7b-21480.c,yes,32,44,csvReader_readCSV,"
  file gemma7b-21480.c line 32 column 44 function csvReader_readCSV
","
  c:@F@csvReader_readCSV at file gemma7b-21480.c line 49 column 3 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"  char line[MAX_BUFFER_SIZE];
  reader->lineNumber++;
  fgets(line, MAX_BUFFER_SIZE, reader->fp);
  reader->bufferSize = 0;
  reader->buffer = realloc(reader->buffer, (reader->lineNumber + 1) * MAX_BUFFER_SIZE);
  reader->buffer[reader->lineNumber - 1] = strdup(line);
  char *token = strtok(line, "","");
  reader->columnNumber = 0;
  while (token) {
    reader->columnNumber++;
    token = strtok(NULL, "","");","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: introspective
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
  FILE *fp;
  char **buffer;
  int bufferSize;
  int lineNumber;
  int columnNumber;
} CSVReader;

CSVReader *csvReader_init(char *filename) {
  CSVReader *reader = malloc(sizeof(CSVReader));
  reader->fp = fopen(filename, ""r"");
  reader->buffer = NULL;
  reader->bufferSize = 0;
  reader->lineNumber = 0;
  reader->columnNumber = 0;
  return reader;
}

void csvReader_readCSV(CSVReader *reader) {
  char line[MAX_BUFFER_SIZE];
  reader->lineNumber++;
  fgets(line, MAX_BUFFER_SIZE, reader->fp);
  reader->bufferSize = 0;
  reader->buffer = realloc(reader->buffer, (reader->lineNumber + 1) * MAX_BUFFER_SIZE);
  reader->buffer[reader->lineNumber - 1] = strdup(line);
  char *token = strtok(line, "","");
  reader->columnNumber = 0;
  while (token) {
    reader->columnNumber++;
    token = strtok(NULL, "","");
  }
}

void csvReader_finalize(CSVReader *reader) {
  fclose(reader->fp);
  free(reader->buffer);
  free(reader);
}

int main() {
  CSVReader *reader = csvReader_init(""example.csv"");
  csvReader_readCSV(reader);
  csvReader_readCSV(reader);
  csvReader_finalize(reader);
  return 0;
}",53,1.25
VULNERABLE,gemini_pro-12375.c,yes,59,9,csv_reader_next_line,"
  file gemini_pro-12375.c line 59 column 9 function csv_reader_next_line
","
  c:@F@csv_reader_next_line at file gemini_pro-12375.c line 102 column 12 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"        // Copy the field into the array
        if (num_fields == reader->num_fields) {
            reader->num_fields++;
            reader->fields = realloc(reader->fields, reader->num_fields * sizeof(char*));
        }
        reader->fields[num_fields] = malloc(end - start + 1);
        strncpy(reader->fields[num_fields], start, end - start);
        reader->fields[num_fields][end - start] = '\0';
        num_fields++;

        // Skip trailing whitespace and the comma","//GEMINI-pro DATASET v1.0 Category: Building a CSV Reader ; Style: curious
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

// A custom CSV reader that's both efficient and easy to use!

// Our trusty CSV reader struct, holding all the juicy data
typedef struct CSVReader {
    FILE *fp; // The file we're reading from
    char *line; // The current line we're parsing
    char **fields; // An array of strings representing the fields in the current line
    int num_fields; // The number of fields in the current line
} CSVReader;

// Initializes a new CSV reader for the given file
CSVReader* csv_reader_init(FILE *fp) {
    CSVReader *reader = malloc(sizeof(CSVReader));
    reader->fp = fp;
    reader->line = NULL;
    reader->fields = NULL;
    reader->num_fields = 0;
    return reader;
}

// Frees the resources associated with the CSV reader
void csv_reader_free(CSVReader *reader) {
    if (reader->line != NULL) free(reader->line);
    if (reader->fields != NULL) free(reader->fields);
    free(reader);
}

// Reads the next line from the CSV file and parses it into fields
int csv_reader_next_line(CSVReader *reader) {
    // Free the old line and fields
    if (reader->line != NULL) free(reader->line);
    if (reader->fields != NULL) free(reader->fields);

    // Get the next line from the file
    size_t len = 0;
    if (getline(&reader->line, &len, reader->fp) == -1) return 0; // EOF

    // Split the line into fields
    char *start = reader->line;
    int num_fields = 0;
    while (*start != '\0') {
        // Skip leading whitespace
        while (*start == ' ') start++;

        // Find the end of the field
        char *end = start;
        while (*end != '\0' && *end != ',' && *end != '\n') end++;

        // Copy the field into the array
        if (num_fields == reader->num_fields) {
            reader->num_fields++;
            reader->fields = realloc(reader->fields, reader->num_fields * sizeof(char*));
        }
        reader->fields[num_fields] = malloc(end - start + 1);
        strncpy(reader->fields[num_fields], start, end - start);
        reader->fields[num_fields][end - start] = '\0';
        num_fields++;

        // Skip trailing whitespace and the comma
        start = end;
        while (*start == ' ' || *start == ',') start++;
    }

    // Update the number of fields
    reader->num_fields = num_fields;
    return 1;
}

// Gets the value of the specified field in the current line
char* csv_reader_get_field(CSVReader *reader, int index) {
    if (index < 0 || index >= reader->num_fields) return NULL;
    return reader->fields[index];
}

// Prints the current line
void csv_reader_print_line(CSVReader *reader) {
    for (int i = 0; i < reader->num_fields; i++) {
        printf(""%s"", reader->fields[i]);
        if (i < reader->num_fields - 1) printf("","");
    }
    printf(""\n"");
}

// Our main function, where the magic happens!
int main() {
    // Open the CSV file
    FILE *fp = fopen(""data.csv"", ""r"");
    if (fp == NULL) {
        perror(""Error opening file"");
        return -1;
    }

    // Create a CSV reader
    CSVReader *reader = csv_reader_init(fp);

    // Read and print each line
    while (csv_reader_next_line(reader)) {
        csv_reader_print_line(reader);
    }

    // Free the reader and close the file
    csv_reader_free(reader);
    fclose(fp);
    return 0;
}",110,4.167
VULNERABLE,gemini_pro-4687.c,yes,38,9,init_game,"
  file gemini_pro-4687.c line 38 column 9 function init_game
","
  c:@F@init_game at file gemini_pro-4687.c line 65 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"        }
    }

    for (int i = 0; i < NUM_PIECES_PER_PLAYER; i++) {
        game->players[0].pieces[i].type = 'b';
        game->players[0].pieces[i].position.x = i % 4 + 1;
        game->players[0].pieces[i].position.y = 1 + (i / 4);

        game->players[1].pieces[i].type = 'w';
        game->players[1].pieces[i].position.x = i % 4 + 1;
        game->players[1].pieces[i].position.y = BOARD_SIZE - (1 + (i / 4));","//GEMINI-pro DATASET v1.0 Category: Checkers Game ; Style: unmistakable
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define BOARD_SIZE 8
#define NUM_PIECES_PER_PLAYER 12

typedef struct {
    int x;
    int y;
} Position;

typedef struct {
    char type;
    Position position;
} Piece;

typedef struct {
    Piece pieces[NUM_PIECES_PER_PLAYER];
    int num_pieces;
} Player;

typedef struct {
    Player players[2];
    Piece board[BOARD_SIZE][BOARD_SIZE];
} Game;

void init_game(Game *game) {
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            game->board[i][j].type = ' ';
        }
    }

    for (int i = 0; i < NUM_PIECES_PER_PLAYER; i++) {
        game->players[0].pieces[i].type = 'b';
        game->players[0].pieces[i].position.x = i % 4 + 1;
        game->players[0].pieces[i].position.y = 1 + (i / 4);

        game->players[1].pieces[i].type = 'w';
        game->players[1].pieces[i].position.x = i % 4 + 1;
        game->players[1].pieces[i].position.y = BOARD_SIZE - (1 + (i / 4));
    }
}

void print_board(Game *game) {
    printf(""  "");
    for (int i = 1; i <= BOARD_SIZE; i++) {
        printf(""%2d "", i);
    }
    printf(""\n"");

    for (int i = 1; i <= BOARD_SIZE; i++) {
        printf(""%2d "", i);
        for (int j = 1; j <= BOARD_SIZE; j++) {
            printf(""%c  "", game->board[i - 1][j - 1].type);
        }
        printf(""\n"");
    }
}

int main() {
    Game game;
    init_game(&game);
    print_board(&game);

    for (int i = 1; i <= BOARD_SIZE; i++) {
        printf(""A   B   C   D   E   F   G   H\n"");
    }

    return 0;
}",73,3.333
VULNERABLE,gpt35-75280.c,yes,25,13,init_clusters,"
  file gpt35-75280.c line 25 column 13 function init_clusters
","
  c:@F@init_clusters at file gpt35-75280.c line 111 column 5 function cluster_data
  c:@F@cluster_data at file gpt35-75280.c line 122 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
void init_clusters(struct cluster *clusters, int num_clusters) {
    for (int i = 0; i < num_clusters; i++) {
        clusters[i].count = 0;
        for (int j = 0; j < DIMENSIONS; j++) {
            clusters[i].centroid.coords[j] = 0.0;
        }
    }
}

double distance(struct item a, struct item b) {","//FormAI DATASET v1.0 Category: Clustering Algorithm Implementation ; Style: asynchronous
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#define DIMENSIONS 2
#define MAX_ITEMS 1000

struct item {
    int id;
    double coords[DIMENSIONS];
};

struct cluster {
    int count;
    struct item centroid;
    struct item items[MAX_ITEMS];
};

void init_clusters(struct cluster *clusters, int num_clusters) {
    for (int i = 0; i < num_clusters; i++) {
        clusters[i].count = 0;
        for (int j = 0; j < DIMENSIONS; j++) {
            clusters[i].centroid.coords[j] = 0.0;
        }
    }
}

double distance(struct item a, struct item b) {
    double sum_squares = 0.0;
    for (int i = 0; i < DIMENSIONS; i++) {
        double diff = a.coords[i] - b.coords[i];
        sum_squares += diff * diff;
    }
    return sqrt(sum_squares);
}

int nearest_cluster(struct item data, struct cluster *clusters, int num_clusters) {
    int nearest_index = 0;
    double nearest_distance = distance(data, clusters[0].centroid);
    for (int i = 1; i < num_clusters; i++) {
        double current_distance = distance(data, clusters[i].centroid);
        if (current_distance < nearest_distance) {
            nearest_index = i;
            nearest_distance = current_distance;
        }
    }
    return nearest_index;
}

void assign_to_clusters(struct item *data, int num_items, struct cluster *clusters, int num_clusters) {
    for (int i = 0; i < num_items; i++) {
        int cluster_index = nearest_cluster(data[i], clusters, num_clusters);
        clusters[cluster_index].items[clusters[cluster_index].count] = data[i];
        clusters[cluster_index].count++;
    }
}

void calculate_centroids(struct cluster *clusters, int num_clusters) {
    for (int i = 0; i < num_clusters; i++) {
        for (int j = 0; j < DIMENSIONS; j++) {
            double sum_coords = 0.0;
            for (int k = 0; k < clusters[i].count; k++) {
                sum_coords += clusters[i].items[k].coords[j];
            }
            clusters[i].centroid.coords[j] = sum_coords / clusters[i].count;
        }
    }
}

void print_cluster(struct cluster cl) {
    printf(""Cluster with centroid at ("");
    for (int i = 0; i < DIMENSIONS; i++) {
        printf(""%g"", cl.centroid.coords[i]);
        if (i < DIMENSIONS - 1) {
            putchar(',');
        }
    }
    printf("") contains %d items:\n"", cl.count);
    for (int i = 0; i < cl.count; i++) {
        printf(""    Item %d at ("", cl.items[i].id);
        for (int j = 0; j < DIMENSIONS; j++) {
            printf(""%g"", cl.items[i].coords[j]);
            if (j < DIMENSIONS - 1) {
                putchar(',');
            }
        }
        putchar(')');
        putchar('\n');
    }
}

void print_clusters(struct cluster *clusters, int num_clusters) {
    for (int i = 0; i < num_clusters; i++) {
        print_cluster(clusters[i]);
    }
}

void randomize_data(struct item *data, int num_items) {
    srand(time(NULL));
    for (int i = 0; i < num_items; i++) {
        data[i].id = i;
        for (int j = 0; j < DIMENSIONS; j++) {
            data[i].coords[j] = rand() / (double)RAND_MAX;
        }
    }
}

void cluster_data(struct item *data, int num_items, struct cluster *clusters, int num_clusters) {
    init_clusters(clusters, num_clusters);
    randomize_data(data, num_items);
    assign_to_clusters(data, num_items, clusters, num_clusters);
    calculate_centroids(clusters, num_clusters);
}

int main() {
    int num_items = 100;
    int num_clusters = 3;
    struct item data[num_items];
    struct cluster clusters[num_clusters];
    cluster_data(data, num_items, clusters, num_clusters);
    print_clusters(clusters, num_clusters);
    return 0;
}",125,2.7
VULNERABLE,gemini_pro-12630.c,yes,60,5,calculate_checksum,"
  file gemini_pro-12630.c line 60 column 5 function calculate_checksum
","
  c:@F@calculate_checksum at file gemini_pro-12630.c line 82 column 22 function send_icmp_echo_request
  c:@F@send_icmp_echo_request at file gemini_pro-12630.c line 151 column 7 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"  uint32_t sum = 0;
  uint16_t *words = (uint16_t *)packet;
  int i;

  for (i = 0; i < sizeof(struct icmp_packet) / sizeof(uint16_t); i++) {
    sum += words[i];
  }

  while (sum >> 16) {
    sum = (sum >> 16) + (sum & 0xffff);
  }","//GEMINI-pro DATASET v1.0 Category: Network Ping Test ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

// Define the maximum number of bytes to send and receive
#define MAX_BYTES 1024

// Define the types of messages that can be sent
#define ICMP_ECHO_REQUEST 8
#define ICMP_ECHO_REPLY 0

// Define the structure of an ICMP packet
struct icmp_packet {
  uint8_t type;
  uint8_t code;
  uint16_t checksum;
  uint16_t identifier;
  uint16_t sequence_number;
  uint8_t data[MAX_BYTES];
};

// Define the structure of an IP packet
struct ip_packet {
  uint8_t version_and_header_length;
  uint8_t type_of_service;
  uint16_t total_length;
  uint16_t identification;
  uint16_t flags_and_fragment_offset;
  uint8_t time_to_live;
  uint8_t protocol;
  uint16_t header_checksum;
  uint32_t source_ip_address;
  uint32_t destination_ip_address;
  uint8_t data[MAX_BYTES];
};

// Define the structure of an Ethernet frame
struct ethernet_frame {
  uint8_t destination_mac_address[6];
  uint8_t source_mac_address[6];
  uint16_t type;
  uint8_t data[MAX_BYTES];
};

// Function to calculate the checksum of an ICMP packet
uint16_t calculate_checksum(struct icmp_packet *packet) {
  uint32_t sum = 0;
  uint16_t *words = (uint16_t *)packet;
  int i;

  for (i = 0; i < sizeof(struct icmp_packet) / sizeof(uint16_t); i++) {
    sum += words[i];
  }

  while (sum >> 16) {
    sum = (sum >> 16) + (sum & 0xffff);
  }

  return ~sum;
}

// Function to send an ICMP echo request packet
int send_icmp_echo_request(int sockfd, struct sockaddr_in *addr, struct icmp_packet *packet) {
  // Set the ICMP packet type to echo request
  packet->type = ICMP_ECHO_REQUEST;

  // Set the ICMP packet code to 0
  packet->code = 0;

  // Set the ICMP packet checksum to 0
  packet->checksum = 0;

  // Calculate the ICMP packet checksum
  packet->checksum = calculate_checksum(packet);

  // Send the ICMP echo request packet
  if (sendto(sockfd, packet, sizeof(struct icmp_packet), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in)) < 0) {
    perror(""sendto"");
    return -1;
  }

  return 0;
}

// Function to receive an ICMP echo reply packet
int receive_icmp_echo_reply(int sockfd, struct sockaddr_in *addr, struct icmp_packet *packet) {
  // Receive the ICMP echo reply packet
  if (recvfrom(sockfd, packet, sizeof(struct icmp_packet), 0, (struct sockaddr *)addr, sizeof(struct sockaddr_in)) < 0) {
    perror(""recvfrom"");
    return -1;
  }

  return 0;
}

// Function to print the results of a ping test
void print_ping_results(struct icmp_packet *packet, struct sockaddr_in *addr, double time) {
  // Get the IP address of the host that was pinged
  char *host_ip_address = inet_ntoa(addr->sin_addr);

  // Print the ping results
  printf(""Ping %s (%s): bytes=%d time=%.3fms\n"", host_ip_address, host_ip_address, sizeof(struct icmp_packet), time);
}

// Main function
int main(int argc, char **argv) {
  // Check if the user has specified a hostname or IP address
  if (argc < 2) {
    fprintf(stderr, ""Usage: %s <hostname or IP address>\n"", argv[0]);
    exit(1);
  }

  // Create a raw socket for sending and receiving ICMP packets
  int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
  if (sockfd < 0) {
    perror(""socket"");
    exit(1);
  }

  // Set the socket options to allow sending and receiving raw ICMP packets
  int on = 1;
  if (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0) {
    perror(""setsockopt"");
    exit(1);
  }

  // Get the IP address of the host that was pinged
  struct hostent *host = gethostbyname(argv[1]);
  if (host == NULL) {
    perror(""gethostbyname"");
    exit(1);
  }

  // Create an ICMP echo request packet
  struct icmp_packet packet;

  // Send an ICMP echo request packet
  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr = *(struct in_addr *)host->h_addr;
  addr.sin_port = 0;

  if (send_icmp_echo_request(sockfd, &addr, &packet) < 0) {
    perror(""send_icmp_echo_request"");
    exit(1);
  }

  // Receive an ICMP echo reply packet
  struct timeval start_time, end_time;

  gettimeofday(&start_time, NULL);

  if (receive_icmp_echo_reply(sockfd, &addr, &packet) < 0) {
    perror(""receive_icmp_echo_reply"");
    exit(1);
  }

  gettimeofday(&end_time, NULL);

  // Calculate the time it took for the ICMP echo request and reply packets to be exchanged
  double time = (end_time.tv_sec - start_time.tv_sec) * 1000.0 + (end_time.tv_usec - start_time.tv_usec) / 1000.0;

  // Print the ping results
  print_ping_results(&packet, &addr, time);

  // Close the socket
  close(sockfd);

  return 0;
}",178,3.0
VULNERABLE,gemma7b-23126.c,yes,62,5,main,"
  file gemma7b-23126.c line 62 column 5 function main
","
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
    // Read the next row from the CSV file
    csv_reader_read_next_row(reader);

    // Print the row data
    printf(""%s\n"", reader->buffer[0]);

    // Free the CSV reader
    csv_reader_free(reader);

    return 0;","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader
{
    char **buffer;
    int size;
    int current_row;
    FILE *file;
} CSVReader;

CSVReader *csv_reader_init(FILE *file)
{
    CSVReader *reader = malloc(sizeof(CSVReader));
    reader->buffer = NULL;
    reader->size = 0;
    reader->current_row = 0;
    reader->file = file;

    return reader;
}

void csv_reader_read_next_row(CSVReader *reader)
{
    char line[MAX_BUFFER_SIZE];
    int len = 0;

    // Read a line from the file
    fgets(line, MAX_BUFFER_SIZE, reader->file);

    // Allocate memory for the row if needed
    if (reader->size < reader->current_row + 1)
    {
        reader->buffer = realloc(reader->buffer, (reader->size + 1) * MAX_BUFFER_SIZE);
        reader->size++;
    }

    // Store the line in the buffer
    reader->buffer[reader->current_row++] = strdup(line);
}

void csv_reader_free(CSVReader *reader)
{
    free(reader->buffer);
    fclose(reader->file);
    free(reader);
}

int main()
{
    FILE *file = fopen(""data.csv"", ""r"");
    CSVReader *reader = csv_reader_init(file);

    // Read the next row from the CSV file
    csv_reader_read_next_row(reader);

    // Print the row data
    printf(""%s\n"", reader->buffer[0]);

    // Free the CSV reader
    csv_reader_free(reader);

    return 0;
}",68,1.25
VULNERABLE,gpt35-27263.c,yes,124,9,print_topology,"
  file gpt35-27263.c line 124 column 9 function print_topology
","
  c:@F@print_topology at file gpt35-27263.c line 215 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    printf(""Network Topology:\n\n"");

    // Print the nodes
    printf(""Nodes:\n"");
    for (int i = 0; i < num_nodes; i++) {
        printf(""%d. %s (id: %d)\n"", i+1, topology->nodes[i].name, topology->nodes[i].id);
    }
    printf(""\n"");

    // Print the edges
    printf(""Edges:\n"");","//FormAI DATASET v1.0 Category: Network Topology Mapper ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_NODES 20        // Maximum number of nodes in the network topology
#define MAX_EDGES 40        // Maximum number of edges in the network topology 

// Definition of a node in the network topology
typedef struct Node {
    int id;             // Unique identifier of the node
    char *name;         // Name of the node
    int num_neighbors;  // Number of neighbors (i.e. adjacent nodes)
    int *neighbors;     // Array of neighbor node ids
} Node;

// Definition of an edge in the network topology
typedef struct Edge {
    int id1;            // Id of the first node connected by the edge
    int id2;            // Id of the second node connected by the edge
    int weight;         // Weight of the edge (used for distance calculations)
} Edge;

// Definition of a network topology
typedef struct Topology {
    int num_nodes;      // Number of nodes in the topology
    int num_edges;      // Number of edges in the topology
    Node nodes[MAX_NODES];  // Array of nodes in the topology
    Edge edges[MAX_EDGES];  // Array of edges in the topology
} Topology;

// Function to add a node to the topology
void add_node(Topology *topology, int id, char *name) {
    int num_nodes = topology->num_nodes;

    if (num_nodes == MAX_NODES) {
        printf(""The maximum number of nodes has already been reached!"");
        return;
    }

    // Check if the node already exists in the topology
    for (int i = 0; i < num_nodes; i++) {
        if (topology->nodes[i].id == id) {
            printf(""A node with the same id already exists in the topology!"");
            return;
        }
    }

    // Initialize the new node with the given id and name
    Node new_node;
    new_node.id = id;
    new_node.name = (char *) malloc(strlen(name) + 1);
    strcpy(new_node.name, name);
    new_node.num_neighbors = 0;
    new_node.neighbors = (int *) malloc(sizeof(int) * MAX_NODES);

    // Add the new node to the topology
    topology->nodes[num_nodes] = new_node;
    topology->num_nodes++;
}

// Function to add an edge to the topology
void add_edge(Topology *topology, int id1, int id2, int weight) {
    int num_nodes = topology->num_nodes;
    int num_edges = topology->num_edges;

    if (num_edges == MAX_EDGES) {
        printf(""The maximum number of edges has already been reached!"");
        return;
    }

    // Check if the nodes exist in the topology
    int index1 = -1, index2 = -1;
    for (int i = 0; i < num_nodes; i++) {
        if (topology->nodes[i].id == id1) {
            index1 = i;
        }
        if (topology->nodes[i].id == id2) {
            index2 = i;
        }
    }

    if (index1 == -1 || index2 == -1) {
        printf(""One or both of the nodes does not exist in the topology!"");
        return;
    }

    // Check if the edge already exists in the topology
    for (int i = 0; i < num_edges; i++) {
        if ((topology->edges[i].id1 == id1 && topology->edges[i].id2 == id2) ||
            (topology->edges[i].id1 == id2 && topology->edges[i].id2 == id1)) {
            printf(""The edge already exists in the topology!"");
            return;
        }
    }

    // Add the new edge to the topology
    Edge new_edge;
    new_edge.id1 = id1;
    new_edge.id2 = id2;
    new_edge.weight = weight;

    topology->edges[num_edges] = new_edge;
    topology->num_edges++;

    // Update the adjacency lists of the nodes
    topology->nodes[index1].neighbors[topology->nodes[index1].num_neighbors] = id2;
    topology->nodes[index1].num_neighbors++;
    topology->nodes[index2].neighbors[topology->nodes[index2].num_neighbors] = id1;
    topology->nodes[index2].num_neighbors++;
}

// Function to print the network topology
void print_topology(Topology *topology) {
    int num_nodes = topology->num_nodes;
    int num_edges = topology->num_edges;

    printf(""Network Topology:\n\n"");

    // Print the nodes
    printf(""Nodes:\n"");
    for (int i = 0; i < num_nodes; i++) {
        printf(""%d. %s (id: %d)\n"", i+1, topology->nodes[i].name, topology->nodes[i].id);
    }
    printf(""\n"");

    // Print the edges
    printf(""Edges:\n"");
    for (int i = 0; i < num_edges; i++) {
        printf(""%d. %d-%d (weight: %d)\n"", i+1, topology->edges[i].id1, topology->edges[i].id2, topology->edges[i].weight);
    }
    printf(""\n"");

    // Print the adjacency lists
    printf(""Adjacency Lists:\n"");
    for (int i = 0; i < num_nodes; i++) {
        printf(""%d. %d (%s): "", i+1, topology->nodes[i].id, topology->nodes[i].name);
        for (int j = 0; j < topology->nodes[i].num_neighbors; j++) {
            printf(""%d "", topology->nodes[i].neighbors[j]);
        }
        printf(""\n"");
    }
    printf(""\n"");
}

// Function to perform a depth-first search on the network topology
void dfs(Topology *topology, int curr_node, bool *visited) {
    int num_nodes = topology->num_nodes;

    visited[curr_node] = true;
    printf(""%d "", topology->nodes[curr_node].id);

    for (int i = 0; i < topology->nodes[curr_node].num_neighbors; i++) {
        int neighbor = topology->nodes[curr_node].neighbors[i];

        for (int j = 0; j < num_nodes; j++) {
            if (visited[j] == false && topology->nodes[j].id == neighbor) {
                dfs(topology, j, visited);
                break;
            }
        }
    }
}

// Function to perform a breadth-first search on the network topology
void bfs(Topology *topology, int start_node) {
    int num_nodes = topology->num_nodes;

    int queue[MAX_NODES];
    int front = 0, rear = 0;

    bool visited[MAX_NODES];
    memset(visited, false, sizeof(visited));

    // Enqueue the start node
    queue[rear++] = start_node;
    visited[start_node] = true;

    // Perform the BFS
    while (front < rear) {
        int curr_node = queue[front++];
        printf(""%d "", topology->nodes[curr_node].id);

        for (int i = 0; i < topology->nodes[curr_node].num_neighbors; i++) {
            int neighbor = topology->nodes[curr_node].neighbors[i];

            for (int j = 0; j < num_nodes; j++) {
                if (visited[j] == false && topology->nodes[j].id == neighbor) {
                    queue[rear++] = j;
                    visited[j] = true;
                    break;
                }
            }
        }
    }
}

// Example usage of the network topology mapper
int main() {

    Topology topology;

    // Add some nodes to the topology
    add_node(&topology, 1, ""A"");
    add_node(&topology, 2, ""B"");
    add_node(&topology, 3, ""C"");

    // Add some edges to the topology
    add_edge(&topology, 1, 2, 1);
    add_edge(&topology, 1, 3, 2);
    add_edge(&topology, 2, 3, 3);

    // Print the network topology
    print_topology(&topology);

    // Perform a depth-first search
    printf(""Depth-First Search (starting from node 1): "");
    bool visited[MAX_NODES];
    memset(visited, false, sizeof(visited));
    dfs(&topology, 0, visited);
    printf(""\n"");

    // Perform a breadth-first search
    printf(""Breadth-First Search (starting from node 1): "");
    bfs(&topology, 0);
    printf(""\n"");

    return 0;
}",230,5.5
VULNERABLE,gpt35-42182.c,yes,29,9,init_file_system,"
  file gpt35-42182.c line 29 column 9 function init_file_system
","
  c:@F@init_file_system at file gpt35-42182.c line 144 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"// Initializes the file system with the given size and number of files
void init_file_system(file_system* fs, int size, int num_files) {
    fs->size = size;
    fs->free_space = size - (num_files * sizeof(file_info));
    for (int i = 0; i < NUM_BLOCKS; i++) {
        fs->data[i] = (char*)malloc(BLOCK_SIZE);
    }
    for (int i = 0; i < num_files; i++) {
        strcpy(fs->files[i].name, """");
        fs->files[i].size = 0;
        fs->files[i].start_block = -1;","//FormAI DATASET v1.0 Category: File system simulation ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILE_SIZE 1024 // Maximum size of a file in the file system
#define NUM_FILES 10 // Number of files in the file system
#define NUM_BLOCKS 20 // Number of blocks in the file system
#define BLOCK_SIZE 64 // Size of each block in bytes

typedef struct {
    char name[20]; // Name of file
    int size; // Size of file in bytes
    int start_block; // Index of first block in file
} file_info;

typedef struct {
    int size; // Size of file system in bytes
    int free_space; // Amount of free space in file system in bytes
    char* data[NUM_BLOCKS]; // Array of data blocks
    file_info files[NUM_FILES]; // Array of file information
} file_system;

// Initializes the file system with the given size and number of files
void init_file_system(file_system* fs, int size, int num_files) {
    fs->size = size;
    fs->free_space = size - (num_files * sizeof(file_info));
    for (int i = 0; i < NUM_BLOCKS; i++) {
        fs->data[i] = (char*)malloc(BLOCK_SIZE);
    }
    for (int i = 0; i < num_files; i++) {
        strcpy(fs->files[i].name, """");
        fs->files[i].size = 0;
        fs->files[i].start_block = -1;
    }
}

// Writes the given data to the given block of the file system
void write_block(file_system* fs, int block_num, char* data) {
    if (strlen(data) > BLOCK_SIZE) {
        printf(""Error: Data too large for block size\n"");
        return;
    }
    strcpy(fs->data[block_num], data);
}

// Reads data from the given block of the file system into the given buffer
void read_block(file_system* fs, int block_num, char* buffer) {
    strcpy(buffer, fs->data[block_num]);
}

// Adds a new file to the file system with the given name and size
void add_file(file_system* fs, char* name, int size) {
    if (fs->free_space < (size + sizeof(file_info))) {
        printf(""Error: Not enough space in file system"");
        return;
    }
    for (int i = 0; i < NUM_FILES; i++) {
        if (strcmp(fs->files[i].name, """") == 0) { // Find first available spot in files array
            fs->free_space -= (size + sizeof(file_info));
            strcpy(fs->files[i].name, name);
            fs->files[i].size = size;
            for (int j = 0; j < NUM_BLOCKS; j++) {
                if (strcmp(fs->data[j], """") == 0) { // Find first available block in data array
                    fs->files[i].start_block = j;
                    write_block(fs, j, """"); // Initialize block with empty string
                    break;
                }
            }
            break;
        }
    }
}

// Writes data to the given file in the file system
void write_file(file_system* fs, char* name, char* data) {
    int file_index = -1;
    for (int i = 0; i < NUM_FILES; i++) {
        if (strcmp(fs->files[i].name, name) == 0) { // Find file with given name
            file_index = i;
            break;
        }
    }
    if (file_index == -1) {
        printf(""Error: File not found"");
        return;
    }
    if (strlen(data) > fs->files[file_index].size) {
        printf(""Error: Data too large for file size\n"");
        return;
    }
    int num_blocks_needed = (fs->files[file_index].size + BLOCK_SIZE - 1) / BLOCK_SIZE; // Round up to nearest block
    int num_data_blocks = NUM_BLOCKS - NUM_FILES;
    if (num_blocks_needed > num_data_blocks) {
        printf(""Error: File too large for file system\n"");
        return;
    }
    int blocks_written = 0;
    int block_num = fs->files[file_index].start_block;
    while (blocks_written < num_blocks_needed) { // Write data to required number of blocks
        write_block(fs, block_num, data);
        blocks_written++;
        block_num++;
    }
}

// Reads data from the given file in the file system into the given buffer
void read_file(file_system* fs, char* name, char* buffer) {
    int file_index = -1;
    for (int i = 0; i < NUM_FILES; i++) {
        if (strcmp(fs->files[i].name, name) == 0) { // Find file with given name
            file_index = i;
            break;
        }
    }
    if (file_index == -1) {
        printf(""Error: File not found"");
        return;
    }
    int num_blocks_needed = (fs->files[file_index].size + BLOCK_SIZE - 1) / BLOCK_SIZE; // Round up to nearest block
    int blocks_read = 0;
    int block_num = fs->files[file_index].start_block;
    while (blocks_read < num_blocks_needed) { // Read data from required number of blocks
        char block_data[BLOCK_SIZE];
        read_block(fs, block_num, block_data);
        strcat(buffer, block_data);
        blocks_read++;
        block_num++;
    }
}

// Prints a list of all files in the file system
void list_files(file_system* fs) {
    printf(""Files in file system:\n"");
    for (int i = 0; i < NUM_FILES; i++) {
        if (strcmp(fs->files[i].name, """") != 0) {
            printf(""%s (%d bytes)\n"", fs->files[i].name, fs->files[i].size);
        }
    }
}

int main() {
    file_system fs;
    init_file_system(&fs, NUM_BLOCKS * BLOCK_SIZE, NUM_FILES);
    add_file(&fs, ""file1"", 100);
    add_file(&fs, ""file2"", 200);
    list_files(&fs);
    char data[] = ""This is some example data"";
    write_file(&fs, ""file1"", data);
    char buffer[MAX_FILE_SIZE] = """";
    read_file(&fs, ""file1"", buffer);
    printf(""File contents: %s\n"", buffer);
    return 0;
}",154,3.5
VULNERABLE,llama2-13B_2121.c,yes,22,9,assemble_puzzle,"
  file llama2-13B_2121.c line 22 column 9 function assemble_puzzle
","
  c:@F@assemble_puzzle at file llama2-13B_2121.c line 50 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    char assembled[num_pieces][3];

    // Loop through the puzzle pieces and assemble them
    for (int i = 0; i < num_pieces; i++) {
        // Get the current puzzle piece
        struct puzzle_piece* piece = pieces[i];

        // If the piece is not already in the assembled puzzle, add it
        if (strchr(assembled[piece->x][piece->y], piece->symbol) == NULL) {
            assembled[piece->x][piece->y] = piece->symbol;
        }","//LLAMA2-13B DATASET v1.0 Category: Syntax parsing ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// Define a struct to represent a puzzle piece
struct puzzle_piece {
    char symbol; // the symbol on the puzzle piece
    int x; // the x-coordinate of the puzzle piece
    int y; // the y-coordinate of the puzzle piece
};

// Define a function to parse the puzzle pieces and put them together
void assemble_puzzle(struct puzzle_piece** pieces, int num_pieces) {
    // Create a 2D array to store the assembled puzzle
    char assembled[num_pieces][3];

    // Loop through the puzzle pieces and assemble them
    for (int i = 0; i < num_pieces; i++) {
        // Get the current puzzle piece
        struct puzzle_piece* piece = pieces[i];

        // If the piece is not already in the assembled puzzle, add it
        if (strchr(assembled[piece->x][piece->y], piece->symbol) == NULL) {
            assembled[piece->x][piece->y] = piece->symbol;
        }
    }

    // Print the assembled puzzle
    for (int i = 0; i < num_pieces; i++) {
        for (int j = 0; j < 3; j++) {
            printf(""%c"", assembled[i][j]);
        }
        printf(""\n"");
    }
}

int main() {
    // Define an array of puzzle pieces
    struct puzzle_piece pieces[5] = {
        {'A', 0, 0},
        {'B', 1, 0},
        {'C', 2, 0},
        {'D', 0, 1},
        {'E', 1, 1}
    };

    // Call the function to assemble the puzzle
    assemble_puzzle(pieces, 5);

    return 0;
}",53,3.0
VULNERABLE,gemma7b-39427.c,yes,51,42,readCSVLine,"
  file gemma7b-39427.c line 51 column 42 function readCSVLine
","
  c:@F@readCSVLine at file gemma7b-39427.c line 59 column 3 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
  // Allocate memory for the line buffer
  reader->buffer = realloc(reader->buffer, (reader->bufferSize + 1) * sizeof(char *));

  // Copy the line into the buffer
  reader->buffer[reader->bufferSize++] = strdup(line);
  reader->currentLine++;
}

int main() {
  CSVReader *reader = createCSVReader(""example.csv"");","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
  FILE *fp;
  char **buffer;
  int bufferSize;
  int currentLine;
  int **data;
  int dataSize;
} CSVReader;

CSVReader *createCSVReader(char *filename) {
  CSVReader *reader = malloc(sizeof(CSVReader));
  reader->fp = fopen(filename, ""r"");
  reader->buffer = NULL;
  reader->bufferSize = 0;
  reader->currentLine = 0;
  reader->data = NULL;
  reader->dataSize = 0;

  return reader;
}

void freeCSVReader(CSVReader *reader) {
  fclose(reader->fp);
  free(reader->buffer);
  free(reader->data);
  free(reader);
}

void readCSVLine(CSVReader *reader) {
  char line[MAX_BUFFER_SIZE];
  int lineSize = 0;

  fgets(line, MAX_BUFFER_SIZE, reader->fp);

  // Calculate the line size
  while (line[lineSize] != '\n' && lineSize < MAX_BUFFER_SIZE) {
    lineSize++;
  }

  // Allocate memory for the line buffer
  reader->buffer = realloc(reader->buffer, (reader->bufferSize + 1) * sizeof(char *));

  // Copy the line into the buffer
  reader->buffer[reader->bufferSize++] = strdup(line);
  reader->currentLine++;
}

int main() {
  CSVReader *reader = createCSVReader(""example.csv"");

  // Read CSV lines
  readCSVLine(reader);
  readCSVLine(reader);

  // Print the data
  for (int i = 0; i < reader->currentLine; i++) {
    printf(""%s\n"", reader->buffer[i]);
  }

  freeCSVReader(reader);

  return 0;
}",70,1.75
VULNERABLE,gemma7b-34762.c,yes,29,3,csvReader_readCSV,"
  file gemma7b-34762.c line 29 column 3 function csvReader_readCSV
","
  c:@F@csvReader_readCSV at file gemma7b-34762.c line 49 column 3 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"  return reader;
}

void csvReader_readCSV(CSVReader *reader) {
  reader->buffer = realloc(reader->buffer, reader->bufferSize * (reader->currentLine + 1) * sizeof(char *));
  reader->buffer[reader->currentLine] = malloc(MAX_BUFFER_SIZE * sizeof(char));

  fgets(reader->buffer[reader->currentLine], MAX_BUFFER_SIZE, reader->fp);

  reader->currentLine++;
}","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader {
  FILE *fp;
  char **buffer;
  int bufferSize;
  int currentLine;
  int currentColumn;
} CSVReader;

CSVReader *csvReader_init(const char *filename) {
  CSVReader *reader = malloc(sizeof(CSVReader));
  reader->fp = fopen(filename, ""r"");
  reader->buffer = NULL;
  reader->bufferSize = MAX_BUFFER_SIZE;
  reader->currentLine = 0;
  reader->currentColumn = 0;

  return reader;
}

void csvReader_readCSV(CSVReader *reader) {
  reader->buffer = realloc(reader->buffer, reader->bufferSize * (reader->currentLine + 1) * sizeof(char *));
  reader->buffer[reader->currentLine] = malloc(MAX_BUFFER_SIZE * sizeof(char));

  fgets(reader->buffer[reader->currentLine], MAX_BUFFER_SIZE, reader->fp);

  reader->currentLine++;
}

char **csvReader_getColumn(CSVReader *reader, int column) {
  char **columnData = malloc(reader->currentLine * sizeof(char *));

  for (int i = 0; i < reader->currentLine; i++) {
    columnData[i] = strchr(reader->buffer[i], ',') + 1;
  }

  return columnData;
}

int main() {
  CSVReader *reader = csvReader_init(""data.csv"");

  csvReader_readCSV(reader);

  char **columnData = csvReader_getColumn(reader, 1);

  for (int i = 0; i < reader->currentLine; i++) {
    printf(""%s\n"", columnData[i]);
  }

  fclose(reader->fp);
  free(reader);

  return 0;
}",61,1.5
VULNERABLE,gemini_pro-21547.c,yes,40,9,init_robot,"
  file gemini_pro-21547.c line 40 column 9 function init_robot
","
  c:@F@init_robot at file gemini_pro-21547.c line 133 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"void init_robot(robot_t *robot) {
    for (int i = 0; i < NUM_SERVOS; i++) {
        robot->servos[i].position = 0;
        robot->servos[i].velocity = 0;
        robot->servos[i].acceleration = 0;
        robot->servos[i].enabled = false;
    }

    for (int i = 0; i < NUM_MOTORS; i++) {
        robot->motors[i].speed = 0;
        robot->motors[i].enabled = false;","//GEMINI-pro DATASET v1.0 Category: Robot movement control ; Style: high level of detail
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

#define NUM_SERVOS      4
#define NUM_MOTORS      2

enum direction {
    FORWARD,
    BACKWARD,
    LEFT,
    RIGHT,
    STOP
};

typedef struct {
    int16_t position;
    int16_t velocity;
    int16_t acceleration;
    bool enabled;
} servo_t;

typedef struct {
    int16_t speed;
    bool enabled;
} motor_t;

typedef struct {
    servo_t servos[NUM_SERVOS];
    motor_t motors[NUM_MOTORS];
} robot_t;

void init_robot(robot_t *robot) {
    for (int i = 0; i < NUM_SERVOS; i++) {
        robot->servos[i].position = 0;
        robot->servos[i].velocity = 0;
        robot->servos[i].acceleration = 0;
        robot->servos[i].enabled = false;
    }

    for (int i = 0; i < NUM_MOTORS; i++) {
        robot->motors[i].speed = 0;
        robot->motors[i].enabled = false;
    }
}

void set_servo_position(robot_t *robot, uint8_t servo_id, int16_t position) {
    if (servo_id >= 0 && servo_id < NUM_SERVOS) {
        robot->servos[servo_id].position = position;
    }
}

void set_servo_velocity(robot_t *robot, uint8_t servo_id, int16_t velocity) {
    if (servo_id >= 0 && servo_id < NUM_SERVOS) {
        robot->servos[servo_id].velocity = velocity;
    }
}

void set_servo_acceleration(robot_t *robot, uint8_t servo_id, int16_t acceleration) {
    if (servo_id >= 0 && servo_id < NUM_SERVOS) {
        robot->servos[servo_id].acceleration = acceleration;
    }
}

void enable_servo(robot_t *robot, uint8_t servo_id) {
    if (servo_id >= 0 && servo_id < NUM_SERVOS) {
        robot->servos[servo_id].enabled = true;
    }
}

void disable_servo(robot_t *robot, uint8_t servo_id) {
    if (servo_id >= 0 && servo_id < NUM_SERVOS) {
        robot->servos[servo_id].enabled = false;
    }
}

void set_motor_speed(robot_t *robot, uint8_t motor_id, int16_t speed) {
    if (motor_id >= 0 && motor_id < NUM_MOTORS) {
        robot->motors[motor_id].speed = speed;
    }
}

void enable_motor(robot_t *robot, uint8_t motor_id) {
    if (motor_id >= 0 && motor_id < NUM_MOTORS) {
        robot->motors[motor_id].enabled = true;
    }
}

void disable_motor(robot_t *robot, uint8_t motor_id) {
    if (motor_id >= 0 && motor_id < NUM_MOTORS) {
        robot->motors[motor_id].enabled = false;
    }
}

void move_forward(robot_t *robot) {
    set_motor_speed(robot, 0, 100);
    set_motor_speed(robot, 1, 100);
    enable_motor(robot, 0);
    enable_motor(robot, 1);
}

void move_backward(robot_t *robot) {
    set_motor_speed(robot, 0, -100);
    set_motor_speed(robot, 1, -100);
    enable_motor(robot, 0);
    enable_motor(robot, 1);
}

void turn_left(robot_t *robot) {
    set_motor_speed(robot, 0, 100);
    set_motor_speed(robot, 1, -100);
    enable_motor(robot, 0);
    enable_motor(robot, 1);
}

void turn_right(robot_t *robot) {
    set_motor_speed(robot, 0, -100);
    set_motor_speed(robot, 1, 100);
    enable_motor(robot, 0);
    enable_motor(robot, 1);
}

void stop(robot_t *robot) {
    disable_motor(robot, 0);
    disable_motor(robot, 1);
}

int main(void) {
    robot_t robot;

    init_robot(&robot);

    move_forward(&robot);
    sleep(1);
    stop(&robot);

    turn_left(&robot);
    sleep(1);
    stop(&robot);

    move_backward(&robot);
    sleep(1);
    stop(&robot);

    turn_right(&robot);
    sleep(1);
    stop(&robot);

    return 0;
}",152,2.2
VULNERABLE,gpt35-42622.c,yes,42,9,add_index_entry,"
  file gpt35-42622.c line 42 column 9 function add_index_entry
","
  c:@F@add_index_entry at file gpt35-42622.c line 68 column 13 function create_index
  c:@F@create_index at file gpt35-42622.c line 108 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
// Define a function to add an entry to the index
void add_index_entry(Index* index, int id, long position) {
    if (index->num_entries < MAX_ENTRIES) {
        index->entries[index->num_entries].id = id;
        index->entries[index->num_entries].position = position;
        index->num_entries++;
    }
}

// Define a function to read an index entry from a file","//FormAI DATASET v1.0 Category: Database Indexing System ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ENTRIES 100

// Define a structure to store data for each entry in the database
typedef struct {
    int id;
    char name[50];
    char address[100];
    double salary;
} Employee;

// Define a structure to store index information for each record in the database
typedef struct {
    int id;
    long position;
} IndexEntry;

// Define a structure to store the overall index for the database
typedef struct {
    int num_entries;
    IndexEntry entries[MAX_ENTRIES];
} Index;

// Define a function to read an Employee record from a file
void read_employee(FILE* fp, Employee* employee) {
    fscanf(fp, ""%d %s %s %lf"", &employee->id, employee->name, employee->address, &employee->salary);
}

// Define a function to write an Employee record to a file
void write_employee(FILE* fp, const Employee* employee) {
    fprintf(fp, ""%d %s %s %lf\n"", employee->id, employee->name, employee->address, employee->salary);
}

// Define a function to add an entry to the index
void add_index_entry(Index* index, int id, long position) {
    if (index->num_entries < MAX_ENTRIES) {
        index->entries[index->num_entries].id = id;
        index->entries[index->num_entries].position = position;
        index->num_entries++;
    }
}

// Define a function to read an index entry from a file
void read_index_entry(FILE* fp, IndexEntry* entry) {
    fscanf(fp, ""%d %ld"", &entry->id, &entry->position);
}

// Define a function to write an index entry to a file
void write_index_entry(FILE* fp, const IndexEntry* entry) {
    fprintf(fp, ""%d %ld\n"", entry->id, entry->position);
}

// Define a function to create the index for the database
void create_index(const char* filename, Index* index) {
    FILE* fp = fopen(filename, ""r"");
    if (fp) {
        // Read each employee record from the file
        Employee employee;
        long position = 0;
        while (!feof(fp)) {
            // Read the next employee record
            read_employee(fp, &employee);
            // Add an index entry for this record
            add_index_entry(index, employee.id, position);
            // Increment the file position to the next record 
            position = ftell(fp);
        }
        fclose(fp);
    }
}

// Define a function to print an employee record
void print_employee(const Employee* employee) {
    printf(""%d %s %s %lf\n"", employee->id, employee->name, employee->address, employee->salary);
}

// Define a function to retrieve an employee record by id
void get_employee_by_id(const char* filename, const Index* index, int id, Employee* employee) {
    FILE* fp = fopen(filename, ""r"");
    if (fp) {
        // Binary search the index for the record with the given id
        int min = 0;
        int max = index->num_entries - 1;
        while (min <= max) {
            int mid = (min + max) / 2;
            if (index->entries[mid].id == id) {
                // Seek to the position of the record in the file
                fseek(fp, index->entries[mid].position, SEEK_SET);
                // Read the record from the file
                read_employee(fp, employee);
                break;
            } else if (index->entries[mid].id < id) {
                min = mid + 1;
            } else {
                max = mid - 1;
            }
        }
        fclose(fp);
    }
}

int main() {
    Index index;
    create_index(""employees.txt"", &index);
    Employee employee;
    get_employee_by_id(""employees.txt"", &index, 2, &employee);
    print_employee(&employee);
    return 0;
}",113,1.778
VULNERABLE,gpt35-51720.c,yes,38,9,initialize_auction,"
  file gpt35-51720.c line 38 column 9 function initialize_auction
","
  c:@F@initialize_auction at file gpt35-51720.c line 144 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    auction->number_of_bidders = MAX_BIDDERS;

    // Creating the items
    for (int i = 0; i < auction->number_of_items; i++) {
        auction->items[i].id = i;
        auction->items[i].name = ""Item Name"";
        auction->items[i].starting_price = 10.00;
        auction->items[i].highest_bidder = NULL;
        auction->items[i].highest_bid = 0.00;
    }
","//FormAI DATASET v1.0 Category: Digital Auction System ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_BIDDERS 10
#define MAX_ITEMS 5

struct Bidder {
    int id;
    char* name;
    float balance;
};

struct Item {
    int id;
    char* name;
    float starting_price;
    struct Bidder* highest_bidder;
    float highest_bid;
};

struct Auction {
    int number_of_items;
    int number_of_bidders;
    struct Item items[MAX_ITEMS];
    struct Bidder bidders[MAX_BIDDERS];
};

// Initializes all the items and bidders in the auction
void initialize_auction(struct Auction* auction) {
    auction->number_of_items = MAX_ITEMS;
    auction->number_of_bidders = MAX_BIDDERS;

    // Creating the items
    for (int i = 0; i < auction->number_of_items; i++) {
        auction->items[i].id = i;
        auction->items[i].name = ""Item Name"";
        auction->items[i].starting_price = 10.00;
        auction->items[i].highest_bidder = NULL;
        auction->items[i].highest_bid = 0.00;
    }

    // Creating the bidders
    for (int i = 0; i < auction->number_of_bidders; i++) {
        char* name = (char*)calloc(10, sizeof(char));
        sprintf(name, ""Bidder #%d"", i+1);

        auction->bidders[i].id = i;
        auction->bidders[i].name = name;
        auction->bidders[i].balance = 50.00;
    }
}

// Shows the current state of the auction
void show_auction(struct Auction* auction) {
    printf(""AUCTION\n"");

    printf(""Items:\n"");
    for (int i = 0; i < auction->number_of_items; i++) {
        printf(""Item #%d: %s\n"", auction->items[i].id, auction->items[i].name);

        if (auction->items[i].highest_bidder == NULL) {
            printf(""Starting price: $%.2f\n"", auction->items[i].starting_price);
        } else {
            printf(""Highest bid: $%.2f by %s\n"", auction->items[i].highest_bid, auction->items[i].highest_bidder->name);
        }

        printf(""------------------------\n"");
    }

    printf(""Bidders:\n"");
    for (int i = 0; i < auction->number_of_bidders; i++) {
        printf(""%s - Balance: $%.2f\n"", auction->bidders[i].name, auction->bidders[i].balance);
    }
}

// Get the bidder with the given id
struct Bidder* get_bidder(struct Auction* auction, int id) {
    for (int i = 0; i < auction->number_of_bidders; i++) {
        if (auction->bidders[i].id == id) {
            return &auction->bidders[i];
        }
    }

    return NULL;
}

// Get the item with the given id
struct Item* get_item(struct Auction* auction, int id) {
    for (int i = 0; i < auction->number_of_items; i++) {
        if (auction->items[i].id == id) {
            return &auction->items[i];
        }
    }

    return NULL;
}

// Run the auction
void run_auction(struct Auction* auction) {
    int number_of_bids = 0;

    // Randomly select a bidder and an item, and have the bidder bid a random amount
    while (number_of_bids < 20) {
        int bidder_id = rand() % auction->number_of_bidders;
        int item_id = rand() % auction->number_of_items;
        float bid_amount = ((float)(rand() % 100)) + 10.00;

        struct Bidder* bidder = get_bidder(auction, bidder_id);
        struct Item* item = get_item(auction, item_id);

        if (bidder == NULL || item == NULL) {
            continue;
        }

        // If the bidder doesn't have enough balance, skip the bid
        if (bid_amount > bidder->balance) {
            continue;
        }

        // If the bid is lower than the current highest bid, skip the bid
        if (bid_amount <= item->highest_bid) {
            continue;
        }

        // Update the highest bid for the item
        item->highest_bidder = bidder;
        item->highest_bid = bid_amount;

        // Deduct the bid amount from the bidder's balance
        bidder->balance -= bid_amount;

        number_of_bids++;
    }
}

// Main function
int main() {
    srand(time(0));

    struct Auction auction;

    initialize_auction(&auction);
    show_auction(&auction);

    run_auction(&auction);
    printf(""\nAuction has ended.\n"");
    show_auction(&auction);

    return 0;
}",152,3.333
VULNERABLE,gpt35-14038.c,yes,36,9,load_baggage,"
  file gpt35-14038.c line 36 column 9 function load_baggage
","
  c:@F@load_baggage at file gpt35-14038.c line 84 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"} Flight;

// Load the baggage to the given terminal
void load_baggage(Baggage *baggage, Terminal *terminal) {
    if (terminal->current_load + baggage->weight <= terminal->capacity) {
        terminal->baggage_list[terminal->current_load] = baggage;
        terminal->current_load += baggage->weight;
        printf(""Baggage %d loaded to Terminal %d, Current Load: %d/%d\n"", baggage->id, terminal->id, terminal->current_load, terminal->capacity);
    } else {
        printf(""Terminal %d is full for Baggage %d\n"", terminal->id, baggage->id);
    }","//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>

#define MAX_BAGGAGE 100 // Maximum number of bags
#define MAX_FLIGHTS 10  // Maximum number of flights
#define MAX_TERMINALS 5 // Maximum number of terminals

// Define the Baggage structure
typedef struct Baggage {
    int id;             // Unique identifier of the baggage
    int flight_number;  // Flight number of the baggage
    int terminal_id;    // ID of the terminal where the baggage will be loaded
    int weight;         // Weight of the baggage in kilograms
} Baggage;

// Define the Terminal structure
typedef struct Terminal {
    int id;             // Unique identifier of the terminal
    int capacity;       // Maximum number of bags that can be loaded to the terminal
    int current_load;   // Current load of the terminal in kilograms
    Baggage *baggage_list[MAX_BAGGAGE]; // List of baggage loaded to the terminal
} Terminal;

// Define the Flight structure
typedef struct Flight {
    int number;         // Unique identifier of the flight
    int capacity;       // Maximum number of bags that can be loaded to the flight
    int current_load;   // Current load of the flight in kilograms
    Terminal *terminal_list[MAX_TERMINALS]; // List of terminals where the flight will stop
} Flight;

// Load the baggage to the given terminal
void load_baggage(Baggage *baggage, Terminal *terminal) {
    if (terminal->current_load + baggage->weight <= terminal->capacity) {
        terminal->baggage_list[terminal->current_load] = baggage;
        terminal->current_load += baggage->weight;
        printf(""Baggage %d loaded to Terminal %d, Current Load: %d/%d\n"", baggage->id, terminal->id, terminal->current_load, terminal->capacity);
    } else {
        printf(""Terminal %d is full for Baggage %d\n"", terminal->id, baggage->id);
    }
}

int main() {
    // Initialize the flights
    Flight flight_list[MAX_FLIGHTS];
    flight_list[0].number = 1;
    flight_list[0].capacity = 1000;
    flight_list[0].current_load = 0;

    // Initialize the terminals
    Terminal terminal_list[MAX_TERMINALS];
    terminal_list[0].id = 1;
    terminal_list[0].capacity = 500;
    terminal_list[0].current_load = 0;
    terminal_list[1].id = 2;
    terminal_list[1].capacity = 800;
    terminal_list[1].current_load = 0;

    // Load the baggage to the terminals
    Baggage baggage_list[MAX_BAGGAGE];
    baggage_list[0].id = 1;
    baggage_list[0].flight_number = 1;
    baggage_list[0].terminal_id = 1;
    baggage_list[0].weight = 100;
    baggage_list[1].id = 2;
    baggage_list[1].flight_number = 1;
    baggage_list[1].terminal_id = 2;
    baggage_list[1].weight = 200;
    baggage_list[2].id = 3;
    baggage_list[2].flight_number = 1;
    baggage_list[2].terminal_id = 1;
    baggage_list[2].weight = 300;
    baggage_list[3].id = 4;
    baggage_list[3].flight_number = 1;
    baggage_list[3].terminal_id = 2;
    baggage_list[3].weight = 400;
    baggage_list[4].id = 5;
    baggage_list[4].flight_number = 1;
    baggage_list[4].terminal_id = 1;
    baggage_list[4].weight = 500;
    int num_baggages = 5;
    for (int i = 0; i < num_baggages; i++) {
        load_baggage(&baggage_list[i], &terminal_list[baggage_list[i].terminal_id - 1]);
    }

    // Assign the terminals to the flights
    flight_list[0].terminal_list[0] = &terminal_list[0];
    flight_list[0].terminal_list[1] = &terminal_list[1];

    // Display the flight information
    printf(""Flight %d\n"", flight_list[0].number);
    printf(""Maximum Load: %d\n"", flight_list[0].capacity);
    printf(""Current Load: %d\n"", flight_list[0].current_load);
    printf(""Terminals:\n"");
    for (int i = 0; i < MAX_TERMINALS; i++) {
        if (flight_list[0].terminal_list[i] != NULL) {
            printf(""Terminal %d\n"", flight_list[0].terminal_list[i]->id);
            printf(""- Maximum Load: %d\n"", flight_list[0].terminal_list[i]->capacity);
            printf(""- Current Load: %d\n"", flight_list[0].terminal_list[i]->current_load);
            printf(""- Baggage List:\n"");
            for (int j = 0; j < MAX_BAGGAGE; j++) {
                if (flight_list[0].terminal_list[i]->baggage_list[j] != NULL) {
                    printf(""  - Baggage %d (%dkg)\n"", flight_list[0].terminal_list[i]->baggage_list[j]->id, flight_list[0].terminal_list[i]->baggage_list[j]->weight);
                }
            }
        }
    }

    return 0;
}",111,4.0
VULNERABLE,gemini_pro-36214.c,yes,34,9,create_election,"
  file gemini_pro-36214.c line 34 column 9 function create_election
","
  c:@F@create_election at file gemini_pro-36214.c line 122 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"void create_election(struct election *election) {
    // Create the candidates
    election->num_candidates = 0;
    for (int i = 0; i < MAX_CANDIDATES; i++) {
        election->candidates[i].id = i + 1;
        election->candidates[i].name = malloc(100);
        election->candidates[i].num_votes = 0;
    }

    // Create the voters
    election->num_voters = 0;","//GEMINI-pro DATASET v1.0 Category: Electronic Voting System ; Style: irregular
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_CANDIDATES 10
#define MAX_VOTERS 100

struct candidate {
    int id;
    char *name;
    int num_votes;
};

struct voter {
    int id;
    char *name;
    bool has_voted;
};

struct election {
    struct candidate candidates[MAX_CANDIDATES];
    int num_candidates;
    struct voter voters[MAX_VOTERS];
    int num_voters;
};

void create_election(struct election *election) {
    // Create the candidates
    election->num_candidates = 0;
    for (int i = 0; i < MAX_CANDIDATES; i++) {
        election->candidates[i].id = i + 1;
        election->candidates[i].name = malloc(100);
        election->candidates[i].num_votes = 0;
    }

    // Create the voters
    election->num_voters = 0;
    for (int i = 0; i < MAX_VOTERS; i++) {
        election->voters[i].id = i + 1;
        election->voters[i].name = malloc(100);
        election->voters[i].has_voted = false;
    }
}

void destroy_election(struct election *election) {
    // Free the memory allocated for the candidates
    for (int i = 0; i < MAX_CANDIDATES; i++) {
        free(election->candidates[i].name);
    }

    // Free the memory allocated for the voters
    for (int i = 0; i < MAX_VOTERS; i++) {
        free(election->voters[i].name);
    }
}

void print_election(struct election *election) {
    // Print the candidates
    printf(""Candidates:\n"");
    for (int i = 0; i < election->num_candidates; i++) {
        printf(""%d. %s\n"", election->candidates[i].id, election->candidates[i].name);
    }

    // Print the voters
    printf(""\nVoters:\n"");
    for (int i = 0; i < election->num_voters; i++) {
        printf(""%d. %s\n"", election->voters[i].id, election->voters[i].name);
    }
}

void vote(struct election *election, int voter_id, int candidate_id) {
    // Get the voter
    struct voter *voter = NULL;
    for (int i = 0; i < election->num_voters; i++) {
        if (election->voters[i].id == voter_id) {
            voter = &election->voters[i];
            break;
        }
    }

    // Check if the voter has already voted
    if (voter->has_voted) {
        printf(""Error: Voter has already voted.\n"");
        return;
    }

    // Get the candidate
    struct candidate *candidate = NULL;
    for (int i = 0; i < election->num_candidates; i++) {
        if (election->candidates[i].id == candidate_id) {
            candidate = &election->candidates[i];
            break;
        }
    }

    // Increment the candidate's vote count
    candidate->num_votes++;

    // Mark the voter as having voted
    voter->has_voted = true;
}

void get_winner(struct election *election) {
    // Find the candidate with the most votes
    int max_votes = 0;
    struct candidate *winner = NULL;
    for (int i = 0; i < election->num_candidates; i++) {
        if (election->candidates[i].num_votes > max_votes) {
            max_votes = election->candidates[i].num_votes;
            winner = &election->candidates[i];
        }
    }

    // Print the winner
    printf(""The winner is: %s\n"", winner->name);
}
int main() {
    // Create the election
    struct election election;
    create_election(&election);

    // Print the election
    print_election(&election);

    // Vote
    vote(&election, 1, 1);
    vote(&election, 2, 2);
    vote(&election, 3, 3);

    // Get the winner
    get_winner(&election);

    // Destroy the election
    destroy_election(&election);

    return 0;
}",139,3.167
VULNERABLE,falcon180b-19957.c,yes,45,9,print_table,"
  file falcon180b-19957.c line 45 column 9 function print_table
","
  c:@F@print_table at file falcon180b-19957.c line 59 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"}

void print_table(Database* db) {
    printf(""+----+-----+--------+\n"");
    for (int i = 0; i < db->num_cols; i++) {
        printf(""| %s |"", db->header[i]);
    }
    printf(""|\n"");
    for (int i = 0; i < db->num_rows; i++) {
        printf(""+----+-----+--------+\n"");
        printf(""| %s | %d | %.2f |\n"", db->rows[i].name, db->rows[i].age, db->rows[i].salary);","//Falcon-180B DATASET v1.0 Category: Database simulation ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ROWS 1000
#define MAX_COLS 100

typedef struct {
    char* name;
    int age;
    float salary;
} Record;

typedef struct {
    char* header[MAX_COLS];
    Record rows[MAX_ROWS];
    int num_rows;
    int num_cols;
} Database;

void create_table(Database* db) {
    db->num_rows = 0;
    db->num_cols = 3;
    db->header[0] = ""Name"";
    db->header[1] = ""Age"";
    db->header[2] = ""Salary"";
}

void add_record(Database* db, char* name, int age, float salary) {
    if (db->num_rows >= MAX_ROWS) {
        printf(""Error: Table is full.\n"");
        return;
    }
    Record* new_row = &db->rows[db->num_rows];
    new_row->name = strdup(name);
    new_row->age = age;
    new_row->salary = salary;
    db->num_rows++;
}

void print_table(Database* db) {
    printf(""+----+-----+--------+\n"");
    for (int i = 0; i < db->num_cols; i++) {
        printf(""| %s |"", db->header[i]);
    }
    printf(""|\n"");
    for (int i = 0; i < db->num_rows; i++) {
        printf(""+----+-----+--------+\n"");
        printf(""| %s | %d | %.2f |\n"", db->rows[i].name, db->rows[i].age, db->rows[i].salary);
    }
}

int main() {
    Database db;
    create_table(&db);
    add_record(&db, ""John Doe"", 25, 50000);
    add_record(&db, ""Jane Smith"", 30, 60000);
    print_table(&db);
    return 0;
}",61,1.75
VULNERABLE,gpt35-33841.c,yes,27,9,create_file_system,"
  file gpt35-33841.c line 27 column 9 function create_file_system
","
  c:@F@create_file_system at file gpt35-33841.c line 152 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"} file_system;

//function to create a file system
void create_file_system(file_system *fs) {
    for(int i=0;i<MAX_FILE_SYSTEM_SIZE/BLOCK_SIZE;i++) {
        fs->disk[i] = NULL;
        fs->allocation_map[i] = 0; //initially all blocks are free
    }
    for(int i=0;i<MAX_FILES;i++) {
        fs->file_list[i].name = NULL;
        fs->file_list[i].start_block = -1; //initially no files exist","//FormAI DATASET v1.0 Category: File system simulation ; Style: introspective
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_FILE_SYSTEM_SIZE 1024*1024 //1MB filesystem
#define BLOCK_SIZE 1024 //1KB block size
#define MAX_FILES 20 //maximum number of files in file system

//structure of a file
typedef struct file {
    char *name;
    int start_block;
    int end_block;
    int size;
} file;

//structure of the file system
typedef struct file_system {
    char *disk[MAX_FILE_SYSTEM_SIZE / BLOCK_SIZE]; //file system disk
    int allocation_map[MAX_FILE_SYSTEM_SIZE / BLOCK_SIZE]; //1->allocated, 0->free
    file file_list[MAX_FILES]; //list of files in file system
} file_system;

//function to create a file system
void create_file_system(file_system *fs) {
    for(int i=0;i<MAX_FILE_SYSTEM_SIZE/BLOCK_SIZE;i++) {
        fs->disk[i] = NULL;
        fs->allocation_map[i] = 0; //initially all blocks are free
    }
    for(int i=0;i<MAX_FILES;i++) {
        fs->file_list[i].name = NULL;
        fs->file_list[i].start_block = -1; //initially no files exist
    }
}

//function to allocate a block for file
int allocate_block(file_system *fs) {
    int block = -1;
    for(int i=0;i<MAX_FILE_SYSTEM_SIZE/BLOCK_SIZE;i++) {
        if(fs->allocation_map[i] == 0) {
            block = i;
            fs->allocation_map[i] = 1;
            break;
        }
    }
    return block;
}

//function to create a file in file system
void create_file(file_system *fs, char *name, int size) {
    int blocks = size / BLOCK_SIZE;
    if(size % BLOCK_SIZE != 0)
        blocks++;
    int start_block = -1;
    for(int i=0;i<MAX_FILE_SYSTEM_SIZE/BLOCK_SIZE;i++) {
        int blocks_found = 0;
        if(fs->allocation_map[i] == 0) {
            for(int j=i;j<MAX_FILE_SYSTEM_SIZE/BLOCK_SIZE;j++) {
                if(fs->allocation_map[j] == 0) {
                    blocks_found++;
                    if(blocks_found == blocks) {
                        start_block = i;
                        break;
                    }
                }
                else {
                    blocks_found = 0;
                    i = j;
                    break;
                }
            }
        }
        if(start_block != -1)
            break;
    }
    if(start_block == -1)
        printf(""ERROR: File could not be created. Not enough space in file system.\n"");
    else {
        int i;
        for(i=0;i<MAX_FILES;i++) {
            if(fs->file_list[i].name == NULL) {
                fs->file_list[i].name = strdup(name);
                fs->file_list[i].start_block = start_block;
                fs->file_list[i].end_block = start_block + blocks - 1;
                fs->file_list[i].size = size;
                break;
            }
        }
        for(int j=start_block;j<=fs->file_list[i].end_block;j++) {
            fs->disk[j] = strdup(name);
            fs->allocation_map[j] = 1;
        }
        printf(""SUCCESS: File %s created in file system with size %d.\n"", name, size);
    }
}

//function to delete a file from file system
void delete_file(file_system *fs, char *name) {
    int i;
    for(i=0;i<MAX_FILES;i++) {
        if(fs->file_list[i].name != NULL && strcmp(fs->file_list[i].name, name) == 0) {
            for(int j=fs->file_list[i].start_block;j<=fs->file_list[i].end_block;j++) {
                fs->disk[j] = NULL;
                fs->allocation_map[j] = 0;
            }
            free(fs->file_list[i].name);
            fs->file_list[i].name = NULL;
            fs->file_list[i].start_block = -1;
            printf(""SUCCESS: File %s deleted from file system.\n"", name);
            break;
        }
    }
    if(i == MAX_FILES)
        printf(""ERROR: File %s not found in file system.\n"", name);
}

//function to display file system structure
void display_file_system(file_system *fs) {
    printf(""FILE SYSTEM STRUCTURE:\n"");
    printf(""-----------------------\n"");
    printf(""File List:\n"");
    printf(""------------------------------------------------------------------------\n"");
    printf(""| %-10s | %-10s | %-10s | %-10s | %-10s |\n"",""File No."",""Name"",""Start Block"",""End Block"",""Size"");
    printf(""------------------------------------------------------------------------\n"");
    for(int i=0;i<MAX_FILES;i++) {
        if(fs->file_list[i].name != NULL) {
            printf(""| %-10d | %-10s | %-10d | %-10d | %-10d |\n"",i+1,fs->file_list[i].name,fs->file_list[i].start_block,fs->file_list[i].end_block,fs->file_list[i].size);
        }
    }
    printf(""------------------------------------------------------------------------\n"");
    printf(""Disk Structure:\n"");
    printf(""--------------------------------------------------------------------------------------\n"");
    printf(""| %-10s |"",""Block No."");
    for(int i=0;i<BLOCK_SIZE/10;i++)
        printf("" %-9d |"",i*10);
    printf(""\n--------------------------------------------------------------------------------------\n"");
    for(int i=0;i<MAX_FILE_SYSTEM_SIZE/BLOCK_SIZE;i++) {
        if(i % (BLOCK_SIZE/10) == 0)
            printf(""| %-10d |"",i);
        if(fs->disk[i] == NULL)
            printf("" %-9s |"",""FREE"");
        else
            printf("" %-9s |"",fs->disk[i]);
        if((i+1) % (BLOCK_SIZE/10) == 0)
            printf(""\n"");
    }
    printf(""--------------------------------------------------------------------------------------\n"");
}

int main() {
    file_system fs;
    create_file_system(&fs);
    int choice;
    while(1) {
        printf(""FILE SYSTEM SIMULATION\n"");
        printf(""1. Create File\n"");
        printf(""2. Delete File\n"");
        printf(""3. Display File System Structure\n"");
        printf(""4. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"",&choice);
        switch(choice) {
            case 1:
                {
                    char name[20];
                    int size;
                    printf(""Enter file name: "");
                    scanf(""%s"",name);
                    printf(""Enter file size (in bytes): "");
                    scanf(""%d"",&size);
                    create_file(&fs,name,size);
                    break;
                }
            case 2:
                {
                    char name[20];
                    printf(""Enter file name: "");
                    scanf(""%s"",name);
                    delete_file(&fs,name);
                    break;
                }
            case 3:
                {
                    display_file_system(&fs);
                    break;
                }
            case 4:
                {
                    printf(""Exiting File System Simulation...\n"");
                    exit(0);
                }
            default:
                printf(""Invalid choice. Please try again.\n"");
        }
    }
    return 0;
}",197,6.333
VULNERABLE,gemini_pro-16893.c,yes,76,9,main,"
  file pthread_lib.c line 204 column 3 function pthread_create
","
  c:@F@pthread_create at file gemini_pro-16893.c line 76 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    traffic_light_controller controller;
    init_traffic_light_controller(&controller);

    // Create the threads for the traffic lights
    for (int i = 0; i < 4; i++) {
        pthread_create(&controller.threads[i], NULL, traffic_light_thread, &controller.lights[i]);
    }

    // Join the threads
    for (int i = 0; i < 4; i++) {
        pthread_join(controller.threads[i], NULL);","//GEMINI-pro DATASET v1.0 Category: Traffic Light Controller ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

// Traffic light colors
#define RED 0
#define YELLOW 1
#define GREEN 2

// Road directions
#define NORTH 0
#define SOUTH 1
#define EAST 2
#define WEST 3

// Traffic light state
typedef struct {
    int color;
    int next_color;
    int timer;
} traffic_light;

// Traffic light controller
typedef struct {
    traffic_light lights[4];
    pthread_t threads[4];
} traffic_light_controller;

// Initialize a traffic light controller
void init_traffic_light_controller(traffic_light_controller *controller) {
    for (int i = 0; i < 4; i++) {
        controller->lights[i].color = RED;
        controller->lights[i].next_color = GREEN;
        controller->lights[i].timer = 0;
    }
}

// Change the color of a traffic light
void change_traffic_light_color(traffic_light *light, int color) {
    light->color = color;
    light->timer = 0;
}

// Thread function for a traffic light
void *traffic_light_thread(void *arg) {
    traffic_light *light = (traffic_light *)arg;

    while (1) {
        // Increment the timer
        light->timer++;

        // Change the color of the traffic light if the timer has expired
        if (light->timer >= 5) {
            change_traffic_light_color(light, light->next_color);
            // Change the next color
            light->next_color = (light->next_color + 1) % 3;
        }

        // Sleep for 1 second
        sleep(1);
    }

    return NULL;
}

// Main function
int main() {
    // Initialize the traffic light controller
    traffic_light_controller controller;
    init_traffic_light_controller(&controller);

    // Create the threads for the traffic lights
    for (int i = 0; i < 4; i++) {
        pthread_create(&controller.threads[i], NULL, traffic_light_thread, &controller.lights[i]);
    }

    // Join the threads
    for (int i = 0; i < 4; i++) {
        pthread_join(controller.threads[i], NULL);
    }

    return 0;
}",85,2.25
VULNERABLE,gpt35-14543.c,yes,36,9,compute_checksum,"
  file gpt35-14543.c line 36 column 9 function compute_checksum
","
  c:@F@compute_checksum at file gpt35-14543.c line 190 column 27 function traceroute
  c:@F@traceroute at file gpt35-14543.c line 296 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    uint16_t* p = (uint16_t*)data;
    uint16_t checksum = 0;
    size_t i;

    for (i = 0; i < (len / 2); i++)
        checksum += p[i];

    if (len % 2 != 0)
        checksum += *((uint8_t*)data + len - 1);

    while (checksum >> 16)","//FormAI DATASET v1.0 Category: Network Ping Test ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <time.h>

#define ICMP_PACKET_SIZE 64
#define ICMP_HEADER_SIZE 8
#define MAX_HOPS 30

// ICMP packet structure
typedef struct icmp_packet
{
    uint8_t type; // ICMP packet type
    uint8_t code; // ICMP packet code
    uint16_t checksum; // ICMP packet checksum
    uint16_t id; // ICMP packet identifier
    uint16_t sequence_number; // ICMP packet sequence number
} icmp_packet_t;

// Calculates the checksum of the ICMP packet
uint16_t compute_checksum(void* data, size_t len)
{
    uint16_t* p = (uint16_t*)data;
    uint16_t checksum = 0;
    size_t i;

    for (i = 0; i < (len / 2); i++)
        checksum += p[i];

    if (len % 2 != 0)
        checksum += *((uint8_t*)data + len - 1); 

    while (checksum >> 16)
        checksum = (checksum & 0xFFFF) + (checksum >> 16);

    return (uint16_t)(~checksum);
}

// Sends an ICMP packet to a given host
void ping_host(char* hostname)
{
    struct hostent* host;
    struct sockaddr_in address;
    icmp_packet_t packet;
    ssize_t bytes_received;
    uint8_t buffer[ICMP_PACKET_SIZE];
    int timeout = 3000; // 3 second timeout

    // Get the IP address of the host
    host = gethostbyname(hostname);
    if (host == NULL)
    {
        fprintf(stderr, ""Failed to resolve hostname: %s\n"", hostname);
        return;
    }

    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_port = htons(0);
    memcpy(&address.sin_addr, host->h_addr, host->h_length);

    // Create a raw socket for ICMP packets
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0)
    {
        fprintf(stderr, ""Failed to create socket: %s\n"", strerror(errno));
        return;
    }

    // Configure the ICMP packet
    memset(&packet, 0, sizeof(packet));
    packet.type = 8; // echo request
    packet.code = 0; // zero code for echo request
    packet.id = htons((uint16_t)getpid()); // unique identifier
    packet.sequence_number = htons(1); // start with sequence number 1
    packet.checksum = compute_checksum(&packet, sizeof(packet));

    // Send the ICMP packet to the host
    clock_t start_time = clock();
    int bytes_sent = sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr*)&address, sizeof(address));
    if (bytes_sent < 0)
    {
        fprintf(stderr, ""Failed to send packet: %s\n"", strerror(errno));
        close(sockfd);
        return;
    }

    // Wait for the response ICMP packet
    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(sockfd, &readfds);
    struct timeval timeout_val;
    timeout_val.tv_sec = timeout / 1000;
    timeout_val.tv_usec = (timeout % 1000) * 1000;
    int select_retval = select(sockfd + 1, &readfds, NULL, NULL, &timeout_val);
    if (select_retval == -1)
    {
        fprintf(stderr, ""Failed to select: %s\n"", strerror(errno));
        close(sockfd);
        return;
    }
    else if (select_retval == 0)
    {
        printf(""***HOST %s NOT RESPONDING***\n"", hostname);
        close(sockfd);
        return;
    }

    // Receive the ICMP packet response
    bytes_received = recv(sockfd, buffer, ICMP_PACKET_SIZE, 0);
    if (bytes_received < 0)
    {
        fprintf(stderr, ""Failed to receive packet: %s\n"", strerror(errno));
        close(sockfd);
        return;
    }

    // Extract the type and code from the response packet
    icmp_packet_t* response_packet = (icmp_packet_t*)buffer;
    uint8_t response_type = response_packet->type;
    uint8_t response_code = response_packet->code;

    // Calculate the round-trip time and print it
    clock_t end_time = clock();
    double elapsed_time = ((double)(end_time - start_time)) / CLOCKS_PER_SEC * 1000.0;
    printf(""%-20s PING %d bytes: time=%.2f ms\n"", hostname, bytes_received - ICMP_HEADER_SIZE, elapsed_time);

    close(sockfd);
}

// Traces a route to a given host
void traceroute(char* hostname)
{
    struct hostent* host;
    struct sockaddr_in address;
    icmp_packet_t packet;
    ssize_t bytes_received;
    uint8_t buffer[ICMP_PACKET_SIZE];
    int timeout = 3000; // 3 second timeout
    int ttl = 1;
    int should_exit = 0;

    // Get the IP address of the host
    host = gethostbyname(hostname);
    if (host == NULL)
    {
        fprintf(stderr, ""Failed to resolve hostname: %s\n"", hostname);
        return;
    }

    // Create a raw socket for ICMP packets
    int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd < 0)
    {
        fprintf(stderr, ""Failed to create socket: %s\n"", strerror(errno));
        return;
    }

    // Set the TTL option for the socket
    if (setsockopt(sockfd, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl)) < 0)
    {
        fprintf(stderr, ""Failed to set TTL option: %s\n"", strerror(errno));
        close(sockfd);
        return;
    }

    // Output the header for the traceroute
    printf(""Tracing route to %s [%s]\n"", hostname, inet_ntoa(*(struct in_addr*)host->h_addr));

    // Loop until we reach the destination or the maximum hop count
    while (!should_exit && ttl <= MAX_HOPS)
    {
        int i;
        int bytes_sent;

        // Configure the ICMP packet
        memset(&packet, 0, sizeof(packet));
        packet.type = 8; // echo request
        packet.code = 0; // zero code for echo request
        packet.id = htons((uint16_t)getpid()); // unique identifier
        packet.sequence_number = htons(1); // start with sequence number 1
        packet.checksum = compute_checksum(&packet, sizeof(packet));

        // Set the TTL for the socket
        if (setsockopt(sockfd, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl)) < 0)
        {
            fprintf(stderr, ""Failed to set TTL option: %s\n"", strerror(errno));
            close(sockfd);
            return;
        }

        // Send the ICMP packet to the host
        clock_t start_time = clock();
        bytes_sent = sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr*)&address, sizeof(address));
        if (bytes_sent < 0)
        {
            fprintf(stderr, ""Failed to send packet: %s\n"", strerror(errno));
            close(sockfd);
            return;
        }

        // Wait for the response ICMP packet
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(sockfd, &readfds);
        struct timeval timeout_val;
        timeout_val.tv_sec = timeout / 1000;
        timeout_val.tv_usec = (timeout % 1000) * 1000;
        int select_retval = select(sockfd + 1, &readfds, NULL, NULL, &timeout_val);
        if (select_retval == -1)
        {
            fprintf(stderr, ""Failed to select: %s\n"", strerror(errno));
            close(sockfd);
            return;
        }
        else if (select_retval == 0)
        {
            printf(""%2d  * * *\n"", ttl);
            ttl++;
            continue;
        }

        // Receive the ICMP packet response
        bytes_received = recv(sockfd, buffer, ICMP_PACKET_SIZE, 0);
        if (bytes_received < 0)
        {
            fprintf(stderr, ""Failed to receive packet: %s\n"", strerror(errno));
            close(sockfd);
            return;
        }

        // Extract the type and code from the response packet
        icmp_packet_t* response_packet = (icmp_packet_t*)buffer;
        uint8_t response_type = response_packet->type;
        uint8_t response_code = response_packet->code;

        // Calculate the round-trip time and print it
        clock_t end_time = clock();
        double elapsed_time = ((double)(end_time - start_time)) / CLOCKS_PER_SEC * 1000.0;

        // Print the hop information
        struct in_addr hop_address;
        memset(&hop_address, 0, sizeof(struct in_addr));
        memcpy(&hop_address.s_addr, buffer + ICMP_HEADER_SIZE + 12, sizeof(struct in_addr));
        printf(""%2d  %s (%s)  %d ms\n"", ttl, host->h_name, inet_ntoa(hop_address), (int)elapsed_time);

        // Check if we have reached the destination
        if (response_type == 0 && response_code == 0)
        {
            should_exit = 1;
        }

        ttl++;
    }

    close(sockfd);
}

// Main entry point of the program
int main(int argc, char* argv[])
{
    // Check the command-line arguments
    if (argc < 2)
    {
        printf(""Usage: %s [options] destination\n\n"", argv[0]);
        printf(""Options:\n"");
        printf(""  -p    Run a ping test instead of a traceroute\n"");
        return 1;
    }

    int use_ping = 0;

    // Parse the command-line arguments
    for (int i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], ""-p"") == 0)
            use_ping = 1;
        else
            break;
    }

    char* destination = argv[argc - 1];

    // Run the appropriate test
    if (use_ping)
        ping_host(destination);
    else
        traceroute(destination);

    return 0;
}",299,7.25
VULNERABLE,gpt35-11289.c,yes,32,19,calculate_checksum,"
  file gpt35-11289.c line 32 column 19 function calculate_checksum
","
  c:@F@calculate_checksum at file gpt35-11289.c line 55 column 28 function send_ping_packet
  c:@F@send_ping_packet at file gpt35-11289.c line 151 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    uint16_t *p = (uint16_t *)data;
    uint16_t answer = 0;
    size_t i;

    for (i = 0; i < len - 1; i += 2) {
        answer += htons(p[i/2]);
    }

    if (i == len - 1) {
        uint16_t tmp = htons(data[len - 1]);
        answer += tmp;","//FormAI DATASET v1.0 Category: Network Ping Test ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/time.h>

#define PING_PACKET_SIZE 64
#define PORT_NUMBER 0
#define MAX_PACK_SIZE 1024
#define MAX_TIMEOUT 1

struct icmp_echo_packet {
    unsigned char type;
    unsigned char code;
    unsigned short checksum;
    unsigned short identifier;
    unsigned short seq_no;
};

uint16_t calculate_checksum(uint8_t *data, size_t len)
{
    uint16_t *p = (uint16_t *)data;
    uint16_t answer = 0;
    size_t i;

    for (i = 0; i < len - 1; i += 2) {
        answer += htons(p[i/2]);
    }

    if (i == len - 1) {
        uint16_t tmp = htons(data[len - 1]);
        answer += tmp;
    }

    answer = (answer >> 16) + (answer & 0xffff);
    answer += (answer >> 16);

    return ~answer;
}

void send_ping_packet(int sockfd, const struct sockaddr *dest_addr, uint16_t seq_no)
{
    struct icmp_echo_packet icmp_packet;
    size_t icmp_packet_size = sizeof(icmp_packet);

    memset(&icmp_packet, 0x00, icmp_packet_size);

    icmp_packet.type = 8;
    icmp_packet.code = 0;
    icmp_packet.checksum = calculate_checksum((uint8_t *)&icmp_packet, icmp_packet_size);
    icmp_packet.seq_no = htons(seq_no);
    icmp_packet.identifier = htons(getpid());

    if (sendto(sockfd, &icmp_packet, icmp_packet_size, 0, dest_addr, sizeof(*dest_addr)) < 0) {
        perror(""sendto"");
    } else {
        printf(""Request Packet sent...\n"");
    }
}

double calculate_time_diff(struct timeval start, struct timeval end)
{
    return ((double)(end.tv_sec - start.tv_sec) * 1000.0) + ((double)(end.tv_usec - start.tv_usec) / 1000.0);
}

void receive_ping_packet(int sockfd, struct sockaddr *src_addr, uint16_t seq_no)
{
    struct icmp_echo_packet recv_buff[MAX_PACK_SIZE];
    size_t recv_buff_size = sizeof(recv_buff);
    struct timeval time_sent, time_recv;
    double rtt;
    socklen_t src_addr_len;
    fd_set readfds;

    FD_ZERO(&readfds);
    FD_SET(sockfd, &readfds);

    struct timeval timeout;
    timeout.tv_sec = MAX_TIMEOUT;
    timeout.tv_usec = 0;

    int ready = select(sockfd + 1, &readfds, NULL, NULL, &timeout);
    switch (ready) {
        case -1:
            perror(""select error"");
            break;

        case 0:
            printf(""Timeout error: no packet received.\n"");
            break;

        default:
            if (FD_ISSET(sockfd, &readfds)) {
                if (recvfrom(sockfd, &recv_buff, recv_buff_size, 0, src_addr, &src_addr_len) < 0) {
                    perror(""recvfrom"");
                } else {
                    gettimeofday(&time_recv, NULL);
                    struct icmp_echo_packet *recv_packet = (struct icmp_echo_packet *)recv_buff;
                    if (ntohs(recv_packet->seq_no) == seq_no && ntohs(recv_packet->identifier) == getpid()) {
                        rtt = calculate_time_diff(time_sent, time_recv);
                        printf(""Reply Packet received in %.3f ms\n"", rtt);
                    } else {
                        printf(""Received packet is not for this task.\n"");
                    }
                }
            }
            break;
    }
}

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, ""Usage: <Program Name> <IP Address>\n"");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in dest_addr;
    struct hostent *host_ptr;
    int sockfd;
    int ttl_val = 64;
    uint16_t seq_no = 0;

    if ((host_ptr = gethostbyname(argv[1])) == NULL) {
        perror(""gethostbyname"");
        exit(EXIT_FAILURE);
    }

    memset(&dest_addr, 0x00, sizeof(dest_addr));
    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(PORT_NUMBER);
    dest_addr.sin_addr = *((struct in_addr *)host_ptr->h_addr);

    if ((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    if (setsockopt(sockfd, IPPROTO_IP, IP_TTL, &ttl_val, sizeof(ttl_val))) {
        perror(""setsockopt"");
        exit(EXIT_FAILURE);
    }

    while (1) {
        seq_no++;
        send_ping_packet(sockfd, (struct sockaddr *)&dest_addr, seq_no);
        receive_ping_packet(sockfd, (struct sockaddr *)&dest_addr, seq_no);
        sleep(2);
    }

    return 0;
}",157,3.8
VULNERABLE,gemma7b-10221.c,yes,37,44,csv_reader_read,"
  file gemma7b-10221.c line 37 column 44 function csv_reader_read
","
  c:@F@csv_reader_read at file gemma7b-10221.c line 61 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
    while (getline(&line, &line_size, reader->file) != -1)
    {
        reader->rows++;
        reader->buffer = realloc(reader->buffer, reader->rows * MAX_BUFFER_SIZE);
        reader->buffer[reader->rows - 1] = strdup(line);

        for (i = 0; i < line_size; i++)
        {
            if (line[i] == ',')
            {","//Gemma-7B DATASET v1.0 Category: Building a CSV Reader ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

typedef struct CSVReader
{
    FILE* file;
    char** buffer;
    int rows;
    int cols;
} CSVReader;

CSVReader* csv_reader_init(const char* filename)
{
    CSVReader* reader = malloc(sizeof(CSVReader));
    reader->file = fopen(filename, ""r"");
    reader->buffer = NULL;
    reader->rows = 0;
    reader->cols = 0;

    return reader;
}

void csv_reader_read(CSVReader* reader)
{
    char* line = NULL;
    size_t line_size = 0;
    int i = 0;

    while (getline(&line, &line_size, reader->file) != -1)
    {
        reader->rows++;
        reader->buffer = realloc(reader->buffer, reader->rows * MAX_BUFFER_SIZE);
        reader->buffer[reader->rows - 1] = strdup(line);

        for (i = 0; i < line_size; i++)
        {
            if (line[i] == ',')
            {
                reader->cols++;
            }
        }
    }

    free(line);
}

void csv_reader_destroy(CSVReader* reader)
{
    fclose(reader->file);
    free(reader->buffer);
    free(reader);
}

int main()
{
    CSVReader* reader = csv_reader_init(""data.csv"");
    csv_reader_read(reader);
    csv_reader_destroy(reader);

    return 0;
}",65,1.75
VULNERABLE,gpt35-30040.c,yes,32,13,initialize_database,"
  file gpt35-30040.c line 32 column 13 function initialize_database
","
  c:@F@initialize_database at file gpt35-30040.c line 62 column 5 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    int i, j;
    for(i = 0; i < MAX_INDEX; i++) {
        db->index[i].letter = 'A' + i;
        db->index[i].count = 0;
        for(j = 0; j < 10; j++) {
            db->index[i].entries[j] = NULL;
        }
    }
    db->count = 0;
}
","//FormAI DATASET v1.0 Category: Database Indexing System ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>

#define MAX_ENTRIES 1000      // Maximum number of entries in the database
#define MAX_INDEX 26          // Maximum number of index entries (A-Z)

struct entry {
    int id;
    char name[50];
    int age;
};

struct index_entry {
    char letter;             // The letter that the entry is indexed by
    struct entry *entries[10];  // Array of pointers to entries
    int count;               // Number of entries currently in the index
};

struct database {
    struct entry entries[MAX_ENTRIES];      // Array of entries in the database
    struct index_entry index[MAX_INDEX];    // Array of index entries
    int count;                              // Number of entries currently in the database
};

void initialize_database(struct database *db) {
    int i, j;
    for(i = 0; i < MAX_INDEX; i++) {
        db->index[i].letter = 'A' + i;
        db->index[i].count = 0;
        for(j = 0; j < 10; j++) {
            db->index[i].entries[j] = NULL;
        }
    }
    db->count = 0;
}

void add_entry(struct database *db, int id, char *name, int age) {
    int index = name[0] - 'A';
    if(db->index[index].count < 10) {
        struct entry *e = (struct entry*)malloc(sizeof(struct entry));
        e->id = id;
        sprintf(e->name, ""%s"", name);
        e->age = age;
        
        db->index[index].entries[db->index[index].count] = e;
        db->index[index].count++;
        db->entries[db->count] = *e;
        db->count++;
    }
}

void print_entries(struct database *db) {
    int i;
    for(i = 0; i < db->count; i++) {
        printf(""ID: %d, Name: %s, Age: %d\n"", db->entries[i].id, db->entries[i].name, db->entries[i].age);
    }
}

int main() {
    struct database db;
    initialize_database(&db);
    
    add_entry(&db, 1, ""Alice"", 25);
    add_entry(&db, 2, ""Bob"", 30);
    add_entry(&db, 3, ""Charlie"", 20);
    add_entry(&db, 4, ""Dave"", 35);
    
    print_entries(&db);
    
    return 0;
}",72,2.0
VULNERABLE,gemini_pro-6589.c,yes,80,9,send_icmp_packet,"
  file gemini_pro-6589.c line 80 column 9 function send_icmp_packet
","
  c:@F@send_icmp_packet at file gemini_pro-6589.c line 143 column 9 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"
    // Calculate the ICMP checksum
    int checksum_len = sizeof(packet.header) + sizeof(packet.data);
    uint32_t checksum = 0;
    for (int i = 0; i < checksum_len; i += 2) {
        checksum += *(uint16_t *)((uint8_t *)&packet + i);
    }
    checksum = (checksum >> 16) + (checksum & 0xFFFF);
    checksum += (checksum >> 16);
    packet.header.checksum = ~htons(checksum);
","//GEMINI-pro DATASET v1.0 Category: Network Ping Test ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <signal.h>
#include <errno.h>
#include <time.h>

#define MAX_HOPS 30
#define MAX_PACKET_SIZE 1024
#define ICMP_ECHO_REQUEST 8
#define ICMP_ECHO_REPLY 0
#define ICMP_MAX_ECHO_DATA_SIZE 56

// ICMP header structure
struct icmp_header {
    uint8_t type;
    uint8_t code;
    uint16_t checksum;
    uint16_t identifier;
    uint16_t sequence_number;
    uint8_t data[ICMP_MAX_ECHO_DATA_SIZE];
};

// ICMP packet structure
struct icmp_packet {
    struct icmp_header header;
    uint8_t data[MAX_PACKET_SIZE - sizeof(struct icmp_header)];
};

// Process a received ICMP packet
void process_icmp_packet(struct icmp_packet *packet, socklen_t addr_len, struct sockaddr *addr) {
    // Check if the ICMP packet is an ICMP echo reply
    if (packet->header.type != ICMP_ECHO_REPLY) {
        printf(""Received non-ICMP echo reply packet.\n"");
        return;
    }

    // Print the IP address and port of the sender
    char addr_str[INET6_ADDRSTRLEN];
    if (addr->sa_family == AF_INET) {
        struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
        inet_ntop(AF_INET, &addr_in->sin_addr, addr_str, sizeof(addr_str));
        printf(""Received ICMP echo reply from %s:%d\n"", addr_str, ntohs(addr_in->sin_port));
    } else if (addr->sa_family == AF_INET6) {
        struct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;
        inet_ntop(AF_INET6, &addr_in6->sin6_addr, addr_str, sizeof(addr_str));
        printf(""Received ICMP echo reply from %s:%d\n"", addr_str, ntohs(addr_in6->sin6_port));
    } else {
        printf(""Received ICMP echo reply from unknown address type.\n"");
    }

    // Print the sequence number and timestamp of the ICMP packet
    printf(""Sequence number: %d\n"", ntohs(packet->header.sequence_number));
    printf(""Received time: %ld ms\n"", (time(NULL) - packet->header.identifier) * 1000);
}

// Send an ICMP echo request packet
int send_icmp_packet(int sockfd, struct sockaddr *addr, socklen_t addr_len, int identifier, int sequence_number) {
    // Create an ICMP packet
    struct icmp_packet packet;
    memset(&packet, 0, sizeof(packet));

    // Fill in the ICMP header
    packet.header.type = ICMP_ECHO_REQUEST;
    packet.header.code = 0;
    packet.header.checksum = 0;
    packet.header.identifier = htons(identifier);
    packet.header.sequence_number = htons(sequence_number);

    // Calculate the ICMP checksum
    int checksum_len = sizeof(packet.header) + sizeof(packet.data);
    uint32_t checksum = 0;
    for (int i = 0; i < checksum_len; i += 2) {
        checksum += *(uint16_t *)((uint8_t *)&packet + i);
    }
    checksum = (checksum >> 16) + (checksum & 0xFFFF);
    checksum += (checksum >> 16);
    packet.header.checksum = ~htons(checksum);

    // Send the ICMP packet
    if (sendto(sockfd, &packet, sizeof(packet), 0, addr, addr_len) < 0) {
        perror(""sendto"");
        return -1;
    }

    return 0;
}

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, ""Usage: %s <hostname or IP address>\n"", argv[0]);
        return EXIT_FAILURE;
    }

    // Create a raw socket for sending and receiving ICMP packets
    int sockfd = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
    if (sockfd < 0) {
        perror(""socket"");
        return EXIT_FAILURE;
    }

    // Set the socket options
    int on = 1;
    if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on, sizeof(on)) < 0) {
        perror(""setsockopt"");
        return EXIT_FAILURE;
    }

    // Resolve the hostname or IP address
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET6;
    hints.ai_socktype = SOCK_RAW;
    hints.ai_protocol = IPPROTO_ICMPV6;
    struct addrinfo *addr_info;
    if (getaddrinfo(argv[1], NULL, &hints, &addr_info) != 0) {
        perror(""getaddrinfo"");
        return EXIT_FAILURE;
    }

    // Get the destination address
    struct sockaddr *addr = addr_info->ai_addr;
    socklen_t addr_len = addr_info->ai_addrlen;

    // Set a timeout for receiving ICMP packets
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
        perror(""setsockopt"");
        return EXIT_FAILURE;
    }

    // Send an ICMP echo request packet
    int identifier = getpid();
    int sequence_number = 0;
    if (send_icmp_packet(sockfd, addr, addr_len, identifier, sequence_number) < 0) {
        return EXIT_FAILURE;
    }

    // Receive an ICMP echo reply packet
    struct icmp_packet packet;
    struct sockaddr addr_recv;
    socklen_t addr_recv_len = sizeof(addr_recv);
    if (recvfrom(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&addr_recv, &addr_recv_len) >= 0) {
        process_icmp_packet(&packet, addr_recv_len, &addr_recv);
    } else {
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            printf(""Timeout: no ICMP echo reply received.\n"");
        } else {
            perror(""recvfrom"");
            return EXIT_FAILURE;
        }
    }

    // Close the socket
    close(sockfd);

    return EXIT_SUCCESS;
}",166,5.667
VULNERABLE,gpt35-29981.c,yes,249,9,perform_traceroute,"
  file gpt35-29981.c line 249 column 9 function perform_traceroute
","
  c:@F@perform_traceroute at file gpt35-29981.c line 321 column 12 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    {
        printf(""%d.\t"", i);

        /* Set hop IP address */
        hop_ip[i-1].byte1 = hop_ip[i-1].byte2 = hop_ip[i-1].byte3 = hop_ip[i-1].byte4 = 0;
        ping_addr.sin_addr.s_addr = *((unsigned int *)(&hop_ip[i - 1]));

        for (j = 0; j < MAX_TRIES; j++)
        {
            send_ping(ping_sockfd, &ping_addr, &icmp_req, i);
","//FormAI DATASET v1.0 Category: Network Ping Test ; Style: secure
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>

#define ICMP_ECHO_REQ 8 /* Type of ICMP requests */

#define PACKET_SIZE 64 /* Packet size for sending/receiving ICMP messages */

#define MAX_HOP 64 /* Maximum hops in traceroute */

#define MAX_TRIES 3 /* Maximum number of tries for each hop */

#define TIMEOUT_SEC 5 /* Time out for each try in seconds */

#define DEFAULT_PORT 0 /* Default port (0 = automatic) */

/* ICMP packet header structure */
struct icmp_header 
{
    unsigned char type; /* ICMP message type */
    unsigned char code; /* ICMP message sub-type */
    unsigned short checksum; /* ICMP header checksum */
    unsigned short id; /* ICMP packet ID (process ID) */
    unsigned short sequence; /* ICMP packet sequence number */
    struct timeval timestamp; /* ICMP packet timestamp */
};

/* IP address structure */
struct ip_address 
{
    unsigned char byte1;
    unsigned char byte2;
    unsigned char byte3;
    unsigned char byte4;
};

char *dns_lookup(char *, struct sockaddr_in *);
void send_ping(int, struct sockaddr_in *, struct icmp_header *, int);
struct timeval recv_ping(int, struct sockaddr_in *, struct ip_address *, int);
int icmp_checksum(struct icmp_header *, int);
int perform_traceroute(char *, int);
void print_error(char *);

/* Converts an IP address from dotted decimal notation to a struct ip_address */
int get_ip_address(char *ip_str, struct ip_address *ipaddr) 
{
    if (ipaddr == NULL) 
    {
        return -1;
    }

    if (inet_aton(ip_str, (struct in_addr *)ipaddr) == 0) 
    {
        return -1;
    }

    return 0;
}

/* Converts an IP address from a struct ip_address to dotted decimal notation */
void print_ip_address(struct ip_address ip) 
{
    printf(""%d.%d.%d.%d"", ip.byte1, ip.byte2, ip.byte3, ip.byte4);
}

/* Looks up a domain name and retrieves its IP address */
char *dns_lookup(char *host_ip, struct sockaddr_in *hostaddr) 
{
    struct hostent *host_entities;
    char *hostname = malloc(MAX_HOP), *ipaddr = malloc(MAX_HOP);

    if (get_ip_address(host_ip, (struct ip_address *)hostaddr) == 0) 
    {
        strcpy(ipaddr, host_ip);
        return ipaddr;
    }

    if ((host_entities = gethostbyaddr((char *)hostaddr, sizeof(struct sockaddr_in), AF_INET)) == NULL) 
    {
        return NULL;
    }

    strcpy(hostname, host_entities->h_name);
    strcpy(ipaddr, inet_ntoa(*(struct in_addr *)host_entities->h_addr));

    return ipaddr;
}

/* Sends an ICMP echo request */
void send_ping(int ping_sockfd, struct sockaddr_in *ping_addr, struct icmp_header *icmp_pkt, int sequence_no) 
{
    int pkt_size = 0;

    icmp_pkt->type = ICMP_ECHO_REQ;
    icmp_pkt->code = 0;
    icmp_pkt->id = getpid();

    /* Set packet timestamp */
    if (gettimeofday(&(icmp_pkt->timestamp), NULL) == -1) 
    {
        perror(""gettimeofday"");
        exit(EXIT_FAILURE);
    }

    icmp_pkt->sequence = sequence_no;
    icmp_pkt->checksum = icmp_checksum(icmp_pkt, sizeof(struct icmp_header));

    pkt_size = sendto(ping_sockfd, icmp_pkt, PACKET_SIZE, 0, (struct sockaddr *)ping_addr, sizeof(struct sockaddr_in));

    if (pkt_size == -1) 
    {
        perror(""sendto"");
        exit(EXIT_FAILURE);
    }
}

/* Receives an ICMP echo reply */
struct timeval recv_ping(int ping_sockfd, struct sockaddr_in *ping_addr, struct ip_address *ipaddr, int sequence_no) 
{
    struct timeval recv_time, timeout;

    timeout.tv_sec = TIMEOUT_SEC;
    timeout.tv_usec = 0;

    fd_set read_fds;
    FD_ZERO(&read_fds);
    FD_SET(ping_sockfd, &read_fds);

    int select_result = select(ping_sockfd + 1, &read_fds, NULL, NULL, &timeout);
    if (select_result == -1) 
    {
        perror(""select"");
        exit(EXIT_FAILURE);
    } 
    else if (select_result == 0) 
    {
        printf(""*\t"");
        fflush(stdout);
        return timeout;
    }

    struct sockaddr_in res_addr;
    socklen_t len = sizeof(res_addr);
    unsigned char recv_buf[PACKET_SIZE];
    int recv_size, iphdr_len;

    if ((recv_size = recvfrom(ping_sockfd, recv_buf, PACKET_SIZE, 0, (struct sockaddr *)&res_addr, &len)) == -1) 
    {
        perror(""recvfrom"");
        exit(EXIT_FAILURE);
    }

    /* Get IP header length */
    iphdr_len = (int)(((unsigned char)recv_buf[0]) & 0x0F) << 2;

    /* Fill in the IP address of the hop */
    ipaddr->byte1 = (unsigned char)recv_buf[iphdr_len + 12];
    ipaddr->byte2 = (unsigned char)recv_buf[iphdr_len + 13];
    ipaddr->byte3 = (unsigned char)recv_buf[iphdr_len + 14];
    ipaddr->byte4 = (unsigned char)recv_buf[iphdr_len + 15];

    /* Fill in the timestamp of the received packet */
    if (gettimeofday(&recv_time, NULL) == -1) 
    {
        perror(""gettimeofday"");
        exit(EXIT_FAILURE);
    }

    /* Print the time taken by the received packet to reach the host */
    long int rtt = (recv_time.tv_sec - ((struct icmp_header *)recv_buf)->timestamp.tv_sec) * 1000000L + (recv_time.tv_usec - ((struct icmp_header *)recv_buf)->timestamp.tv_usec);
    printf(""%ld.%03lds\t"", rtt / 1000, rtt % 1000);
    fflush(stdout);

    return recv_time;
}

/* Calculates the checksum of an ICMP packet */
int icmp_checksum(struct icmp_header *icmp_pkt, int pkt_size) 
{
    unsigned short *buf = (unsigned short *)icmp_pkt;
    unsigned int sum = 0;

    /* Calculate checksum using 16-bit words */
    for (sum = 0; pkt_size > 1; pkt_size -= 2) 
    {
        sum += *buf++;

        if (sum & 0x80000000)
        {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }
    }

    if (pkt_size == 1)
    {
        sum += *(unsigned char *)buf;
    }

    while (sum >> 16)
    {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    /* Take one's complement of the sum */
    return ~sum;
}

/* Performs a traceroute to a given IP address or domain */
int perform_traceroute(char *ip_addr, int port) 
{
    int i, j, ping_sockfd;
    struct sockaddr_in ping_addr;
    struct ip_address hop_ip[MAX_HOP];
    struct icmp_header icmp_req;
    struct timeval recv_time;

    if ((ping_sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_ICMP)) == -1) 
    {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    if (port == DEFAULT_PORT) 
    {
        port = (getuid() != 0) ? 1023 : 0;
    }

    memset(&ping_addr, 0, sizeof(ping_addr));
    ping_addr.sin_family = AF_INET;
    ping_addr.sin_port = htons(port);

    char *host_name = dns_lookup(ip_addr, &ping_addr);
    printf(""Traceroute to %s (%s), %d hops max\n"", host_name, ip_addr, MAX_HOP);
    fflush(stdout);

    for (i = 1; i <= MAX_HOP; i++) 
    {
        printf(""%d.\t"", i);

        /* Set hop IP address */
        hop_ip[i-1].byte1 = hop_ip[i-1].byte2 = hop_ip[i-1].byte3 = hop_ip[i-1].byte4 = 0;
        ping_addr.sin_addr.s_addr = *((unsigned int *)(&hop_ip[i - 1]));

        for (j = 0; j < MAX_TRIES; j++) 
        {
            send_ping(ping_sockfd, &ping_addr, &icmp_req, i);

            /* Receive ICMP echo replies */
            recv_time = recv_ping(ping_sockfd, &ping_addr, &hop_ip[i-1], i);

            /* Check if the ICMP packet is a reply to a transmitted packet */
            if (icmp_req.id == getpid() && icmp_req.sequence == i) 
            {
                break;
            }
        }

        printf(""\n"");

        /* Exit if it's the final destination */
        if (hop_ip[i-1].byte1 == ((struct sockaddr_in *)&ping_addr)->sin_addr.s_addr >> 24
            && hop_ip[i-1].byte2 == (((struct sockaddr_in *)&ping_addr)->sin_addr.s_addr & 0x00FFFFFF) >> 16) 
        {
            break;
        }
    }

    close(ping_sockfd);
    return 0;
}

/* Prints errors */
void print_error(char *progname) 
{
    fprintf(stderr, ""Usage: %s [-p port] hostname/IPaddress\n"", progname);
}

/* Main function */
int main(int argc, char **argv) 
{
    int port = DEFAULT_PORT;
    char *progname = argv[0];

    /* Parse command line arguments */
    int i;
    for (i = 1; i < argc; ++i) 
    {
        if (strcmp(argv[i], ""-p"") == 0) 
        {
            if (++i < argc) 
            {
                port = atoi(argv[i]);
            } 
            else 
            {
                print_error(progname);
                return -1;
            }
        } 
        else 
        {
            break;
        }
    }

    if (i < argc - 1) 
    {
        print_error(progname);
        return -1;
    }

    char *ip_addr = argv[argc-1];

    return perform_traceroute(ip_addr, port);
}",322,4.0
VULNERABLE,gpt35-67438.c,yes,27,17,evaluate,"
  file gpt35-67438.c line 27 column 17 function evaluate
","
  c:@F@evaluate at file gpt35-67438.c line 71 column 60 function main
  c:@F@main
  dereference failure: Oversized field offset",dereference failure: Oversized field offset,"    int i, j, k, out, in[2], res[MAXGATES];
    for (i = 0; i < c->num_gates; i++) {
        in[0] = in[1] = -1;
        for (j = 0; j < c->num_gates; j++) {
            for (k = 0; k < 2; k++) {
                if (c->gates_wired[j][k] == i) {
                    in[k] = j;
                }
            }
        }
        if (in[0] == -1 || in[1] == -1) {","//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: single-threaded
#include <stdio.h>
#include <stdlib.h>
#define MAXGATES 10
#define MAXWIRES 30

typedef struct Gate {
    int input[2];
    int output;
    char op;
} Gate;

typedef struct Circuit {
    int num_wires;
    int num_gates;
    int gates_wired[MAXGATES][2];
    Gate gates[MAXGATES];
} Circuit;

int evaluate(Circuit *c, int *vals)
{
    int i, j, k, out, in[2], res[MAXGATES];
    for (i = 0; i < c->num_gates; i++) {
        in[0] = in[1] = -1;
        for (j = 0; j < c->num_gates; j++) {
            for (k = 0; k < 2; k++) {
                if (c->gates_wired[j][k] == i) {
                    in[k] = j;
                }
            }
        }
        if (in[0] == -1 || in[1] == -1) {
            out = vals[c->gates[i].input[0]];
        } else {
            out = c->gates[in[0]].output;
            switch (c->gates[i].op) {
                case '&':
                    out &= c->gates[in[1]].output; break;
                case '|':
                    out |= c->gates[in[1]].output; break;
                case '^':
                    out ^= c->gates[in[1]].output; break;
            }
        }
        res[i] = out;
    }
    for (i = 0; i < c->num_gates; i++) {
        c->gates[i].output = res[i];
    }
    return c->gates[c->num_gates - 1].output;
}

int main()
{
    Circuit c;
    c.num_wires = 3;
    c.num_gates = 2;
    c.gates[0].input[0] = 0;
    c.gates[0].input[1] = 1;
    c.gates[0].output = -1;
    c.gates[0].op = '&';
    c.gates[1].input[0] = 1;
    c.gates[1].input[1] = 2;
    c.gates[1].output = -1;
    c.gates[1].op = '|';
    c.gates_wired[0][0] = 1;
    c.gates_wired[0][1] = -1;
    c.gates_wired[1][0] = -1;
    c.gates_wired[1][1] = -1;
    int vals[MAXWIRES] = {1, 0, 1};
    printf(""The result of evaluating the circuit is %d\n"", evaluate(&c, vals));
    return 0;
}",73,6.0
